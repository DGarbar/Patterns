# Мост

![UML](/src/AdditionalDocs/uml/Bridge/Bridge.png)

Разделяет один или несколько классов на **две отдельные иерархии - абстракцию и реализацию**, позволяя изменять их независимо друг от друга.

 ***«Абстракция»*** (или *«интерфейс»*) - это образный слой управления чем-либо. Он не делает работу самостоятельно, а **делегирует её слою *«реализации»* (иногда называемому *«платформой»*)**.

!!!
**Только не путайте эти термины с интерфейсами или абстрактными классами из вашего языка программирования, это не одно и то же.**

Если говорить о реальных программах, то **абстракцией может выступать графический интерфейс программы**, а **реализацией - API к которому интерфейс обращается по реакции на действия пользователя**.

## Применимость
 
 - Когда вы хотите разделить монолитный класс, который содержит **несколько различных реализаций какой-то функциональности (например, может работать с разными системами баз данных)**.

   - Чем больше класс, тем тяжелее разобраться в его коде, тем больше это затягивает разработку. Кроме того, изменения, вносимые в одну из реализаций, приводят к редактированию всего класса, что может привести к ошибкам.

      **Мост** позволяет разделить монолитный класс на несколько отдельных иерархий. После этого вы можете менять их код независимо друг от друга. Это упрощает работу над кодом и уменьшает вероятность внесения ошибок.

 - Когда класс нужно **расширять в двух независимых плоскостях**.

    - **Мост** предлагает выделить одну из таких плоскостей в отдельную иерархию классов, **храня ссылку на один из её объектов в первоначальном классе**.

 - Когда вы хотите, чтобы **реализацию можно было бы изменять во время выполнения программы**.

   - **Мост** позволяет заменять реализацию даже во время выполнения программы, так как конкретная реализация не «вшита» в класс абстракции.

     Кстати, из-за этого пункта **Мост** часто путают со [**Стратегией**][Strategy]. Обратите внимания, что у **Моста** этот пункт стоит на последнем месте по значимости, так как его **главная задача - структурная**.

## Шаги реализации
 
1. Определите, существует ли в ваших классах **два непересекающихся измерения**. Это может быть **функциональность/платформа, предметная-область/инфраструктура, фронт-энд/бэк-энд или интерфейс/реализация**.

2. Продумайте, какие операции будут нужны клиентам и опишите их в базовом классе абстракции.

3. **Определите поведения доступные на всех платформах** и выделите из них ту часть, **которая будет нужная абстракции**. На основании этого опишите общий интерфейс реализации.

4. Для каждой платформы создайте свой класс конкретной реализации. Все они должны следовать общему интерфейсу, который мы выделили перед этим.

5. **Добавьте в класс абстракции ссылку на объект реализации**. Реализуйте методы абстракции, **делегируя основную работу связанному объекту реализации**.

6. Если у вас есть несколько вариаций абстракции, создайте для каждой из них свой подкласс.

7. Клиент должен **подать объект реализации в конструктор абстракции**, чтобы связать их воедино. После этого он может свободно использовать объект абстракции, забыв о реализации.

## Преимущества и недостатки
 
  | + | - |
  | ------ | ------ |
 |Позволяет строить платформо-независимые программы.|Усложняет код программы за счёт дополнительных классов.
 |Скрывает лишние или опасные детали реализации от клиентского кода.
 |Реализует принцип [**открытости/закрытости**][OCP].
 
 ## Отношения с другими паттернами

- **Мост** проектируют загодя, чтобы развивать большие части приложения отдельно друг от друга. [**Адаптер**][Adapter] применяется постфактум, чтобы заставить несовместимые классы работать вместе.

- **Мост**, [**Стратегия**][Strategy] и [**Состояние**][State] (а также слегка и [**Адаптер**][Adapter]) имеют схожие структуры классов - все они построены на принципе [**«композиции»**][Composition], то есть делегирования работы другим объектам. Тем не менее, они отличаются тем, что решают разные проблемы. Помните, что паттерны - это не только рецепт построения кода определённым образом, но и описание проблем, которые привели к данному решению.

- [**Абстрактная фабрика**][Abstract_Factory] может работать совместно с **Мостом**. Это особенно полезно, если у вас есть абстракции, которые могут работать только с некоторыми из реализаций. В этом случае фабрика будет определять типы создаваемых абстракций и реализаций.

- Паттерн [**Строитель**][Builder] может быть построен в виде **Моста**: директор будет играть роль абстракции, а строители - реализации.

[OCP]: </src/AdditionalDocs/SOLID/Open-Closed_principle.md>
[Composition]: </src/AdditionalDocs/Composition.md>

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
