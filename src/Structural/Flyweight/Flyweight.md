# Приспособленец 

![UML](/src/AdditionalDocs/uml/Flyweight.png)

Позволяет вместить большее количество объектов в отведённую оперативной память за счёт **экономного разделения общего состояния объектов между собой, вместо хранения одинаковых данных в каждом объекте.**

**Неизменяемые данные объекта принято называть «*внутренним состоянием*». Все остальные данные - это «*внешнее состояние*»**.

#### Неизменяемость Легковесов

Так как **объекты легковесов** будут использованы в разных контекстах, вы должны быть уверены в том, что **их состояние невозможно изменять после создания (*final*)**. Всё внутреннее состояние легковес должен получать через параметры конструктора. Он не должен иметь сеттеров и публичных полей.

#### Фабрика Легковесов

**Flyweight** дополняет шаблон [**Factory Method**][Factory_Method] таким образом, что при обращении клиента [**Factory Method**][Factory_Method] для создания нового объекта ищет уже созданный объект с такими же параметрами, что и у требуемого, и возвращает его клиенту. Если такого объекта нет, то фабрика создаст новый.

Обычно этот метод добавляют в контейнер легковесов либо создают отдельный класс-фабрику. Его даже можно сделать статическим и поместить в класс легковесов.

## Применимость

- Когда **не хватает оперативной памяти для поддержки всех нужных объектов**.

  - Эффективность паттерна **Легковес** во многом зависит от того, как и где он используется. Применяйте этот паттерн, когда выполнены все перечисленные условия:

     - в приложении используется большое число объектов;

     - (из-за этого) высоки расходы оперативной памяти;

     - большую часть состояния объектов можно вынести за пределы их классов;

     - многие группы объектов можно заменить относительно небольшим количеством разделяемых объектов, поскольку внешнее состояние вынесено.

## Шаги реализации

1. Разделите поля класса, который станет легковесом, на две части:

   - **внутреннее состояние**: значения этих полей одинаковы для большого числа объектов.

   - **внешнее состояние (контекст)**: значения полей уникальны для каждого объекта.
   
2. **Оставьте поля внутреннего состояние в классе**, но убедитесь, что их значения неизменяемы. **Эти поля должны инициализироваться только через конструктор (final)**.

3. Превратите **поля внешнего состояния в аргументы методов**, где эти поля использовались. Затем, удалите поля из класса.

4. **Создайте фабрику, которая будет кешировать и повторно отдавать уже созданные объекты**. Клиент должен запрашивать легковеса с определённым внутренним состоянием из этой фабрики, а не создавать его напрямую.

5. Клиент должен хранить или вычислять значения внешнего состояния (контекст) и передавать его в методы объекта легковеса.

 ## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |Экономит оперативную память.|Расходует процессорное время на поиск/вычисление контекста.
 | |Усложняет код программы за счёт множества дополнительных классов.
 
 ## Отношения с другими паттернами

- [**Компоновщик**][Composite] часто совмещают с **Легковесом**, чтобы реализовать общие ветки дерева и сэкономить при этом память.

- **Легковес** показывает, как создавать много мелких объектов, а [**Фасад**][Facade] показывает, как создать один объект, который отображает целую подсистему.

- Паттерн **Легковес** может напоминать [**Одиночку**][Singleton], если для конкретной задачи у вас получилось уменьшить количество объектов к одному. Но помните, что между паттернами есть два кардинальных отличия:

  - В отличие от [**Одиночки**][Singleton], вы можете иметь множество объектов-легковесов.

  - Объекты-легковесов должны быть неизменяемыми, тогда как **объект-одиночки допускает изменение своего состояния**.
 
 
[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
