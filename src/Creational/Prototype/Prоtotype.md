# Прототип

![UML](/src/AdditionalDocs/uml/Prototype.png)

Позволяет создавать новые объекты на основе некоторого объекта-прототипа.

## Применимость
 
 - Когда ваш **код не должен зависеть от классов копируемых объектов**.

   - Такое часто бывает, если ваш код работает с объектами, поданными извне через какой-то общий интерфейс. Вы не можете привязаться к их классам, даже если бы хотели, так как их конкретные классы неизвестны.

     Паттерн **Прототип** предоставляет клиенту общий интерфейс для работы со всеми прототипами. Клиенту **не нужно зависеть от всех классов копируемых объектов, а только от интерфейса клонирования**.

 - Когда вы имеете уйму подклассов, которые отличаются начальными значениями полей. Кто-то создал эти классы, чтобы быстро создавать объекты с определённой конфигурацией.

   - **Прототип** предлагает использовать набор прототипов, вместо создания подклассов для популярных конфигураций объектов.

    Таким образом, вместо порождения объектов из подклассов, вы будете копировать существующие объекты-прототипы, в которых уже настроено внутреннее состояние. Это позволит избежать взрывного роста количества классов в программе и уменьшить её сложность.

## Шаги реализации
!!!

  (Поверхностное копирование)
- [Конструктор копирования][Ex1]

(Глубокое копирование)
- [Cloneable][Ex2]
- [Serialization][Ex3]

!!!

1. Создайте **интерфейс прототипов с единственным методом clone (Cloneable)**. Если у вас уже есть иерархия продуктов, метод клонирования можно объявить непосредственно в каждом из её классов.

2. Добавьте **в классы будущих прототипов альтернативный конструктор, принимающий в качестве аргумента объект текущего класса**. Этот конструктор должен скопировать из поданного объекта значения всех полей, объявленных в рамках текущего класса, а затем передать выполнение родительскому конструктору, чтобы тот позаботился об остальных полях.

   Если ваш язык программирования не поддерживает перегрузку методов, то копирование значений можно проводить и в другом методе, специально созданном для этих целей. Конструктор удобнее тем, что позволяет клонировать объект за один вызов.

3. **Метод клонирования обычно состоит всего из одной строки: вызова оператора new с конструктором прототипа. Все классы, поддерживающие клонирование, должны явно определить метод clone, чтобы подать собственный класс в оператор new. В обратном случае, результатом клонирования окажется объект родительского класса**.

4. Опционально, создайте **центральное хранилище прототипов**. В нём можно хранить вариации объектов, возможно даже одного класса, но по-разному настроенных.

   Вы можете разместить это хранилище либо в новом фабричном классе, либо в фабричном методе базового класса прототипов. Такой фабричный метод должен на основании входящих аргументов искать в каталоге прототипов подходящий экземпляр, а затем вызывать его метод клонирования и возвращать полученный объект.

    Наконец, нужно будет избавиться от прямых вызовов конструкторов объектов, заменив их вызовами фабричного метода хранилища прототипов.

 ## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |Позволяет клонировать объекты, не привязываясь к их конкретным классам.|Сложно клонировать составные объекты, имеющие ссылки на другие объекты.
 |Меньше повторяющегося кода инициализации объектов.
 |Ускоряет создание объектов.
 |Альтернатива созданию подклассов для конструирования сложных объектов.
 
## Отношения с другими паттернами

- Многие архитектуры начинаются с применения [**Фабричного метода**][Factory_method] (более простого и расширяемого через подклассы) и эволюционируют в сторону [**Абстрактной фабрики**][Abstract_Factory], **Прототипа** или [**Строителя**][Builder] (более гибких, но и более сложных).

- Классы [**Абстрактной фабрики**][Abstract_Factory] чаще всего реализуются с помощью [**Фабричного метода**][Factory_method], хотя они могут быть построены и на основе **Прототипа**.

- Если [**Команду**][Command] нужно копировать перед вставкой в историю выполненных команд, вам может помочь **Прототип**.

- Архитектура, построенная на [**Компоновщиках**][Composite] и [**Декораторах**][Decorator], часто может быть улучшена за счёт внедрения **Прототипа**. Он позволяет клонировать сложные структуры объектов, а не собирать их заново.

- **Прототип** не опирается на наследование, но ему нужна сложная операция инициализации. [**Фабричный метод**][Factory_method] наоборот, построен на наследовании, но не требует сложной инициализации.

- [**Снимок**][Memento] иногда можно заменить **Прототипом**, если объект, чьё состояние требуется сохранять в истории, довольно простой, не имеет активных ссылок на внешние ресурсы, либо их можно легко восстановить.

- [**Абстрактной фабрика**][Abstract_Factory], [**Строитель**][Builder] и **Прототип** могут быть реализованы при помощи [**Одиночки**][Singleton]. 

[Ex1]: <src/Creational/Prototype/Example/CopyConstructor/>
[Ex2]: <src/Creational/Prototype/Example/WithJDK/>
[Ex3]: <src/Creational/Prototype/Example/Serialization/>

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
