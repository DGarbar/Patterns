# Dependency Inversion Principle

**Принцип инверсии зависимостей (Dependency inversion principle, DIP)**

- Код должен зависеть от абстракций, а не от конкретных классов; 

  Класс, в котором используется `new`, автоматически становится зависимым от этой конкретной реализации, а не от абстракции

- Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций;

- Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
***

Рассмотрим классическую трехзвенную архитектуру:

![UML](/src/AdditionalDocs/uml/SOLID/DIP/noDIP.png)

**Высокоуровневые модули приложения не отделены от низкоуровневых реализаций**. Абстракции не отделены от деталей. Изменение логики в слое доступа к данным может неожиданно привести к поломке в модуле отображения. Тестировать такую систему будет очень сложно. Даже если получится написать модульные тесты, то любое изменение в системе приведет к тому, что эти тесты придется переписывать. В результате эта система обладает характеристиками:

1. **Жесткость**

     Тяжело менять систему, потому что каждое изменение затрагивает очень много различных ее частей.

2. **Хрупкость**

      Когда вы вносите изменения в одну часть системы, то в неожиданном месте ломается другая.

3. **Неподвижность**

      Очень сложно повторно использовать код в другом приложении, потому что модули сильно связаны между собой.

К чему мы пришли:

![UML](/src/AdditionalDocs/uml/SOLID/DIP/DIP.png)

В данном случае каждый слой отдельно представлен абстрактными классами/интерфейсами. Сам слой наследуется от этого абстрактного слоя (например, *Business Layer* реализует интерфейсы, которые объявлены в *Business Layer Abstract*). Все классы верхнего уровня используют нижележащий уровень через его абстрактный слой. Таким образом ни один слой не зависит от деталей другого. Напротив, они зависят только от абстракций.

Тут есть вопрос по реализации. Как класс из *UI Layer* узнает во время исполнения программы, какую реализацию надо использовать? 

1. Передача в конструктор или метод Set___(___ ___);

2. Создание фабрики.

<http://blog.byndyu.ru/2009/12/blog-post.html>