# Early binding, Static Binding
Присоединение вызова метода к телу метода называется связыванием.

- **Раннее**, потому что оно происходит ещё на этапе компиляции программы.
- **Статическое**, потому что его уже не изменить во время выполнения.
***

```
method exportShape(shape: Shape) is
    Exporter exporter = new Exporter()
    exporter.export(shape);
```
 В классе `Exporter` у нас есть пять версий метода с таким именем, которые **отличаются только типом параметра**. Похоже, здесь тоже придётся динамически отслеживать тип передаваемого параметра и по нему определять какой из методов выбрать.

Но здесь нас ждёт засада. Что если кто-то подаст в метод `exportShape` такой объект, для которого не существует метода `export(<?>)` в классе  `Exporter`? Например, объект `Ellipse`, для которого у нас нет экспорта. Действительно, у нас **нет гарантии что необходимый метод будет существовать, как это было с переопределенными методами. А значит, возникнет неоднозначная ситуация**.

Именно поэтому все **разработчики компиляторов выбирают безопасную тропинку и применяют раннее или статическое связывание для перегруженных методов**:

Вернемся к нашему примеру. Мы уверены в том, что имеем параметр с типом `Shape`. Мы знаем что в `Exporter` существует подходящая реализация: `export(s: Shape)`. Значит, этот участок кода мы жёстко связываем с известной реализацией метода.

**И поэтому даже если мы подадим в параметрах один из подклассов `Shape`, всё равно будет вызвана реализация `export(s: Shape)`.**

**(Грубо говоря, следить надо за ссылкой, а не за `new Object()`)**

**Для всех методов Java используется механизм позднего связывания, если только метод не был объявлен как `private` и в ситуациях описанных ниже**. Вызов `private` метода компилируется в инструкцию байт-кода *invokespecial*, которая вызывает реализацию метода из конкретного класса, определенного в момент компиляции. Вызов метода с другим уровнем доступа компилируется в *invokevirtual*, которая уже смотрит на тип объекта по ссылке в момент исполнения. Финальные неприватные методы тоже вызываются через *invokevirtual*.

**В инструкцию байт-кода *invokespesial* (Early) компилируются**:

- Инициализационный вызов (`<init>`) при создании объекта???

- Вызов `private` метода

- `static method`

- `final`

- Overload method

- Вызов метода с использованием ключевого слова `super`

- constructor

```java
public class Root{
  private void prt(){System.out.println("Root");}
  public static void main(String[] args){
    Root root = new Branch();
    root.prt(); // Root
    Branch branch = (Branch) root;
    branch.prt(); // Branch
  }
}
class Branch extends Root{
  final void prt() {System.out.println("Branch");}
}
```