# Принципы проектирования
(НЕ ЗАКОНЫ)

* **Изменяемые аспекты** приложения должны быть **отделенны** от постоянных;

* Программировать на уровне **интерфейсов**, а не на уровне реализаций;

* [**Композиция**][Composition]* лучше наследования;

* Стремиться к [**слабой связанности**][LowCoupling]* взаимодействующих объектов;

  - Выделять уровень абстракции, чтобы работать с **супер типом** (Полиморфизм)
  
* Используйте только одну точку. `(Class.method())`[**Принцип минимальной информированности**][Demetra];
  
## Solid
 
* У класса должна быть только 1 обязанность. Только 1 причина для изменения. [**Single Responsibility S_olid**][SRP];

* Классы открыты для расширения, но закрыты для изменения. [**Open/closed s_O_lid**][OCP];

* Наследующий класс должен дополнять, а не замещать поведение базового класса. [**Liskov Substitution so_L_id**][LSP];

* Клиенты не должны зависеть от методов, которые они не используют. [**Interface Segregation sol_I_d**][ISP];

* [**Инверсия управления (Голливудский принцип)**][IoC] ->>> [**Dependency-Inversion soli_D**][DIP];

## Ключевые принципы

* Don’t repeat yourself - [DRY][DRY];

* Keep it simple stupid - [KISS][KISS];

* You ain’t gonna need it - [YAGNI][YAGNI];

## Паттерны проектирования 

 | [**Порождающие**][Creational]: удобное и безопасное **создание** новых объектов | [**Структурные**][Structural]: **построение** удобных в поддержке иерархий классов | [**Поведенческие**][Behavioral]: эффективного и безопасного **взаимодействия** между объектами программы |
 | :------: | :------: |:------: |
 | [**Фабричный метод**][Factory_Method] | [**Адаптер**][Adapter] | [**Цепочка обязанностей**][Chain_of_Responsibility] |
 | [**Абстрактная фабрика**][Abstract_Factory] | [**Мост**][Bridge] | [**Команда**][Command] |
 | [**Строитель**][Builder] | [**Компоновщик**][Composite] | [**Итератор**][Iterator] |
 | [**Пул объектов**][Object_Pool] |[**Декоратор**][Decorator] | [**Посредник**][Mediator] |
 | [**Прототип**][Prototype] | [**Фасад**][Facade] | [**Снимок**][Memento] |
 | [**Одиночка**][Singleton] | [**Легковес**][Flyweight] | [**Наблюдатель**][Observer] |
 |  | [**Заместитель**][Proxy] |[**Состояние**][State] |
 |  | [**Выделение частного класса данных**][Private_Class_Data] |  [**Стратегия**][Strategy] |
 |  |  | [**Шаблонный метод**][Template_Method] |
 |  |  | [**Посетитель**][Visitor] |
 |  |  | [**Null объект**][Null_Object] |
 
 
[DRY]: </src/AdditionalDocs/DRY.md>
[KISS]: </src/AdditionalDocs/KISS.md>
[YAGNI]: </src/AdditionalDocs/YAGNI.md>

[BindingTypes]: </src/AdditionalDocs/BindingTypes/>  
[LowCoupling]: </src/AdditionalDocs/LowCoupling.md>
[Composition]: </src/AdditionalDocs/Composition.md>
[Demetra]: </src/AdditionalDocs/Principle_of_Least_Knowledge.md>
[IoC]: </src/AdditionalDocs/Inversion_of_Control.md>
[God-Object]: </src/AdditionalDocs/AntiPatterns/God-Object.md>
[SRP]: </src/AdditionalDocs/SOLID/Single_Responsibility_principle.md>
[OCP]: </src/AdditionalDocs/SOLID/Open-Closed_principle.md>
[LSP]: </src/AdditionalDocs/SOLID/Liskov_Substitution_principle.md>
[ISP]: </src/AdditionalDocs/SOLID/Interface_Segregation_principle.md>
[DIP]: </src/AdditionalDocs/SOLID/Dependency_Inversion_principle.md>


[Creational]: </src/Creational/>
[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Object_Pool]: </src/Creational/Object_Pool/Object_Pool.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Structural]: </src/Structural/>
[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>
[Private_Class_Data]: </src/Structural/Private_Class_Data/Private_Class_Data.md>


[Behavioral]: </src/Behavioral/>
[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
[Null_Object]: </src/Behavioral/Null_Object/Null_Object.md># Объект-бог

**Объект-бог** (God object) - антипаттерн объектно-ориентированного программирования, описывающий объект, который **хранит в себе «слишком много» или делает «слишком много»**.
***

Вместо того, чтобы общаться друг с другом непосредственно, другие объекты полагаются на божественный объект. Так как на божественный объект ссылается так много кода, его обслуживание (внесение изменений) становится сложным: велик риск сломать существующую функциональность.


Хотя божественные объекты считаются плохой практикой программирования, поскольку вредят поддерживаемости кода, **они могут быть полезны для работы при ограниченных ресурсах** (в микроконтроллерах или мобильных телефонах), где производительность важнее, чем поддерживаемость кода.
# Двойная диспетчеризация

**Двойная диспетчеризация** (double dispatch) - это трюк, позволяющий **обойти ограниченность раннего связывания в перегруженных методах**.
***

Вот как это делается:

```
class Visitor is
    method visit(s: Shape) is
        print("Visited shape")
    method visit(d: Dot)
        print("Visited dot")

interface Graphic is
    method accept(v: Visitor)

class Shape implements Graphic is
    method accept(v: Visitor)
        // Компилятор знает, что здесь `this` это `Shape`.
        v.visit(this)

class Dot extends Shape is
    method accept(v: Visitor)
        // Компилятор знает, что здесь `this` это `Dot`.
        // А значит можно статически связать этот вызов
        // с реализацией visit(d: Dot).
        v.visit(this)


Visitor v = new Visitor();
Graphic g = new Dot();

// Метод accept() – переопределен, но не перегружен. А значит, связан
// динамически. Поэтому реализация `accept` будет выбрана во время выполнения 
// уже из того класса, объект которого его вызвал (класс Dot).
g.accept(v);

// Выведет "Visited dot".
```
# Early binding, Static Binding
Присоединение вызова метода к телу метода называется связыванием.

- **Раннее**, потому что оно происходит ещё на этапе компиляции программы.
- **Статическое**, потому что его уже не изменить во время выполнения.
***

```
method exportShape(shape: Shape) is
    Exporter exporter = new Exporter()
    exporter.export(shape);
```
 В классе `Exporter` у нас есть пять версий метода с таким именем, которые **отличаются только типом параметра**. Похоже, здесь тоже придётся динамически отслеживать тип передаваемого параметра и по нему определять какой из методов выбрать.

Но здесь нас ждёт засада. Что если кто-то подаст в метод `exportShape` такой объект, для которого не существует метода `export(<?>)` в классе  `Exporter`? Например, объект `Ellipse`, для которого у нас нет экспорта. Действительно, у нас **нет гарантии что необходимый метод будет существовать, как это было с переопределенными методами. А значит, возникнет неоднозначная ситуация**.

Именно поэтому все **разработчики компиляторов выбирают безопасную тропинку и применяют раннее или статическое связывание для перегруженных методов**:

Вернемся к нашему примеру. Мы уверены в том, что имеем параметр с типом `Shape`. Мы знаем что в `Exporter` существует подходящая реализация: `export(s: Shape)`. Значит, этот участок кода мы жёстко связываем с известной реализацией метода.

**И поэтому даже если мы подадим в параметрах один из подклассов `Shape`, всё равно будет вызвана реализация `export(s: Shape)`.**

**(Грубо говоря, следить надо за ссылкой, а не за `new Object()`)**

**Для всех методов Java используется механизм позднего связывания, если только метод не был объявлен как `private` и в ситуациях описанных ниже**. Вызов `private` метода компилируется в инструкцию байт-кода *invokespecial*, которая вызывает реализацию метода из конкретного класса, определенного в момент компиляции. Вызов метода с другим уровнем доступа компилируется в *invokevirtual*, которая уже смотрит на тип объекта по ссылке в момент исполнения. Финальные неприватные методы тоже вызываются через *invokevirtual*.

**В инструкцию байт-кода *invokespesial* (Early) компилируются**:

- Инициализационный вызов (`<init>`) при создании объекта???

- Вызов `private` метода

- `static method`

- `final`

- Overload method

- Вызов метода с использованием ключевого слова `super`

- constructor

```java
public class Root{
  private void prt(){System.out.println("Root");}
  public static void main(String[] args){
    Root root = new Branch();
    root.prt(); // Root
    Branch branch = (Branch) root;
    branch.prt(); // Branch
  }
}
class Branch extends Root{
  final void prt() {System.out.println("Branch");}
}
```
# Dynamic binding, Runtime binding

Присоединение вызова метода к телу метода называется связыванием.

- **Поздним**, потому что мы связываем объект и реализацию уже после компиляции.
- **Динамическим**, потому что мы делаем это при каждом прохождении через этот участок.
***

```
class Exporter is
    method export(s: Shape) is
        print("Exporting shape")
    method export(d: Dot)
        print("Exporting dot")
    method export(c: Circle)
        print("Exporting circle")
    method export(r: Rectangle)
        print("Exporting rectangle")
    method export(cs: CompoundGraphic)
        print("Exporting compound")
```

Кажется, что всё хорошо. Но давайте испробуем такой класс в деле:

```
class App() is
    method export(shape: Shape) is
        Exporter exporter = new Exporter()
        exporter.export(shape);

app.export(new Circle());
// К сожалению, выведет "Exporting shape".
```

Итак, вызов метода `draw` в классе `Shape`. Но нам известно ещё и о четырёх классах переопределяющих этот метод. Можно ли уже сейчас понять какую реализацию нужно выбрать? Похоже, что нет, ведь для этого придётся запустить программу и узнать какой же объект будет подан в параметр. Но одно вы знаете точно — какой бы объект ни был передан, он точно будет иметь реализацию `draw`. *(Для примера, можно заполнять массив через рандом фигур)*

В результате машинный код, который вы создадите, будет **каждый раз при проходе через этот участок проверять что за объект этот `s`**, и выбирать реализацию метода `draw` из соответствующего класса.


```java
class King {
    King() {
        System.out.println("Call King constructor");
        speech();   //polymorphic method overriden in AerysTargaryen 
    } 
    public void speech() {
        System.out.println("I'm the King of the Andals!");
    }
}
 
class AerysTargaryen extends King {
    private String victimName;
 
    AerysTargaryen() {
        System.out.println("Call Aerys Targaryen constructor");
        victimName = "Lyanna Stark";
        speech();
    }
 
    @Override
    public void speech() {
        System.out.println("Burn " + victimName + "!");
    }
}
 
class Kingdom {
    public static void main(String[] args) {
        King king = new AerysTargaryen();
    }
}
```
Результат работы программы обусловлен выполнение алгоритма инициализации объекта:

1. Память, выделенная под новый объект, заполняется двоичными нулями.

2. Конструкторы базовых классов вызываются по иерархии. В этот момент вызывается переопределенный метод `speech()` ( перед вызовом конструктора класса `AerysTargaryen`), где обнаруживается, что переменная `victimName` равна null из-за первого этапа.

3. Вызываются инициализаторы членов класса в порядке их определения.

4. Исполняется тело конструктора производного класса.

**В частности из-за таких поведенческих моментов стоит придерживаться следующего правила написания конструкторов:**

 - **выполняйте в конструкторе лишь самые необходимые и простые действия по инициализации объекта**;
 
 - **по возможности избегайте вызова методов, не определенных как `private` или `final` (что в данном контексте одно и то же)**. 
# Композиция

Повторное использование кода может быть достигнуто с помощью как наследования, так и композиции.
Но при этом **задействование композиции обеспечивает более высокий уровень инкапсуляции**, чем наследование,
так как изменения в back-end классе не обязательно затронут код, который относится к front-end классу.

**Композиция** - это техника проектирования, применяющая в классах отношения типа **«has a»** (имеет, включает в себя).
Для повторного использования кода могут применяться как наследование в java, так и композиция объекта.
***

## Суть композиции 

Заключается в выражении отношения **«has a»** между объектами.
Подумайте о стуле. У стула есть (has a) сидение. У стула есть (has a) спинка. У стула есть (has a) определенное количество ножек.
Фраза "has a" / "есть" предполагает отношения, в которых стул имеет или, как минимум, использует другой объект. Это как раз и есть отношения "has a", являющиеся основой композиции.

#### Преимущества

* Контроль видимости;
* Реализация может быть заменена во время выполнения (run-time);
* [**Слабая связанность**][LowCoupling]*, так как класс-интерфейс не зависит от реализации.

### Различия между композицией и наследованием

| Композиция (has a / имеет) | Наследование (is a / является) |
| ------ | ------ |	
|	Поддерживает полиморфизм и повторное использование кода. | Поддерживает полиморфизм и повторное использование кода.|
|	Объект во время выполнения (run-time) уже создан.|	Объект создается динамически во время компиляции.|
|	Реализация может быть заменена во время выполнения (run-time).| Реализация может быть заменена во время компиляции.|
|	Подкласс не зависит от класса-родителя, что благоприятствует слабому связыванию (особенно под управлением интерфейса).|	Подкласс зависит от реализации класса-родителя, поэтому связывание считается сильным.|
|	В Доме есть Ванная комната. Неправильно говорить, что Дом - это Ванная комната.|	Наследование является однонаправленным: Дом - это Здание. Но здание не является домом.|

**!!! Не используйте наследование только для того, чтобы обеспечить повторное использование кода.
Если **нет отношений “is a“** (является), для этих целей используется **композиция**.**

### Разница между композицией и агрегацией в отношениях объектов.

**Агрегация (Делегирование)** - это взаимосвязь, при которой один класс вписывается в коллекцию. Это часть целого отношения, где **часть может существовать без целого**. Такие отношения гораздо слабее. Нет циклической зависимости. Например: **заказ и продукт**.
 - Один **объект получает ссылку (указатель)** на другой объект в процессе конструирования.
 
**Композиция** - это взаимосвязь, при которой один класс вписывается в коллекцию. Это часть целого отношения, **при которой часть не может существовать без целого**. Если целое уничтожается, все его составляющие тоже будут уничтожены. Это более сильные отношения. Например: многоугольник и его вершины, **заказ и его компонент**.
 - Один **объект создает другой объект** и время жизни "части" зависит от времени жизни целого.

[LowCoupling]: <LowCoupling.md>
# DRY – Don’t repeat yourself (не повторяй себя)

(DIE - Duplication is Evil)

- Принцип разработки программного обеспечения, нацеленный на **снижение повторения информации различного рода**, особенно в системах со множеством слоёв абстрагирования.
***

Когда принцип **DRY** применяется успешно, изменение единственного элемента системы не требует внесения изменений в другие, логически не связанные элементы.

**DRY** всегда приводит к декомпозиции сложных алгоритмов на простые функции. А декомпозиция сложных операций на более простые (и повторно используемые) значительно упрощает понимание программного кода. **Повторное использование функций, вынесенных из сложных алгоритмов, позволяет сократить время разработки и тестирования новой функциональности.**

Доступ к конкретному функционалу должен быть доступен в одном месте, унифицирован и сгруппирован по какому-либо принципу, а не «разбросан» по системе в произвольных вариациях.

Нарушения принципа **DRY** называют **WET** — *«Write Everything Twice»* или *"We enjoy typing"*.
# Инверсия управления (Голливудский принцип)

**Inversion of Control** - это некий абстрактный принцип, набор рекомендаций для написания слабо связанного кода. Суть которого в том, что каждый компонент системы должен быть **как можно более изолированным от других**, не полагаясь в своей работе на детали конкретной реализации других компонентов.
***

**Компоненты высокого уровня не должен зависеть от компонентов низкого уровня.**

Все подходы, основанные на инверсии управления, страдают от следующих **двух недостатков**:

 - Логика взаимодействия программы разбросана по отдельным обработчикам событий или классам;
 
 - Поток управления задан неявно и использует общее состояние (shared state) обработчиков событий.
 
 **Одной из реализаций IoC в применении к управлению зависимостями является [**внедрение зависимостей**][DIP]**. Внедрение зависимости используется во многих фреймворках, которые называются **IoC-контейнерами**.
 
 [DIP]: </src/AdditionalDocs/SOLID/Dependency_Inversion_principle.md>
# KISS - keep it simple stupid (делайте вещи проще)

- Принцип проектирования и программирования, при котором **простота системы декларируется в качестве основной цели или ценности**.
***

#### Правила

- Разбивайте **задачи на подзадачи** которые не должны по вашему мнению длиться более 4-12 часов написания кода.

- Разбивайте задачу на множество более маленьких задач, каждая задача должна решаться одним или парой классов.

- Сохраняйте ваши методы маленькими. Каждый **метод должен состоять не более чем из 30-40 строк**. Каждый метод должен решать одну маленькую задачу, а не множество случаев. **Если в вашем методе множество условий, разбейте его на несколько. Это повысит читаемость, позволит легче поддерживать код и быстрее находить ошибки в нём.** Вы полюбите улучшать код.

- Сохраняйте ваши классы маленькими. Здесь применяется та же техника что и с методами.

- Придумайте **решение задачи сначала, потом напишите код**. Никогда не поступайте иначе. Многие разработчики придумывают решение задачи во время написания кода и в этом нет ничего плохого. Вы можете делать так и при этом придерживаться выше обозначенного правила. Если вы можете в уме разбивать задачу на более мелкие части, когда вы пишете код, делайте это любыми способами. И **не бойтесь переписывать код ещё и ещё и ещё…** В счёт не идёт число строк, до тех пор пока вы считаете что можно ещё меньше/ещё лучше.

- **Не бойтесь избавляться от кода**. Изменение старого кода и написание нового решения два очень важных момента. Если вы столкнулись с новыми требованиями, или не были оповещены о них ранее, тогда порой лучше придумать новое более изящное решение решающее и старые и новые задачи.

# Слабая связанность

**Связность** (coupling) - это взаимная зависимость реализации классов между собой, то есть индикатор количества изменений, которые нужно внести в классы при изменении одного класса. 

**Слабая связность означает, что изменения, вносимые в один класс повлекут за собой небольшие изменения в другие классы, то есть упростит рефакторинг кода, при необходимости**. 
***

 Самый простой пример уменьшения связности кода - это не использовать для классов открытые (public) поля, вместо чего следует использовать модификаторы доступа - геттеры и сеттеры. Таким образом, при изменении названия поля внутри класса не понадобится переписывать код где-либо еще.

Все придуманные шаблоны проектирования (design patterns) придуманы именно для того, чтобы снижать связность кода.

**Определяется по сложности (количеству необходимых изменений) которые возникают
при расширении.**
# Принцип минимальной информированности (Закон Деметры)

!!! Может быть перефразирован как **«Используйте только одну точку»** 

Каждый программный модуль должен:

- обладать ограниченным знанием о других модулях: знать о модулях, которые имеют «непосредственное» отношение к этому модулю.

- взаимодействовать только с известными ему модулями «друзьями», не взаимодействовать с незнакомцами.

- обращаться только к непосредственным «друзьям».
***

**Аналогия из жизни**: Если вы хотите, чтобы собака побежала, глупо командовать её лапами, лучше отдать команду собаке, а она уже разберётся со своими лапами сама.

Основной идеей является то, что **объект должен иметь как можно меньше представления о структуре и свойствах чего угодно** (включая собственные подкомпоненты).


В объекте можно вызывать методы принадлежащие только:

- самому объекту;

- объектам, переданным в параметрах метода;

- любому объекту созданному внутри метода;

- любим компонентам объекта ([**Композиция**][Composition]).

[Composition]: </src/AdditionalDocs/Composition.md> 
# Dependency Inversion Principle

**Принцип инверсии зависимостей (Dependency inversion principle, DIP)**

- Код должен зависеть от абстракций, а не от конкретных классов; 

  Класс, в котором используется `new`, автоматически становится зависимым от этой конкретной реализации, а не от абстракции

- Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций;

- Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
***

Рассмотрим классическую трехзвенную архитектуру:

![UML](/src/AdditionalDocs/uml/SOLID/DIP/noDIP.png)

**Высокоуровневые модули приложения не отделены от низкоуровневых реализаций**. Абстракции не отделены от деталей. Изменение логики в слое доступа к данным может неожиданно привести к поломке в модуле отображения. Тестировать такую систему будет очень сложно. Даже если получится написать модульные тесты, то любое изменение в системе приведет к тому, что эти тесты придется переписывать. В результате эта система обладает характеристиками:

1. **Жесткость**

     Тяжело менять систему, потому что каждое изменение затрагивает очень много различных ее частей.

2. **Хрупкость**

      Когда вы вносите изменения в одну часть системы, то в неожиданном месте ломается другая.

3. **Неподвижность**

      Очень сложно повторно использовать код в другом приложении, потому что модули сильно связаны между собой.

К чему мы пришли:

![UML](/src/AdditionalDocs/uml/SOLID/DIP/DIP.png)

В данном случае каждый слой отдельно представлен абстрактными классами/интерфейсами. Сам слой наследуется от этого абстрактного слоя (например, *Business Layer* реализует интерфейсы, которые объявлены в *Business Layer Abstract*). Все классы верхнего уровня используют нижележащий уровень через его абстрактный слой. Таким образом ни один слой не зависит от деталей другого. Напротив, они зависят только от абстракций.

Тут есть вопрос по реализации. Как класс из *UI Layer* узнает во время исполнения программы, какую реализацию надо использовать? 

1. Передача в конструктор или метод Set___(___ ___);

2. Создание фабрики.

<http://blog.byndyu.ru/2009/12/blog-post.html>
# Interface Segregation Principle

**Принцип разделения интерфейса (Interface Segregation Principle, ISP)**

- Клиенты не должны зависеть от методов, которые они не используют.
***

Принцип разделения интерфейсов говорит о том, что **слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические**, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.
# Liskov Substitution Principle

**Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP)**

- Пусть `q(x)` является свойством, верным относительно объектов `x` некоторого типа `T`. Тогда `q(y)` также должно быть верным для объектов `y` типа `S`, где `S` является подтипом типа `T`.

или

- Наследующий класс должен дополнять, а **не замещать поведение базового класса**.

или

- Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.
***

**Замещения** - если `S` является подтипом `T`, тогда объекты типа `T` в программе могут быть замещены объектами типа `S` без каких-либо изменений желательных свойств этой программы.

Более простыми словами можно сказать, что **поведение наследуемых классов не должно противоречить поведению, заданному базовым классом**, то есть поведение наследуемых классов должно быть ожидаемым для кода, использующего переменную базового типа.

 *«Подкласс не должен требовать от вызывающего кода больше, чем базовый класс, и не должен предоставлять вызывающему коду меньше, чем базовый класс»* (Саттер и Александреску)
 
 
 
# Open-Closed Principle

**Принцип открыт/закрыт (Open-Closed Principle, OCP)**

Программные сущности (классы, модули, функции и т. п.) должны быть **открыты для расширения, но закрыты для модификации**.

 - **Они открыты для расширения**.
  
      Это означает, что поведение модуля можно расширить. Когда требования к приложению изменяются, мы добавляем в модуль новое поведение, отвечающее изменившимся требованиям. Иными словами, мы можем изменить состав функций модуля.
 
 - **Они закрыты для модификации**. 
 
     Расширение поведения модуля не сопряжено с изменениями в исходном или двоичном коде модуля. **Двоичное исполняемое представление модуля, будь то компонуемая библиотека, DLL или EXE-файл, остается  неизменным**.
 ***
 
 При этом понятия открытости и закрытости определяются так:
 
  - **Модуль называют открытым**, если он еще доступен для расширения. Например, имеется возможность расширить множество операций в нем или добавить поля к его структурам данных.
  
  - **Модуль называют закрытым**, если он доступен для использования другими модулями. Это означает, что модуль (его интерфейс - с точки зрения скрытия информации) уже имеет **строго определенное окончательное описание**. На уровне реализации закрытое состояние модуля означает, что модуль можно компилировать, сохранять в библиотеке и делать его доступным для использования другими модулями (его клиентами).
  
 Но всегда ли нам нужно создавать наследника? Нет, не всегда! Даже такой ОО-гуру как Мейер, который описывает в своей книге 12 видов наследования, относится к расширяемости модулей путем создания наследников с разумным прагматизмом: 
 
 *«Если имеется возможность переписать исходную программу так, чтобы она, без излишнего усложнения, смогла удовлетворять потребности нескольких разновидностей клиентов, то следует это сделать»*.
  
 Естественно, модуль должен модифицироваться при наличии в нем ошибок: 
 
 *«Как принцип Открыт-Закрыт, так и переопределение в механизме наследования не позволяет справиться с дефектами разработки, не говоря уже об ошибках в программе. **Если в модуле что-то не в порядке, то следует это сразу исправить в исходной программе**, не пытаясь разбираться возникающей проблемой в производном модуле»*
 
 
 
 ## Принцип единственного выбора
 
 ```
 abstract class Importer
 {
     public abstract void ImportData();
 }
  
 static class ImporterFactory
 {
     public static Importer Create(string fileName)
     {
         Contract.Requires(!string.IsNullOrEmpty(fileName));
         Contract.Ensures(Contract.Result<Importer>() != null);
  
         var extension = Path.GetExtension(fileName);
         switch (extension)
         {
             case "json":
                 return new JsonImporter();
             case "xls":
             case "xlsx":
                 return new XlsImporter();
             default:
                 throw new InvalidOperationException(
                   "Extension is not supported");
         }
     }
 ```
 
 Отвечает ли реализация такой фабрики принципу **Open/Close**? Или для соответствия этому принципу нам нужно вводить интерфейс `IImporterFactory` и еще одну иерархию - иерархию фабрик? А кто будет создавать фабрику? С помощью фабрики фабрик?
 
 [**Фабричный метод**][Factory_Method] сам по себе и так уже прячет от своих клиентов способ получения нужного `Importer`-а и дополнительный уровень косвенности здесь не нужен.
 
 Вот что пишет Бертран Мейер по этому поводу: 
 
 *«Необходимо допускать возможность того, что **список вариантов**, заданных и известных на некотором этапе разработки программы, может **в последующем быть изменен** путем добавления или удаления вариантов. Чтобы обеспечить реализацию такого подхода к процессу разработки программного обеспечения, нужно найти способ защитить структуру программы от воздействия подобных изменений. Отсюда следует принцип **Единственного Выбора**»*
 
 **Принцип единственного выбора**: всякий раз, когда система программного обеспечения должна поддерживать множество альтернатив, их **полный список должен быть известен только одному модулю системы**.
 
 ## Какую проблему призван решить принцип Открыт/Закрыт?
 
 Смысл принципа OCP довольно прост: дизайн системы должен быть простым и устойчивым к изменениям.
 
  - **Во-первых, за счет абстракции и инкапсуляции**. Мы выделяем существенные части системы в виде интерфейсов и абстрактных классов, не задумываясь о реализации, которая будет скрыта от клиентов. Но даже конкретный класс, унаследованный от `System.Object` представляет собой абстракцию. Класс `String` абстрагирует нас от конкретного представления строки и многих других подробностей, хотя и не реализует интерфейс `IString`.
 
    Любой класс моделирует абстракцию: его **открытый интерфейс акцентирует внимание на важной составляющей класса**, оставляя в закрытой части ненужные подробности. Это позволяет думать о классе, как о черном ящике, который представляет определенные услуги лишь ему известным способом.
 
  - **Во-вторых, за счет наследования**. Мы используем наследование для полиморфного поведения, что позволяет использовать базовые классы в подавляющем числе мест приложения, а также использовать повторно значительные куски кода.
  
  !!!
 **Абстракция не подразумевает наличие наследования. Абстракция не может существовать без инкапсуляции!** *(книга Гради Буча «Объектно-ориентированный анализ и проектирование»)
  
 ## Заключение
 **Что такое OCP?** Это фиксация интерфейса класса/модуля, и возможность изменения или подмены реализации/поведения.
 
 **Цели OCP**: Борьба со сложностью и ограничение изменений минимальным числом модулей.
 
 **Как мы реализуем OCP?** С помощью инкапсуляции. Она позволяет изменять реализацию без изменения интерфейса и с помощью наследования. Наследование уже в свою очередь позволяет заменить реализацию, которая не затронет существующих клиентов базового класса.
 
 
 [Factory_Method]:</src/Creational/Factory_Method/Factory_Method.md>
# Single Responsibility Principle

**Принцип единственной ответственности (The Single Responsibility Principle, SRP)**

- **Каждый объект должен иметь одну ответственность и эта ответственность должна быть полностью инкапсулирована в класс**. Все его поведения должны быть направлены исключительно на обеспечение этой ответственности.

**Robert C. Martin определяет ответственность как причину изменения и заключает, что классы должны иметь одну и только одну причину для изменений**. 
***

Например, представьте себе класс, который составляет и печатает отчёт. Такой класс может измениться по двум причинам:

- может измениться само содержимое отчёта;

- может измениться формат отчёта.

Логично, что оба аспекта этих причин на самом деле являются двумя разными ответственностями. **SRP** говорит, что в таком случае нужно **разделить класс на два новых класса, для которых будет характерна только одна ответственность**. Причина, почему нужно сохранять направленность классов на единственную цель в том, что это делает классы более здоровыми. Что касается класса, приведённого выше, если произошло изменение в процессе составления отчёта - есть большая вероятность, что в негодность придёт код, отвечающий за печать.

## Использование 
Возникает вопрос, когда стоит использовать этот принцип? Всё же **принцип - это не закон и SRP стоит применять в зависимости от того, как изменяется приложение**:

- если **при изменении кода, отвечающего за одну ответственность, в приложении появляются исправления кода, отвечающего за другую ответственность**, то это первый сигнал о нарушении SRP.

  - если же изменения кода, отвечающего за одну ответственность, не вносят изменения в код, отвечающий за другую ответственность, то этот принцип можно не применять.
  
**Слепое следование принципу единственной ответственности приводит к избыточной сложности приложения, его поддержки и тестированию.**SRP** стоит применять только тогда, когда это оправдано.**
 
 Принцип **SRP** можно применить только в том случае, когда:

- объекту класса становится позволительно слишком много;

- доменная логика концентрируется только в одном классе;

- любое изменение логики поведения объекта приводит к изменениям в других местах приложения, где это не подразумевалось изначально;

- приходится тестировать, исправлять ошибки, компилировать различные места приложения, даже если за их работоспособность отвечает третья сторона;

- невозможно легко отделить и применить класс в другой сфере приложения, так как это потянет ненужные зависимости.  
# You ain’t gonna need it (Вам это не понадобится)

- [**KISS**][KISS] старается искать простые решения, а **YAGNI** просто не делает никаких решений!

- В качестве основной цели и/или ценности декларируется **отказ от избыточной функциональности, - то есть отказ добавления функциональности, в которой нет непосредственной надобности**.
***

#### Планирование проекта

Начиная планирование нового проекта, постарайтесь учесть следующее:

- Достичь меньшей сложности путем уменьшения уровня абстракций.

  Подумайте, вам действительно нужен Hibernate? Старайтесь тщательнее оценивать все, что может добавить сложности вашей системе. Учтите, что зачастую многие абстракции реализовываются в сторонних продуктах и библиотеках. Каждая из новых библиотек добавляет сложности. Обновления, патчи, исправления в безопасности - все это вам придется делать/применять в будущем.

- Разделить функционал от возможностей (features).

- Учесть небольшие не-функциональные требования.

- Определить затратные по времени задачи, чтобы избавиться от них.

#### Последствия YAGNI

- **Тратится время**, которое было бы затрачено на добавление, тестирование и улучшение необходимой функциональности.

- Новые функции должны быть отлажены, документированы и сопровождаться.
Новая функциональность ограничивает то, что может быть сделано в будущем, - **ненужные новые функции могут впоследствии помешать добавить новые нужные**.

  Если вся функциональность не документирована, она может так и остаться неизвестной пользователям, но может создать для безопасности пользовательской системы различные риски.

- Пока новые функции действительно не нужны, **трудно полностью предугадать, что они должны делать, и протестировать их**. Если новые функции тщательно не протестированы, они могут неправильно работать, когда впоследствии понадобятся.

- Это приводит к тому, что программное обеспечение становится более сложным (подчас чрезмерно сложным).

- Добавление новой функциональности может **привести к желанию ещё более новой функциональности, приводя к эффекту «снежного кома».**


**Также важно понимать, что все это вовсе не значит, что можно сесть и писать плохой код**, приправленный хаками. Вы просто пишете небольшое приложение, а не плохое! Можно согласиться на немного возросшие затраты по поддержке - мы живем в реальном мире.

[KISS]: </src/AdditionalDocs/KISS.md>
# Цепочка обязанностей 

![UML](/src/AdditionalDocs/uml/Chain_of_Responsibility.png)

Позволяет **передавать запросы последовательно по цепочке обработчиков**. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.

## Применимость

- Когда **программа содержит несколько объектов, способных обработать тот или иной запрос, однако заранее неизвестно какой запрос придёт и какой обработчик понадобится**.

  - Вы связываете потенциальных обработчиков в одну цепь и поочерёдно спрашиваете, хочет ли данный объект обработать запрос. Если нет, двигаетесь дальше по цепочке.

- Когда важно, чтобы **обработчики выполнялись один за другим в строгом порядке**.

  - Цепочка обязанностей позволяет запускать обработчики последовательно один за другим в определённом порядке.

- Когда **набор объектов, способных обработать запрос, должен задаваться динамически**.

  - В любой момент вы можете вмешаться в существующую цепочку и **переназначить связи так, чтобы убрать или добавить новое звено**.

## Шаги реализации

1. Создайте **интерфейс обработчика** и опишите в нём основной метод обработки.

   Продумайте, в каком виде клиент должен передавать данные запроса в обработчик. **Самый гибкий способ** - *превратить данные запроса в объект и передавать его целиком через параметры метода обработчика*.

2. Имеет смысл создать **абстрактный базовый класс обработчиков**, чтобы не дублировать **реализацию метода получения следующего обработчика** во всех конкретных обработчиках.

   Добавьте в базовый обработчик **поле для хранения ссылки на следующий объект цепочки**. Устанавливайте **начальное значение этого поля через конструктор**. Это сделает объекты обработчиков неизменяемыми. Но если программа предполагает динамическую перестройку цепочек, **можете добавить и сеттер для поля**.

   Реализуйте здесь метод обработки так, чтобы он перенаправлял запрос следующему объекту, проверив его наличие. Это позволит полностью скрыть поле-ссылку от подклассов, дав им возможность передавать запросы дальше по цепи, обратившись к родительской реализации метода.

3. Один за другим создайте классы конкретных обработчиков и реализуйте в них методы обработки запросов. При получении запроса каждый обработчик должен решить:

    - Может он обработать запрос или нет?
    - Следует передать запрос следующему обработчику или нет?

4. **Клиент может собирать цепочку обработчиков самостоятельно**, опираясь на свою бизнес-логику, либо получать уже готовые цепочки извне. В последнем случае, **цепочки собирают фабричные объекты исходя из конфигурации приложения или текущего окружения**.

5. **Клиент может посылать запросы любому обработчику в цепи, а не только первому.** Запрос будет передаваться по цепочке пока какой-то обработчик не откажется передавать его дальше, либо когда будет достигнут конец цепи.

6. Клиент должен знать о динамической природе цепочки и быть готов к таким случаям:

    - Цепочка может состоять из единственного объекта.
    - Запросы могут не достигать конца цепи.
    - Запросы могут достигать конца, оставаясь необработанными.
 
## Преимущества и недостатки

 | + | - |
 | ------ | ------ |
 |Уменьшает зависимость между клиентом и обработчиками.|Запрос может остаться никем не обработанным. +-
 |Соблюдает [**принцип единственной обязанности класса**][SRP].
 |Соблюдает принцип [**открытости/закрытости**][OCP].
 
## Отношения с другими паттернами

- **Цепочка обязанностей**, [**Команда**][Command], [**Посредник**][Mediator] и [**Наблюдатель**][Observer] показывают различные способы работы отправителей запросов с их получателями:

  - **Цепочка обязанностей** передаёт запрос последовательно через цепочку потенциальных получателей, ожидая, что какой-то из них обработает запрос.

  - [**Команда**][Command] устанавливает косвенную одностороннюю связь от отправителей к получателям.
  
  - [**Посредник**][Mediator] убирает прямую связь между отправителями и получателями, заставляя их общаться опосредованно, через себя.
  
  - [**Наблюдатель**][Observer] передаёт запрос одновременно всем заинтересованным получателям, но позволяет им динамически подписывать или отписываться от таких оповещений.

- **Цепочку обязанностей** часто используют вместе с [**Компоновщиком**][Composite]. В этом случае, запрос передаётся от дочерних компонентов к их родителям.

- Обработчики в **Цепочке обязанностей** могут быть выполнены в виде [**Команд**][Command]. В этом случае множество разных операций может быть выполнено над одним и тем же контекстом, коим является запрос.

  Но есть и другой подход, в котором сам запрос является [**Командой**][Command], посланной по цепочке объектов. В этом случае одна и та же операция может быть выполнена над множеством разных контекстов, представленных в виде цепочки.

- **Цепочка обязанностей** и [**Декоратор**][Decorator] имеют очень похожие структуры. Оба паттерна базируются на принципе рекурсивного выполнения операции через серию связанных объектов. Но есть и несколько важных отличий.

  Обработчики в **Цепочке обязанностей** могут выполнять произвольные действия, независимые друг от друга, а также в любой момент прерывать дальнейшую передачу по цепочке. С другой стороны [**Декораторы**][Decorator] расширяют какое-то определённое действие, не ломая интерфейс базовой операции и не прерывая выполнение остальных декораторов.


[SRP]: </src/AdditionalDocs/SOLID/Single_Responsibility_principle.md>
[OCP]: </src/AdditionalDocs/SOLID/Open-Closed_principle.md>

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
```java
package Behavioral.Chain_of_Responsibility.Example.Db;

import java.util.HashMap;
import java.util.Map;

//Mock DB
public class DB {

  public static Map<String, Integer> users;

  static {
    users = new HashMap<>();
    users.put("Dima", 1);
    users.put("User", 1234);
    users.put("Admin", 0);
    users.put("Cat", 9990);
  }

}
```
```java
package Behavioral.Chain_of_Responsibility.Example;

import Behavioral.Chain_of_Responsibility.Example.Steps.Authentication;
import Behavioral.Chain_of_Responsibility.Example.Steps.Authorization;
import Behavioral.Chain_of_Responsibility.Example.Steps.Registration;
import Behavioral.Chain_of_Responsibility.Example.Steps.SpellCheck;
import Behavioral.Chain_of_Responsibility.Example.Steps.Step;

public class Ex {

  public static void main(String[] args) {
    Step spellCheck = new SpellCheck();
    Step registration = new Registration();
    Step authorization = new Authorization(registration);
    Step authentication = new Authentication();

    // First we check on accepted symbols,
    spellCheck.setNextStep(authorization);
    // then going to checking if we have this name in DB,
    authorization.setNextStep(authentication);
    // if we haven't we go to registration,
    registration.setNextStep(authentication);
    // we can add addPrevStep (Deque)

    //After all steps we checking password + name
    authentication.setNextStep(null);

    System.out.println("Dimasdasd + 112");
    spellCheck.check("Dimasdasd", 112);//wrong all
    System.out.println("Dima + 1");
    spellCheck.check("Dima", 12222); //wrong pass
    System.out.println("Admin + 0");
    spellCheck.check("Admin", 0); //all good
  }

}
```
```java
package Behavioral.Chain_of_Responsibility.Example.Steps;

import Behavioral.Chain_of_Responsibility.Example.Db.DB;

public class Authentication extends Step {

  /*
   * Last step.
   * Verify password with name from DB.
   */

  @Override
  public boolean check(String name, int pas) {
    System.out.println("Authentication....");
    if (DB.users.get(name) == pas) {
      System.out.println("You are in");
      System.out.println("Welcome");
      return true;
    } else {
      System.out.println("Passs is wrong");
      return false;
    }
  }
}
```
```java
package Behavioral.Chain_of_Responsibility.Example.Steps;

import Behavioral.Chain_of_Responsibility.Example.Db.DB;
import java.util.Scanner;

public class Authorization extends Step {

  private Step regStep;
  private Scanner sc = new Scanner(System.in);

  public Authorization(Step regStep) {
    this.regStep = regStep;
  }

  /*
   * Second step.
   * Verify that the user is in the DB.
   * If not, propose to create new user (go to Registration step)
   * else go to Authentication step
   */

  @Override
  public boolean check(String name, int pas) {
    System.out.println("Authorization...");
    if (DB.users.containsKey(name)) {
      return checkNext(name, pas);
    } else {
      if (isReg()) {
        regStep.check(name, pas);
      }
    }
    return false;
  }

  private boolean isReg() {
    System.out.println("Your name is incorrect");
    System.out.println("Do you want to register? Y/N");
    return sc.next().equalsIgnoreCase("y");
  }

}
```
```java
package Behavioral.Chain_of_Responsibility.Example.Steps;

import Behavioral.Chain_of_Responsibility.Example.Db.DB;
import java.util.Scanner;

public class Registration extends Step {

  private Scanner sc = new Scanner(System.in);

  /*
   * Possible step.
   * Verify that the user is in the DB.
   * if hasn't, add to DB new User,
   * and then go to Authentication Step (next Step).
   */

  // Also can we can use Deque (have previous step) for returning to authorization.
  // but y menya lapki
  @Override
  public boolean check(String name, int pas) {
    System.out.println("Registration...");
    while (true) {
      if (DB.users.containsKey(name)) {
        System.out.println("Name already used");
        System.out.println("You want to exit? Y/N");
        if (sc.next().equalsIgnoreCase("y")) {
          return false;
        }
      } else {
        System.out.println("Write down Pas: ");
        pas = sc.nextInt();

        //adding new User in DB

        DB.users.put(name, pas);
        return checkNext(name, pas);
      }

      System.out.println("Write down Name: ");
      name = sc.next();
    }
  }
}
```
```java
package Behavioral.Chain_of_Responsibility.Example.Steps;

public class SpellCheck extends Step {

  /*
   * First step.
   * Check symbols.
   * If name is valid go to Authorization step.
   */

  @Override
  public boolean check(String name, int pas) {
    System.out.println("SpellChecking...");
    if (name.isEmpty()) {
      System.out.println("You mast wrote something");
    } else if (name.matches("\\w*")) {
      return checkNext(name, pas);
    } else {
      System.out.println("Invalid name");
    }
    return false;
  }
}
```
```java
package Behavioral.Chain_of_Responsibility.Example.Steps;

public abstract class Step {

  private Step nextStep;

  //We also can put NextStep in constructor
  //Also can be previous step (Deque) but y menya lapki
  public void setNextStep(Step step) {
    this.nextStep = step;
  }

  public abstract boolean check(String name, int pas);

  public boolean checkNext(String name, int pas) {
    if (nextStep == null) {
      return true;
    }
    return nextStep.check(name, pas);
  }

}
```
# Команда 

![UML](/src/AdditionalDocs/uml/Command/Command.png)

**Превращает запросы в объекты**, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также **поддерживать отмену операций**.
 
 Соблюдение [**Dependency-Inversion**][DIP]
![UML](/src/AdditionalDocs/uml/Command/ex1.png)
![UML](/src/AdditionalDocs/uml/Command/ex1_sol.png)

## Применимость
 - Когда вы хотите параметризовать объекты выполняемым действием.

   - Команда превращает операции в объекты. А объекты можно **передавать, хранить и взаимозаменять внутри других объектов**.

     Скажем, вы разрабатываете библиотеку графического меню и хотите, чтобы пользователи могли использовать меню в разных приложениях, не меняя каждый раз код ваших классы. Применив паттерн, пользователям не придётся изменять классы меню, вместо этого они будут **конфигурировать объекты меню различными командами**.

 - Когда вы хотите **ставить операции в очередь, выполнять их по расписанию или передавать по сети**.

   - Как и любые другие объекты, **команды можно сериализовать**, то есть превратить в строку, чтобы потом сохранить в файл или базу данных. Затем, в любой удобный момент, её можно достать обратно, снова превратить в объект команды, и выполнить. Таким же образом **команды можно передавать по сети, логировать или выполнять на удалённом сервере**.

 - Когда вам нужна **операция отмены**.

   - Главная вещь, которая вам нужна, чтобы иметь возможность **отмены операций - это хранение истории**. Среди многих способов как это делается, паттерн **Команда** является, пожалуй, самым популярным.

     История команд выглядит как стек, в который попадают все выполненные объекты команд. Каждая команда перед выполнением операции сохраняет текущее состояния объекта, с которым она будет работать. После выполнения операции, копия команды попадает в стек истории, все ещё неся в себе сохранённое состояние объекта. Если потребуется отмена, программа возьмёт последнюю команду из истории и возобновит сохранённое в ней состояние.

     Этот способ имеет две особенности. **Во-первых, точное состояние объектов не так-то просто сохранить, ведь часть его может быть приватным. Но с этим может помочь справиться паттерн [**Снимок**][Memento].**

     **Во-вторых, копии состояния могут занимать довольно много оперативной памяти**. Поэтому иногда можно прибегнуть к альтернативной реализации, когда вместо восстановления старого состояния, команда выполняет обратное действие. **Недостаток этого способа в сложности** (а иногда и невозможности) реализации обратного действия.
     
 ## Шаги реализации

1. Создайте **общий интерфейс команд** и определите в нём метод запуска (`execute()`).

2. Создайте классы конкретных команд. **В каждом классе должно быть поле для хранения ссылки на один или несколько объектов-получателей, которым команда будет перенаправлять основную работу** (Делегирование).

   Кроме этого, команда должна иметь поля для хранения параметров, которые нужны при вызове методов получателя. Значения всех этих полей команда должна получать через конструктор.

   И наконец, реализуйте основной метод команды, вызывая в нём те или иные методы получателя.

3. Добавьте в классы отправителей поля для хранения команд. Объект-отправитель должен принимать готовый объект команды извне через конструктор, либо через сеттер команды.

4. **Измените основной код отправителей так, чтобы они делегировали выполнение действия команде**.

5. Порядок инициализации объектов должен выглядеть так:

 - Создаём объекты получателей. (Создаем лампочку)
 - Создаём объекты команд, связав их с получателями. (Создаем команду вклСвет, передаем в нее лампочку)
 - Создаём объекты отправителей, связав их с командами. (Создаем пульт, передаем в него команду)
 
 ## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |**Убирает прямую зависимость между объектами, вызывающими операции и объектами, которые их непосредственно выполняют**. |Усложняет код программы за счёт дополнительных классов.
 |Позволяет реализовать простую **отмену и повтор операций**.
 |Позволяет реализовать **отложенный запуск команд**.
 |Позволяет **собирать сложные команды из простых**.
 |Соблюдает принцип [**открытости/закрытости**][OCP].

## Отношения с другими паттернами

- [**Цепочка обязанностей**][Chain_of_Responsibility], **Команда**, [**Посредник**][Mediator] и [**Наблюдатель**][Observer] показывают различные способы работы отправителей запросов с их получателями:

  - [**Цепочка обязанностей**][Chain_of_Responsibility] передаёт запрос последовательно через цепочку потенциальных получателей, ожидая, что какой-то из них обработает запрос.
  
  - **Команда** устанавливает косвенную одностороннюю связь от отправителей к получателям.
  
  - [**Посредник**][Mediator] убирает прямую связь между отправителями и получателями, заставляя их общаться опосредованно, через себя.
  
  - [**Наблюдатель**][Observer] передаёт запрос одновременно всем заинтересованным получателям, но позволяет им динамически подписывать или отписываться от таких оповещений.

 - Обработчики в [**Цепочке обязанностей**][Chain_of_Responsibility] могут быть выполнены в виде **Команд**. В этом случае множество разных операций может быть выполнено над одним и тем же контекстом, коим является запрос.

    Но есть и другой подход, в котором сам запрос является **Командой**, посланной по цепочке объектов. В этом случае одна и та же операция может быть выполнена над множеством разных контекстов, представленных в виде цепочки.

 - **Команду** и [**Снимок**][Memento] можно использовать сообща для реализации отмены операций. В этом случе объекты команд будут отображать выполненные действие над объектом, снимки - хранить копию состояния этого объекта до того, как команда была выполнена.

    **Команда** и [**Стратегия**][Strategy] похожи по духу, но отличаются масштабом и применением:

    - **Команду** используют, чтобы превратить любые разнородные действия в объекты. Параметры операции превращаются в поля объекта. Этот объект теперь можно логировать, хранить в истории для отмены, передавать во внешние сервисы и так далее.
 
    - С другой стороны, [**Стратегия**][Strategy] описывает разные способы сделать одно и то же действие, позволяя взаимозаменять эти способы в каком-то объекте контекста.
Если **Команду** нужно копировать перед вставкой в историю выполненных команд, вам может помочь [**Прототип**][Prototype].

- [**Посетитель**][Visitor] это более мощный аналог **Команды**, которую можно выполнить сразу над объектами нескольких классов.


[OCP]: </src/AdditionalDocs/SOLID/Open-Closed_principle.md>
[DIP]: </src/AdditionalDocs/SOLID/Dependency_Inversion_principle.md>

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
```java
package Behavioral.Command.Example;

import Behavioral.Command.Example.Commands.LightOn;
import Behavioral.Command.Example.Commands.MacroCommand;
import Behavioral.Command.Example.Commands.StereoOff;
import Behavioral.Command.Example.Commands.StereoOn;
import Behavioral.Command.Example.Invoker.RemoteController;
import Behavioral.Command.Example.Receivers.Light;
import Behavioral.Command.Example.Receivers.Stereo;

public class Command {

  public static void main(String[] args) {

    //Create Receivers
    Light kitchen = new Light("Kitchen");
    Light lounge = new Light("Lounge");
    Light hall = new Light("Hall");
    Stereo stereo = new Stereo();

    //Create MacroCommands
    MacroCommand partyCommand = new MacroCommand();
    partyCommand.addCommand(new StereoOn(stereo));
    partyCommand.addCommand(new LightOn(lounge));

    //Create Invoker
    RemoteController remoteController = new RemoteController();

    remoteController.setCommand(new StereoOn(stereo));
    remoteController.pressButton();
    remoteController.setCommand(new StereoOff(stereo));
    remoteController.pressButton();
    System.out.println("UNDO");
    remoteController.pressUndoButton();

    System.out.println("Party START");
    remoteController.setCommand(partyCommand);
    remoteController.pressButton();
    System.out.println("UNDO");
    remoteController.pressUndoButton();

  }
}

```
```java
package Behavioral.Command.Example.Commands;

public interface Command {

  void execute();

  void undo();

  //store();

  //load();

}
```
```java
package Behavioral.Command.Example.Commands;

import Behavioral.Command.Example.Receivers.Light;

public class LightOff implements Command {

  private Light light;

  public LightOff(Light light) {
    this.light = light;
  }

  @Override
  public void execute() {
    light.switchOFF();
  }

  @Override
  public void undo() {
    light.switchON();
  }
}
```
```java
package Behavioral.Command.Example.Commands;

import Behavioral.Command.Example.Receivers.Light;

public class LightOn implements Command {

  private Light light;

  public LightOn(Light light) {
    this.light = light;
  }

  @Override
  public void execute() {
    light.switchON();
  }

  @Override
  public void undo() {
    light.switchOFF();
  }

}
```
```java
package Behavioral.Command.Example.Commands;

import java.util.HashSet;
import java.util.Set;

public class MacroCommand implements Command {

  private Set<Command> commandSet = new HashSet<>();

  public void addCommand(Command command) {
    commandSet.add(command);
  }

  @Override
  public void execute() {
    commandSet.forEach(Command::execute);
  }

  @Override
  public void undo() {
    commandSet.forEach(Command::undo);
  }
}
```
```java
package Behavioral.Command.Example.Commands;

import Behavioral.Command.Example.Receivers.Stereo;

public class StereoOff implements Command {

  private Stereo stereo;

  public StereoOff(Stereo stereo) {
    this.stereo = stereo;
  }

  @Override
  public void execute() {
    stereo.setVolume(0);
    stereo.stereoOFF();
  }

  @Override
  public void undo() {
    stereo.stereoON();
  }

}
```
```java
package Behavioral.Command.Example.Commands;

import Behavioral.Command.Example.Receivers.Stereo;

public class StereoOn implements Command {

  private Stereo stereo;

  public StereoOn(Stereo stereo) {
    this.stereo = stereo;
  }

  @Override
  public void execute() {
    stereo.stereoON();
    stereo.setCd();
    stereo.setVolume(12);
  }

  @Override
  public void undo() {
    stereo.stereoOFF();
  }
}
```
```java
package Behavioral.Command.Example.Invoker;

import Behavioral.Command.Example.Commands.Command;

public class RemoteController {

  //We have only one Command slot in our case.
  private Command command;

  public void setCommand(Command command) {
    this.command = command;
  }

  //We delegate work to Command.

  public void pressButton() {
    command.execute();
  }

  public void pressUndoButton() {
    command.undo();
  }

  /*
   * We can also have stack instead of method undo in Command,
   * if we want to have history of events.
   * Also we can have state of Command :
   * Serializable in method store() and Deserializable in load().
   */
}
```
```java
package Behavioral.Command.Example.Receivers;

public class Light {

  private boolean on;
  private String name;

  public Light(String name) {
    this.name = name;
  }

  public void switchON() {
    on = true;
    System.out.println("Light in " + name + " is On");
  }

  public void switchOFF() {
    on = false;
    System.out.println("Light in " + name + " is Off");
  }


}
```
```java
package Behavioral.Command.Example.Receivers;

public class Stereo {

  private int volume;
  private boolean cd;
  private boolean on;

  public int getVolume() {
    return volume;
  }

  public void setVolume(int volume) {
    this.volume = volume;
  }

  public boolean isCd() {
    return cd;
  }

  public void setCd() {
    cd = true;
  }

  public boolean isOn() {
    return on;
  }

  public void stereoON() {
    on = true;
    System.out.println("Stereo is ON");
  }

  public void stereoOFF() {
    this.on = false;
    System.out.println("Stereo is OFF");
  }
}
```
```java
package Behavioral.Interpreter.Example.SimpleEx1.Context;

import Behavioral.Interpreter.Example.SimpleEx1.Expression.AddExpression;
import Behavioral.Interpreter.Example.SimpleEx1.Expression.Expression;
import Behavioral.Interpreter.Example.SimpleEx1.Expression.NumberExpression;
import Behavioral.Interpreter.Example.SimpleEx1.Expression.SubtractExpression;

public class Context {

  /*
   * Start counting from the right to the left.
   * We take on 1 number per iteration.
   */
  public Expression calculate(String exp) {
    int pos = exp.length() - 1;
    while (pos > 0) {
      if (Character.isDigit(exp.charAt(pos))) {
        pos--;
      } else {
        Expression left = calculate(exp.substring(0, pos));
        Expression right = new NumberExpression(
          Integer.valueOf(exp.substring(pos + 1, exp.length())));
        char operator = exp.charAt(pos);
        switch (operator) {
          case '-':
            return new SubtractExpression(left, right);
          case '+':
            return new AddExpression(left, right);
        }
      }
    }
    //When we get only one number
    int result = Integer.valueOf(exp);
    return new NumberExpression(result);
  }
}
```
```java
package Behavioral.Interpreter.Example.SimpleEx1;

import Behavioral.Interpreter.Example.SimpleEx1.Context.Context;
import Behavioral.Interpreter.Example.SimpleEx1.Expression.Expression;

/*
 * Calculate expression ([0-9]*\+|-[0-9]*)*
 */
public class Ex {

  //5+2-43+2 = -34
  public static void main(String[] args) {
    Context context = new Context();
    Expression expression = context.calculate("5+2-43+2");
    System.out.println(expression.interpret());
  }

}
```
```java
package Behavioral.Interpreter.Example.SimpleEx1.Expression;

public class AddExpression implements Expression {

  private final Expression num1;
  private final Expression num2;

  public AddExpression(Expression num1, Expression num2) {
    this.num1 = num1;
    this.num2 = num2;
  }

  @Override
  public int interpret() {
    return num1.interpret() + num2.interpret();
  }
}
```
```java
package Behavioral.Interpreter.Example.SimpleEx1.Expression;

public interface Expression {

  int interpret();

}
```
```java
package Behavioral.Interpreter.Example.SimpleEx1.Expression;

public class NumberExpression implements Expression {

  private int number;

  public NumberExpression(int number) {
    this.number = number;
  }

  @Override
  public int interpret() {
    return number;
  }
}
```
```java
package Behavioral.Interpreter.Example.SimpleEx1.Expression;

public class SubtractExpression implements Expression {

  private final Expression num1;
  private final Expression num2;

  public SubtractExpression(Expression num1, Expression num2) {
    this.num1 = num1;
    this.num2 = num2;
  }

  @Override
  public int interpret() {
    return num1.interpret() - num2.interpret();
  }
}
```
```java
package Behavioral.Interpreter.Example.SimpleEx2;

import Behavioral.Interpreter.Example.SimpleEx2.Expression.AndExpression;
import Behavioral.Interpreter.Example.SimpleEx2.Expression.Expression;
import Behavioral.Interpreter.Example.SimpleEx2.Expression.OrExpression;
import Behavioral.Interpreter.Example.SimpleEx2.Expression.TerminalExpression;

//We use recursion for wrap different Expression

public class Ex {


  public static void main(String[] args) {
    Expression isGay = getGayExpression(
      new TerminalExpression("Vlad"),
      new TerminalExpression("Dima"));
    Expression isInLove = getStateExpression(
      new TerminalExpression("Tanya"),
      new TerminalExpression("inLove")
    );

    System.out.println("Is Vlad gay? " + isGay.interpret("Vlad"));
    System.out.println("Is Tanya is in Love? " + isInLove.interpret("Tanya is inLove?"));
  }

  //Rule: Dima and Vlad Geys
  public static Expression getGayExpression(Expression person1, Expression person2) {
    return new OrExpression(person1, person2);
  }

  //Rule: Tanya in love
  public static Expression getStateExpression(Expression ex1, Expression ex2) {
    return new AndExpression(ex1, ex2);
  }
}

```
```java
package Behavioral.Interpreter.Example.SimpleEx2.Expression;

public class AndExpression implements Expression {

  private Expression expr1;
  private Expression expr2;

  public AndExpression(Expression expr1, Expression expr2) {
    this.expr1 = expr1;
    this.expr2 = expr2;
  }

  @Override
  public boolean interpret(String context) {
    return expr1.interpret(context) && expr2.interpret(context);
  }
}
```
```java
package Behavioral.Interpreter.Example.SimpleEx2.Expression;

public interface Expression {

  boolean interpret(String context);

}
```
```java
package Behavioral.Interpreter.Example.SimpleEx2.Expression;

public class OrExpression implements Expression {

  private Expression expr1;
  private Expression expr2;

  public OrExpression(Expression expr1, Expression expr2) {
    this.expr1 = expr1;
    this.expr2 = expr2;
  }

  @Override
  public boolean interpret(String context) {
    return expr1.interpret(context) || expr2.interpret(context);
  }
}
```
```java
package Behavioral.Interpreter.Example.SimpleEx2.Expression;

public class TerminalExpression implements Expression {

  private String data;

  public TerminalExpression(String data) {
    this.data = data;
  }

  @Override
  public boolean interpret(String context) {
    return context.contains(data);
  }
}
```
# Интерпретатор 

![UML](/src/AdditionalDocs/uml/Interpreter/Interpreter.png)

Предоставляет возможность оценить грамматику или выражение языка. Этот шаблон предполагает **реализацию интерфейса выражения, который интерпретирует конкретный контекст**. Этот шаблон используется в разборе SQL, движке обработки символов и т. д.

или

Позволяет **описать алгоритм со своей грамматикой и определенными правилами для решения конкретной задачи**. Короче говоря, данный шаблон позволяет описать механизм вычисления конкретной задачи с заданным синтаксисом.

## Применимость

- Когда нужно **реализовать простой язык**.
  
  - Уместен для языков с простой грамматикой, где простота важнее эффективности 
  
  - Может использоваться как со сценарными языками, так и с языками программирования.

## Шаги реализации

1. Создайте интерфейс выражения.
  
    - Как правило, будет вмещать в себя метод `interpret(String context)`

2. Создайте конкретные классы реализаций. Которые предусматривают в себе все нужные варианты интерпретаций.

## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |Грамматику легко изменять и расширять.|Сложные грамматики трудно сопровождать.
 |Простая реализация грамматики.
 
## Отношения с другими паттернами

- Обычно вместе с паттерном **Интерпретатор** используется [**Компоновщик**][Composite]
 
 - **Абстрактное синтаксическое дерево** - это пример применения паттерна [**Компоновщик**][Composite].

![UML](/src/AdditionalDocs/uml/Interpreter/AbstractSyntaxTree.png)
 
- [**Приспособленец**][Flyweight] показывает варианты совместного использования терминальных символов в абстрактном синтаксическом дереве. 

- **Интерпретатор** может пользоваться [**Итератором**][Singleton] для обхода структуры.

- [**Посетителя**][Visitor] можно использовать для инкапсуляции в одном классе поведения каждого узла абстрактного синтаксического дерева.


[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
```java
package Behavioral.Iterator.Example;

import Behavioral.Iterator.Example.Menus.DinnerMenu;
import Behavioral.Iterator.Example.Menus.PancakeMenu;

public class Ex {

  public static void main(String[] args) {
    PancakeMenu pancakeMenu = new PancakeMenu();
    DinnerMenu dinnerMenu = new DinnerMenu();

    Waitress waitress = new Waitress();
    waitress.addMenu(pancakeMenu);
    waitress.addMenu(dinnerMenu);

    waitress.printMenu();
  }

}
```
```java
package Behavioral.Iterator.Example.Iterators;

import Behavioral.Iterator.Example.Menus.MenuItem.MenuItem;
import java.util.Iterator;

/*
 *  We also can convert to List<T>
 *  List<MenuItem> list = Arrays.asList(dinnerMenu)
 *  and get Iterator<E>
 *  list.iterator()
 */

public class DinnerMenuIterator implements Iterator<MenuItem> {

  private MenuItem[] dinnerMenu;
  private int position = 0;

  public DinnerMenuIterator(MenuItem[] dinnerMenu) {
    this.dinnerMenu = dinnerMenu;
  }

  @Override
  public boolean hasNext() {
    return position < dinnerMenu.length && dinnerMenu[position] != null;
  }

  @Override
  public MenuItem next() {
    return dinnerMenu[position++];
  }

  @Override
  public void remove() {
    throw new UnsupportedOperationException("Not supported for Dinner Menu");
  }
}
```
```java
package Behavioral.Iterator.Example.Menus;

import Behavioral.Iterator.Example.Iterators.DinnerMenuIterator;
import Behavioral.Iterator.Example.Menus.MenuItem.MenuItem;
import java.util.Iterator;

//Interface Menu extends Iterable
public class DinnerMenu implements Menu {

  private final int MENU_SIZE = 10;
  private int lastItemIndex = 0;
  private MenuItem[] dinnerMenu;

  //Lazy init.
  public DinnerMenu() {
    dinnerMenu = new MenuItem[MENU_SIZE];

    //Some items

    addItem(new MenuItem("HotDog", 3.99));
    addItem(new MenuItem("BLT", 10.99));
    addItem(new MenuItem("Soup", 7.99));
  }

  public void addItem(MenuItem menuItem) {
    if (lastItemIndex < MENU_SIZE) {
      dinnerMenu[lastItemIndex++] = menuItem;
    } else {
      System.out.println("Menu is full");
    }
  }

  @Override
  public Iterator<MenuItem> iterator() {
    return new DinnerMenuIterator(dinnerMenu);
  }
}
```
```java
package Behavioral.Iterator.Example.Menus;

import Behavioral.Iterator.Example.Menus.MenuItem.MenuItem;

public interface Menu extends Iterable<MenuItem> {

  void addItem(MenuItem menuItem);
}
```
```java
package Behavioral.Iterator.Example.Menus.MenuItem;

public class MenuItem {

  private String name;
  private double price;

  public MenuItem(String name, double price) {
    this.name = name;
    this.price = price;
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public double getPrice() {
    return price;
  }

  public void setPrice(double price) {
    this.price = price;
  }
}
```
```java
package Behavioral.Iterator.Example.Menus;

import Behavioral.Iterator.Example.Menus.MenuItem.MenuItem;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

//Interface Menu extends Iterable
public class PancakeMenu implements Menu {

  private List<MenuItem> pancakeMenu;

  public PancakeMenu() {
    pancakeMenu = new ArrayList<>();

    //some items
    addItem(new MenuItem("Waffles", 0.99));
    addItem(new MenuItem("Pancake with milk", 5.25));
    addItem(new MenuItem("Desert", 2.90));
  }

  public void addItem(MenuItem menuItem) {
    pancakeMenu.add(menuItem);
  }

  @Override
  public Iterator<MenuItem> iterator() {
    return pancakeMenu.iterator();

    //or we can use more functional listIterator();
    //return pancakeMenu.listIterator();
  }
}
```
```java
package Behavioral.Iterator.Example;

import Behavioral.Iterator.Example.Menus.Menu;
import Behavioral.Iterator.Example.Menus.MenuItem.MenuItem;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class Waitress {

  private List<Menu> menus;

  public Waitress() {
    menus = new ArrayList<>();
  }

  public void printMenu() {
    for (Menu menu : menus) {
      printMenu(menu.iterator());
    }
  }


  public void addMenu(Menu menu) {
    menus.add(menu);
  }

  private void printMenu(Iterator<MenuItem> iterator) {
    while (iterator.hasNext()) {
      MenuItem menuItem = iterator.next();
      System.out.println(menuItem.getName() + "  Which price is only = " + menuItem.getPrice());
    }
    System.out.println("//////");
  }
}
```
# Итератор

![UML](/src/AdditionalDocs/uml/Iterator.png)
 
Даёт возможность **последовательно обходить элементы составных объектов**, не раскрывая их внутреннего представления.

Коллекции (Iterable collection) не всегда являются списком. Это может быть и база данных, и удалённое API, и даже дерево [**Компоновщика**][Composite]. Поэтому сама коллекция может создавать итераторы, так как она знает, какие именно итераторы могут с ней работать.

**JDK имеет интерфейсы [Iterable\<T>](https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html), [Iterator\<E>](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html)**

**Так же JDK есть более функциональный [ListIterator\<E>](https://docs.oracle.com/javase/8/docs/api/java/util/ListIterator.html), используется классами, реализующими интерфейс [List](https://docs.oracle.com/javase/8/docs/api/java/util/List.html)**

## Применимость
 - Когда у вас есть сложная структура данных, и вы хотите скрыть от клиента детали её реализации (из-за сложности или вопросов безопасности).

   - **Итератор предоставляет клиенту всего несколько простых методов перебора элементов коллекции**. Это не только упрощает доступ к коллекции, но и защищает её данные от неосторожных или злоумышленных действий.

 - Когда вам нужно иметь **несколько вариантов обхода** одной и той же структуры данных.

   - Нетривиальные алгоритмы обхода структуры данных могут иметь довольно объёмный код. Этот код будет захламлять всё вокруг, если поместить его в класс коллекции или где-то посреди основной бизнес-логики программы. Применив итератор, вы можете **переместить код обхода структуры данных в собственный класс, упростив поддержку остального кода**.

 - Когда вам хочется иметь **единый интерфейс обхода различных структур данных**.

   - **Итератор позволяет вынести реализации различных вариантов обхода в подклассы**. Это позволит легко взаимозаменять объекты итераторов, в зависимости от того, с какой структурой данных приходится работать.

## Шаги реализации
 
1. Создайте **интерфейс итераторов**. В качестве минимума, вам понадобится **операция получения следующего элемента**. Но для удобства можно предусмотреть и другие методы, например, для **получения предыдущего элемента**, **текущей позиции**, **проверки окончания обхода и прочих**.

2. Создайте интерфейс коллекции и опишите в нём **метод получения итератора**. Важно, чтобы его сигнатура **возвращала общий интерфейс итераторов**, а не один из конкретных итераторов.

3. Создайте классы конкретных итераторов для тех коллекций, которые нужно обходить с помощью паттерна. **Итератор должен быть привязан только к одному объекту коллекции. Обычно эта связь устанавливается через конструктор**.

4. Реализуйте методы получения итератора в конкретных классах коллекций. Они должны создавать новый итератор того класса, который способен работать с данным типом коллекции. **Коллекция должна передавать собственную ссылку в созданный итератор**.

5. **В клиентском коде и в классах коллекций не должно остаться кода обхода элементов**. Клиент должен получать новый итератор из объекта коллекции каждый раз, когда ему нужно перебрать её элементы.

 ## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |Упрощает классы хранения данных.|Неоправдан, если можно обойтись простым циклом.
 |Позволяет реализовать различные **способы обхода структуры данных**.
 |Позволяет одновременно перемещаться по структуре данных в разные стороны.
 
 
## Отношения с другими паттернами

- Вы можете обходить дерево **[**Компоновщика**][Composite]**, используя **Итератор**.

- [**Фабричный метод**][Factory_method] можно использовать вместе с **Итератором**, чтобы подклассы коллекций могли создавать подходящие им итераторы.

- [**Снимок**][Memento] можно использовать вместе с **Итератором**, чтобы сохранить текущее состояние обхода структуры данных и вернуться к нему в будущем, если потребуется.

- [**Посетитель**][Visitor] можно использовать совместно с **Итератором**. **Итератор** будет отвечать за обход структуры данных, а [**Посетитель**][Visitor] - за выполнение действий над каждым её компонентом.


[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
```java
package Behavioral.Mediator.Example.Ex1;

import Behavioral.Mediator.Example.Ex1.Users.Admin;
import Behavioral.Mediator.Example.Ex1.Users.User;
import java.util.HashSet;
import java.util.Set;

public class ChatRoom {

  private Set<User> users = new HashSet<>();

  public void addUser(User user) {
    users.add(user);
  }

  public void showMessage(User user, String mess) {
    if (user instanceof Admin) {
      mess = "ADMIN: " + user.getName() + " is send " + mess;
    } else {
      mess = user.getName() + " is send " + mess;
    }

    String finalMess = mess;

    users.forEach(x -> System.out.println(finalMess + " TO " + x.getName()));

  }
}
```
```java
package Behavioral.Mediator.Example.Ex1;

import Behavioral.Mediator.Example.Ex1.Users.Admin;
import Behavioral.Mediator.Example.Ex1.Users.User;

//Users don't know about each other

public class Ex {

  public static void main(String[] args) {
    ChatRoom chatRoom = new ChatRoom();
    User user1 = new User("Vlad", chatRoom);
    User user2 = new User("Pupsik", chatRoom);
    User user3 = new User("Nagibator", chatRoom);
    User user4 = new User("Ivanovator", chatRoom);
    User user5 = new User("IdIoT", chatRoom);
    Admin admin = new Admin("Dima", chatRoom);
    Admin admin2 = new Admin("Root", chatRoom);

    chatRoom.addUser(user1);
    chatRoom.addUser(user2);
    chatRoom.addUser(user3);
    chatRoom.addUser(user4);
    chatRoom.addUser(user5);
    chatRoom.addUser(admin);
    chatRoom.addUser(admin2);

    user1.sendMessage("Lol");

    admin.sendMessage("I + java = Love");
  }
}
```
```java
package Behavioral.Mediator.Example.Ex1.Users;

import Behavioral.Mediator.Example.Ex1.ChatRoom;

public class Admin extends User {

  public Admin(String name, ChatRoom chatRoom) {
    super(name, chatRoom);
  }
}
```
```java
package Behavioral.Mediator.Example.Ex1.Users;

import Behavioral.Mediator.Example.Ex1.ChatRoom;

public class User {

  private String name;
  private ChatRoom chatRoom;

  public User(String name, ChatRoom chatRoom) {
    this.name = name;
    this.chatRoom = chatRoom;
  }

  public String getName() {
    return name;
  }

  public void sendMessage(String message) {
    chatRoom.showMessage(this, message);
  }

}
```
```java
package Behavioral.Mediator.Example.Ex2.Components.HouseStaff;

public class AlarmClock {

  public void alarm() {
    System.out.println("TIME TO WAKE UP");
  }

  public void turnOfAlarm() {
    System.out.println("Alarm clock is OFF");
  }
}
```
```java
package Behavioral.Mediator.Example.Ex2.Components.HouseStaff;

public class BedroomDoor {

  public void close() {
    System.out.println("Bedroom door is close");
  }

  public void open() {
    System.out.println("Bedroom door is open");
  }

}
```
```java
package Behavioral.Mediator.Example.Ex2.Components.HouseStaff;

public class BedroomLight {

  public void on() {
    System.out.println("Bedroom light on");
  }

  public void off() {
    System.out.println("Bedroom light off");
  }

}
```
```java
package Behavioral.Mediator.Example.Ex2.Components.HouseStaff;

public class CoffeeMachine {

  public void makeCoffee() {
    System.out.println("Coffee is done");
  }

  public void boil() {
    System.out.println("Boil water");
  }

}
```
```java
package Behavioral.Mediator.Example.Ex2.Components.HouseStaff;

public class KitchenDoor {

  public void close() {
    System.out.println("Kitchen door is close");
  }

  public void open() {
    System.out.println("Kitchen door is open");
  }

}
```
```java
package Behavioral.Mediator.Example.Ex2.Components.HouseStaff;

public class KitchenLight {

  public void on() {
    System.out.println("Kitchen light on");
  }

  public void off() {
    System.out.println("Kitchen light off");
  }
}
```
```java
package Behavioral.Mediator.Example.Ex2.Components.Sensors;

import Behavioral.Mediator.Example.Ex2.Mediator.Mediator;

public class KitchenSensor extends Sensor {

  public KitchenSensor(Mediator mediator) {
    super(mediator);
  }

  @Override
  public void sens() {
    mediator.notify("Kitchen");
  }
}
```
```java
package Behavioral.Mediator.Example.Ex2.Components.Sensors;

import Behavioral.Mediator.Example.Ex2.Mediator.Mediator;

public class LeaveSensor extends Sensor {

  public LeaveSensor(Mediator mediator) {
    super(mediator);
  }

  @Override
  public void sens() {
    mediator.notify("Leave");
  }
}
```
```java
package Behavioral.Mediator.Example.Ex2.Components.Sensors;

import Behavioral.Mediator.Example.Ex2.Mediator.Mediator;

public abstract class Sensor {

  protected Mediator mediator;

  public Sensor(Mediator mediator) {
    this.mediator = mediator;
  }

  public abstract void sens();
}
```
```java
package Behavioral.Mediator.Example.Ex2.Components.Sensors;

import Behavioral.Mediator.Example.Ex2.Mediator.Mediator;

public class WakeUpSensor extends Sensor {

  public WakeUpSensor(Mediator mediator) {
    super(mediator);
  }

  @Override
  public void sens() {
    mediator.notify("WakeUp");
  }
}
```
```java
package Behavioral.Mediator.Example.Ex2;

import Behavioral.Mediator.Example.Ex2.Components.HouseStaff.AlarmClock;
import Behavioral.Mediator.Example.Ex2.Components.HouseStaff.BedroomDoor;
import Behavioral.Mediator.Example.Ex2.Components.HouseStaff.BedroomLight;
import Behavioral.Mediator.Example.Ex2.Components.HouseStaff.CoffeeMachine;
import Behavioral.Mediator.Example.Ex2.Components.HouseStaff.KitchenDoor;
import Behavioral.Mediator.Example.Ex2.Components.HouseStaff.KitchenLight;
import Behavioral.Mediator.Example.Ex2.Components.Sensors.KitchenSensor;
import Behavioral.Mediator.Example.Ex2.Components.Sensors.LeaveSensor;
import Behavioral.Mediator.Example.Ex2.Components.Sensors.WakeUpSensor;
import Behavioral.Mediator.Example.Ex2.Mediator.SmartHouse;
import Behavioral.Mediator.Example.Ex2.Mediator.SmartHouseBuilder;

public class Ex {

  public static void main(String[] args) {
    SmartHouse smartHouse = new SmartHouseBuilder()
      .setAlarmClock(new AlarmClock())
      .setBedroomDoor(new BedroomDoor())
      .setBedroomLight(new BedroomLight())
      .setCoffeeMachine(new CoffeeMachine())
      .setKitchenDoor(new KitchenDoor())
      .setKitchenLight(new KitchenLight())
      .createSmartHouse();

    //Each sensor don't know about HouseStaff, but know about mediator
    WakeUpSensor wakeUpSensor = new WakeUpSensor(smartHouse);
    KitchenSensor kitchenSensor = new KitchenSensor(smartHouse);
    LeaveSensor leaveSensor = new LeaveSensor(smartHouse);

    wakeUpSensor.sens();
    System.out.println("then go to Kitchen");
    kitchenSensor.sens();
    System.out.println("mMMm I hate coffee");
    System.out.println("Ohh i am late ****");
    leaveSensor.sens();
  }
}
```
```java
package Behavioral.Mediator.Example.Ex2.Mediator;

public interface Mediator {

  void notify(String state);
}
```
```java
package Behavioral.Mediator.Example.Ex2.Mediator;

import Behavioral.Mediator.Example.Ex2.Components.HouseStaff.AlarmClock;
import Behavioral.Mediator.Example.Ex2.Components.HouseStaff.BedroomDoor;
import Behavioral.Mediator.Example.Ex2.Components.HouseStaff.BedroomLight;
import Behavioral.Mediator.Example.Ex2.Components.HouseStaff.CoffeeMachine;
import Behavioral.Mediator.Example.Ex2.Components.HouseStaff.KitchenDoor;
import Behavioral.Mediator.Example.Ex2.Components.HouseStaff.KitchenLight;

// We also can use Observer and interface to all HouseStaff

public class SmartHouse implements Mediator {

  private AlarmClock alarmClock;
  private BedroomDoor bedroomDoor;
  private BedroomLight bedroomLight;
  private CoffeeMachine coffeeMachine;
  private KitchenDoor kitchenDoor;
  private KitchenLight kitchenLight;

  public SmartHouse(AlarmClock alarmClock,
    BedroomDoor bedroomDoor,
    BedroomLight bedroomLight,
    CoffeeMachine coffeeMachine,
    KitchenDoor kitchenDoor,
    KitchenLight kitchenLight) {
    this.alarmClock = alarmClock;
    this.bedroomDoor = bedroomDoor;
    this.bedroomLight = bedroomLight;
    this.coffeeMachine = coffeeMachine;
    this.kitchenDoor = kitchenDoor;
    this.kitchenLight = kitchenLight;
  }

  @Override
  public void notify(String state) {
    switch (state) {
      case "WakeUp":
        alarmClock.turnOfAlarm();
        bedroomDoor.open();
        bedroomLight.on();
        coffeeMachine.boil();
        break;
      case "Kitchen":
        kitchenDoor.open();
        kitchenLight.on();
        bedroomLight.off();
        bedroomDoor.close();
        break;
      case "Leave":
        bedroomDoor.close();
        kitchenDoor.close();
        bedroomLight.off();
        kitchenLight.off();
        break;
    }
  }
}
```
```java
package Behavioral.Mediator.Example.Ex2.Mediator;

import Behavioral.Mediator.Example.Ex2.Components.HouseStaff.AlarmClock;
import Behavioral.Mediator.Example.Ex2.Components.HouseStaff.BedroomDoor;
import Behavioral.Mediator.Example.Ex2.Components.HouseStaff.BedroomLight;
import Behavioral.Mediator.Example.Ex2.Components.HouseStaff.CoffeeMachine;
import Behavioral.Mediator.Example.Ex2.Components.HouseStaff.KitchenDoor;
import Behavioral.Mediator.Example.Ex2.Components.HouseStaff.KitchenLight;

public class SmartHouseBuilder {

  private AlarmClock alarmClock;
  private BedroomDoor bedroomDoor;
  private BedroomLight bedroomLight;
  private CoffeeMachine coffeeMachine;
  private KitchenDoor kitchenDoor;
  private KitchenLight kitchenLight;

  public SmartHouseBuilder setAlarmClock(AlarmClock alarmClock) {
    this.alarmClock = alarmClock;
    return this;
  }

  public SmartHouseBuilder setBedroomDoor(BedroomDoor bedroomDoor) {
    this.bedroomDoor = bedroomDoor;
    return this;
  }

  public SmartHouseBuilder setBedroomLight(BedroomLight bedroomLight) {
    this.bedroomLight = bedroomLight;
    return this;
  }

  public SmartHouseBuilder setCoffeeMachine(CoffeeMachine coffeeMachine) {
    this.coffeeMachine = coffeeMachine;
    return this;
  }

  public SmartHouseBuilder setKitchenDoor(KitchenDoor kitchenDoor) {
    this.kitchenDoor = kitchenDoor;
    return this;
  }

  public SmartHouseBuilder setKitchenLight(KitchenLight kitchenLight) {
    this.kitchenLight = kitchenLight;
    return this;
  }

  public SmartHouse createSmartHouse() {
    return new SmartHouse(alarmClock, bedroomDoor, bedroomLight, coffeeMachine, kitchenDoor,
      kitchenLight);
  }
}
```
# Посредник

![UML](/src/AdditionalDocs/uml/Mediator.png)

(Также можно выделить Компоненты в отдельный интерфейс)

***Компоненты** - это разнородные объекты, содержащие бизнес-логику программы. Каждый компонент хранит ссылку на объект посредника, но работает с ним только через абстрактный интерфейс посредников. Благодаря этому, компоненты можно повторно использовать в другой программе, связав их с посредником другого типа.

***Посредник** определяет интерфейс для обмена информацией с компонентами. Обычно хватает одного метода для оповещения посредника о событиях, произошедших в компонентах. В параметрах этого метода можно передавать детали события: ссылку на компонент, в котором оно произошло, и любые другие данные.

Позволяет **уменьшить связанность** множества классов между собой, благодаря перемещению этих связей в один класс-посредник, также обеспечивает взаимодействие.

## Применимость
 
 - Когда вам сложно менять некоторые классы из-за **множества хаотичных связей с другими классами**.

   - **Посредник позволяет поместить все эти связи в один класс**. После чего вам будет легче их отрефакторить, сделать более понятными и гибкими.

 - Когда вы не можете **повторно использовать класс**, поскольку он зависит от уймы других классов.

   - После применения паттерна, компоненты теряют прежние связи с другими компонентами. А всё их общение происходит косвенно, через посредника.

 - Когда вам **приходится создавать множество подклассов компонентов, чтобы использовать одни и те же компоненты в разных контекстах**.

   - Если раньше изменение отношений в одном компоненте могли повлечь за собой снежный ком изменений в каждом другом компоненте, то теперь вам **достаточно создать подкласс посредника и поменять в нём связи между компонентами**.

## Шаги реализации

1. Найдите **группу тесно переплетённых классов**, отвязав которые друг от друга, можно получить некоторую пользу. Например, чтобы повторно использовать их код в другой программе.

2. Создайте **общий интерфейс Посредников и опишите в нём методы для взаимодействия с Компонентами**. В простейшем случае достаточно одного метода для получения оповещений от компонентов.

   Этот **интерфейс необходим, если вы хотите повторно использовать классы компонентов для других задач**. В этом случае, всё, что нужно сделать - это создать новый класс конкретного посредника.

3. Реализуйте этот **интерфейс в классе Конкретного посредника**. Поместите в него **поля, которые будут содержать ссылки на все объекты компонентов**.

4. Вы можете пойти дальше и переместить **код создания компонентов в класс Конкретного посредника, превратив его в фабрику**.

5. **Компоненты тоже должны иметь ссылку на объект посредника**. Связь между ними удобней всего установить, подавая посредника в параметры конструктора компонентов.

6. Измените **код компонентов так, чтобы они вызывали метод оповещения посредника**, а не методы других компонентов. С другой стороны, **посредник должен вызывать методы нужного компонента, когда получает оповещение**.

## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |Устраняет зависимости между компонентами, позволяя повторно их использовать.|Посредник может сильно раздуться.
 |Упрощает взаимодействие между компонентами.
 |Централизует управление в одном месте.
 
## Отношения с другими паттернами

- [**Цепочка обязанностей**][Chain_of_Responsibility], [**Команда**][Command], **Посредник** и [**Наблюдатель**][Observer] показывают различные способы работы отправителей запросов с их получателями:

  - [**Цепочка обязанностей**][Chain_of_Responsibility] передаёт запрос последовательно через цепочку потенциальных получателей, ожидая, что какой-то из них обработает запрос.

   - [**Команда**][Command] устанавливает косвенную одностороннюю связь от отправителей к получателям.

   - **Посредник** убирает прямую связь между отправителями и получателями, заставляя их общаться опосредованно, через себя.
   
   - [**Наблюдатель**][Observer] передаёт запрос одновременно всем заинтересованным получателям, но позволяет им динамически подписывать или отписываться от таких оповещений.

- **Посредник** и [**Фасад**][Facade] похожи тем, что пытаются организовать работу множества существующих классов.

  - [**Фасад**][Facade] создаёт упрощённый интерфейс к подсистеме, не внося в неё никакой добавочной функциональности. Сама подсистема не знает о существовании [**Фасада**][Facade]. Классы подсистемы общаются друг с другом напрямую.

  - **Посредник** централизует общение между компонентами системы. Компоненты системы знают только о существовании **Посредника**, у них нет прямого доступа к другим компонентам.

- Разница между **Посредником** и [**Наблюдателем**][Observer] не всегда очевидна. Чаще всего они выступают как конкуренты, но иногда могут работать вместе.
  
  Цель **Посредника** - убрать обоюдные зависимости между компонентами системы. Вместо этого они становятся зависимыми от самого посредника. С другой стороны, цель [**Наблюдателя**][Observer] - обеспечить динамическую одностороннюю связь, в которой одни объекты косвенно зависят от других.

  Довольно популярна реализация **Посредника** при помощи [**Наблюдателя**][Observer]. При этом объект посредника будет выступать издателем, а все остальные компоненты станут подписчиками и смогут динамически следить за событиями, происходящими в посреднике. В этом случае трудно понять, чем же отличаются оба паттерна.

  Но **Посредник** имеет и другие реализации, когда отдельные компоненты жёстко привязаны к объекту посредника. Такой код вряд ли будет напоминать [**Наблюдателя**][Observer], но всё же останется **Посредником**.

  Напротив, в случае реализации посредника с помощью [**Наблюдателя**][Observer], представим такую программу, в которой каждый компонент системы становится издателем. Компоненты могут подписываться друг на друга, в то же время, не привязываясь к конкретным классам. Программа будет состоять из целой сети [**Наблюдателей**][Observer], не имея центрального объекта **Посредника**.


[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Object_Pool]: </src/Creational/Object_Pool/Object_Pool.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>
[Private_Class_Data]: </src/Structural/Private_Class_Data/Private_Class_Data.md>


[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
[Null_Object]: </src/Behavioral/Null_Object/Null_Object.md>
```java
package Behavioral.Memento.Example.StaticNestedMemento;

import java.util.Stack;

public class Caretaker {

  private final Stack<Creator.Memento> mementos = new Stack<>();

  public Creator.Memento getLastSave() {
    return mementos.peek();
  }

  public void addSave(Creator.Memento memento) {
    mementos.push(memento);
  }

  public void removeLastSave() {
    mementos.pop();
  }
}
```
```java
package Behavioral.Memento.Example.StaticNestedMemento;

public class Creator {

  private String name;

  private int lvl;
  private String type;
  private String state;

  public Creator(String name, String type, String state) {
    this.name = name;
    lvl = 0;
    this.type = type;
    this.state = state;
  }

  public void upLvl() {
    lvl++;
  }

  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }

  public String getState() {
    return state;
  }

  public void setState(String state) {
    this.state = state;
  }

  public Memento save() {
    System.out.println("Saving...");
    return new Memento(lvl, type, state);
  }

  public void load(Memento memento) {
    lvl = memento.getLvl();
    type = memento.getType();
    state = memento.getState();
  }

  @Override
  public String toString() {
    return "Creator{" +
      "name='" + name + '\'' +
      ", lvl=" + lvl +
      ", type='" + type + '\'' +
      ", state='" + state + '\'' +
      '}';
  }

  //Nested static class
  public static class Memento {

    private final int lvl;
    private final String type;
    private final String state;

    public Memento(int lvl, String type, String state) {
      this.lvl = lvl;
      this.type = type;
      this.state = state;
    }

    //Accessible only by outer class

    private int getLvl() {
      return lvl;
    }

    private String getType() {
      return type;
    }

    private String getState() {
      return state;
    }
  }
}
```
```java
package Behavioral.Memento.Example.StaticNestedMemento;

// We can also create Memento in package class
// Encapsulation is still worked,
// bc new Memento is created by Creator(Class can use private fields)
// Also can create common interface for Memento

//Memento can have link to Creator and restore him, by itself
public class Ex {

  public static void main(String[] args) {
    Creator ork = new Creator("Ork", "Bowman", "dang");
    Creator undead = new Creator("Undead", "Wizard", "world");

    Caretaker caretaker = new Caretaker();
    caretaker.addSave(ork.save()); //First save

    System.out.println(ork.toString());
    ork.upLvl();
    ork.upLvl();
    ork.setState("world");
    ork.setType("Super Bowman");
    System.out.println(ork.toString());
    caretaker.addSave(ork.save()); // Next save

    ork.upLvl();
    ork.setState("Super dang");
    ork.upLvl();
    ork.upLvl();
    System.out.println(ork.toString());
    System.out.println("SORRY YOU DIED LOL");
    ork.load(caretaker.getLastSave());
    System.out.println(ork.toString());

    undead.load(caretaker.getLastSave());
  }
}
```
# Хранитель

![UML](/src/AdditionalDocs/uml/Memento/Memento.png)

Классическая реализация паттерна полагается на **механизм вложенных классов**. (Java)

Когда нужно полностью исключить доступ к состоянию Создателей и Снимков.
![UML](/src/AdditionalDocs/uml/Memento/MementoSave.png)

Позволяет не нарушая инкапсуляцию, зафиксировать и сохранить внутреннее состояние объекта так, чтобы позднее восстановить его в это состояние.

## Применимость
 
 (Serialization = Memento)
 
 - Когда вам нужно **сохранять мгновенный снимок состояния объекта (или его части)**, чтобы впоследствии объект можно было восстановить в том же состоянии.

    - **Снимок позволяет делать любое количество снимков объекта и хранить их независимо от объекта**, с которого делают снимок. Снимки часто используют не только для реализации операции отмены, но и для транзакций, когда состояние объекта нужно откатить, если операция не удалась.

 - Когда **прямое получение состояния объекта раскрывает детали его реализации и нарушает инкапсуляцию**.

    - Паттерн предлагает изготовить снимок самому исходному объекту, так как ему доступны все поля, даже приватные.

## Шаги реализации

1. Определите класс создателя, объекты которого должны создавать снимки своего состояния.

2. Создайте **класс снимка и опишите в нём все те же поля, которые имеются в оригинальном классе-создателе**.

3. Сделайте **объекты снимков неизменяемыми**. Они должны получать начальные значения только один раз, через свой конструктор.

4. Если ваш язык программирования это позволяет, сделайте **класс снимка вложенным в класс создателя**.

   Если нет, извлеките из класса снимка пустой интерфейс, который будет доступен остальным объектам программы. Впоследствии вы можете добавить некоторые вспомогательные методы в этот интерфейс, дающие доступ к метаданным снимка, однако прямой доступ к данным создателя должен быть исключён.

5. Добавьте в **класс создателя метод получения снимков**. Создатель должен создавать новые объекты снимков, передавая значения своих полей через конструктор.

   Сигнатура метода должна возвращать снимки через ограниченный интерфейс, если он у вас есть. Сам класс должен работать с конкретным классом снимка.

6. Добавьте в **класс создателя метод восстановления из снимка**. Что касается привязки к типам, руководствуйтесь той же логикой, что и в пункте 4.

7. Опекуны, будь то история операций, объекты команд или нечто иное, должны знать о том, когда запрашивать снимки у создателя, где их хранить, и когда восстанавливать.

8. **Связь опекунов с создателями можно перенести внутрь снимков**. В этом случае каждый снимок будет привязан к своему создателю и должен будет сам восстанавливать его состояние. Но **это будет работать либо если классы снимков вложены в классы создателей, либо если создатели имеют сеттеры для установки значений своих полей**.

## Преимущества и недостатки

 | + | - |
 | ------ | ------ |
 |Не нарушает инкапсуляции исходного объекта.|Требует **много памяти, если клиенты слишком часто создают снимки**.
 |Упрощает структуру исходного объекта. Ему **не нужно хранить историю версий своего состояния**.|Может **повлечь дополнительные издержки памяти, если объекты, хранящие историю, не освобождают ресурсы**, занятые устаревшими снимками.
 | |В некоторых языках (например, PHP, Python, JavaScript) сложно гарантировать, чтобы только исходный объект имел доступ к состоянию снимка.

## Отношения с другими паттернами

- [**Команду**][Command] и **Снимок** можно использовать сообща для реализации отмены операций. В этом случе объекты команд будут отображать выполненные действие над объектом, снимки - хранить копию состояния этого объекта до того, как команда была выполнена.

- **Снимок** можно использовать вместе с [**Итератором**][Iterator], чтобы сохранить текущее состояние обхода структуры данных и вернуться к нему в будущем, если потребуется.

- **Снимок** иногда можно заменить [**Прототипом**][Prototype], если объект, чьё состояние требуется сохранять в истории, довольно простой, не имеет активных ссылок на внешние ресурсы, либо их можно легко восстановить.

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
```java
package Behavioral.Null_Object.Example.Animals;

public interface Animal {

  void voice();

  void run();
}
```
```java
package Behavioral.Null_Object.Example.Animals;

public class Cat implements Animal {

  @Override
  public void voice() {
    System.out.println("Mya Mya ");
  }

  @Override
  public void run() {
    System.out.println("Cat is running");
  }
}
```
```java
package Behavioral.Null_Object.Example.Animals;

public class Dog implements Animal {

  @Override
  public void voice() {
    System.out.println("GAV GAV ");
  }

  @Override
  public void run() {
    System.out.println("Dog is running");
  }
}
```
```java
package Behavioral.Null_Object.Example.Animals;

public class NullAnimal implements Animal {

  private static NullAnimal ourInstance = new NullAnimal();

  public static NullAnimal getInstance() {
    return ourInstance;
  }

  private NullAnimal() {
  }

  @Override
  public void voice() {

  }

  @Override
  public void run() {

  }
}
```
```java
package Behavioral.Null_Object.Example;

import Behavioral.Null_Object.Example.Animals.Animal;
import Behavioral.Null_Object.Example.Animals.Cat;
import Behavioral.Null_Object.Example.Animals.Dog;
import Behavioral.Null_Object.Example.Animals.NullAnimal;
import java.util.Scanner;

public class Ex {

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    Animal animal;
    while (true) {
      System.out.println("Write down what animals do you want");
      String str = sc.next();
      switch (str) {
        case "Dog":
          animal = new Dog();
          break;
        case "Cat":
          animal = new Cat();
          break;
        default:
          animal = NullAnimal.getInstance();
      }
      animal.run();
      animal.voice();
    }
  }
}
```
# Null Object

![UML](/src/AdditionalDocs/uml/Null_Object.png)

 Объекты могут иметь значение NULL, они нуждаются в проверке на NULL-значение перед использованием, так как методы класса «нулевого» объекта, как правило, не могут вызываться.

**Null-object инкапсулирует отсутствие объекта путём замещения его другим объектом, который ничего не делает**.

## Применимость

- Когда объект требует взаимодействия с другими объектами. **Null Object не устанавливает нового взаимодействия - он использует уже установленное взаимодействие**;

- Когда какие-то из взаимодействующих объектов должны бездействовать;

- Когда требуется абстрагирование **«общения» с объектами, имеющими NULL-значение**.

## Шаги реализации

- Описать существующий интерфес, оставляя методы пустыми или описать "заглушки".

## Преимущества и недостатки

| + | - |
| ------ | ------ |
|Замена всех проблем с Null.|

## Отношения с другими паттернами

- Класс **Null Object** часто реализуется как [**Singleton**][Singleton]. Поскольку **Null Object** обычно не имеет какого-либо состояния, его состояние не может измениться, поэтому несколько экземпляров идентичны. Вместо того, чтобы использовать несколько одинаковых экземпляров, система может просто использовать один экземпляр повторно.

- Если некоторые клиенты ожидают, что **Null Object** ничего не сделает в одном направлении, а некоторые в другом, потребуются несколько классов NullObject. Класс NullObject потребует подключаемых переменных, чтобы клиент мог указать, как нулевой объект ничего не должен делать. Это может быть признаком абстрактного объекта, не имеющего четко определенного (семантического) интерфейса.

- **Null Object** не может стать реальным объектом. Если объект может стать реальным объектом - это не **Null Object**. Это может быть реальный объект с режимом do-nothing, например, контроллер, который может переключаться и находиться в режиме только для чтения. Если это один объект, он должен быть реализован с шаблоном State или, возможно, с  [**Proxy**][Proxy] шаблоном. В этом случае может использоваться Null State или прокси может содержать **Null Object**

- **Null Object** может быть аналогично использованию [**Proxy**][Proxy], но оба шаблона имеют разные цели. [**Proxy**][Proxy] обеспечивает уровень косвенности при доступе к объекту. **Null Object** не скрывает реального объекта и не контролирует доступ к нему, он заменяет реальный объект. [**Proxy**][Proxy] может в конечном итоге мутировать, чтобы начать действовать как настоящий субъект. **Null Object** не будет мутировать для запуска.

- **Null Object** может быть частным случаем шаблона [**Strategy**][Strategy]. [**Strategy**][Strategy] определяет несколько ConcreteStrategy классов как разные подходы к выполнению задачи. Если один из этих подходов должен ничего не делать, тогда этот ConcreteStrategy является NullObject. Например, контроллер представляет собой представление по стратегии для обработки ввода, а NoController - это стратегия, которая игнорирует все входные данные.

- **Null Object** может быть частным случаем [**State**][State]. Обычно у каждого ConcreteState есть некоторые методы для этого состояния. Фактически, данный метод часто реализуется, чтобы сделать что-то полезное в большинстве состояний. Если конкретный ConcreteState реализует большинство методов, так что они пустые или по крайней мере дают нулевые результаты, он становится **Null Object**.

- **Null Object** может использоваться, чтобы позволить [**Visitor**][Visitor] безопасно посещать иерархию и обрабатывать нулевую ситуацию.
  

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Object_Pool]: </src/Creational/Object_Pool/Object_Pool.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>
[Private_Class_Data]: </src/Structural/Private_Class_Data/Private_Class_Data.md>


[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
[Null_Object]: </src/Behavioral/Null_Object/Null_Object.md>
```java
package Behavioral.Observer.Example.ComponentIsPublisher.Components;

public class BasementAlarm extends Component {

  @Override
  public void update() {
    System.out.println("Basement Alarm is working");
  }
}
```
```java
package Behavioral.Observer.Example.ComponentIsPublisher.Components;

import java.util.ArrayList;
import java.util.List;

public abstract class Component {

  private List<Component> com = new ArrayList<>();

  public void addNotify(Component component) {
    com.add(component);
  }

  public void removeNotify(Component component) {
    com.remove(component);
  }

  public void notifyComponent() {
    com.forEach(Component::update);
  }

  public abstract void update();
}
```
```java
package Behavioral.Observer.Example.ComponentIsPublisher.Components;

public class FirstAlarm extends Component {

  @Override
  public void update() {
    System.out.println("First Alarm is Working");
  }
}
```
```java
package Behavioral.Observer.Example.ComponentIsPublisher.Components;

public class FourthAlarm extends Component {

  @Override
  public void update() {
    System.out.println("Fourth alarm is working");
  }
}
```
```java
package Behavioral.Observer.Example.ComponentIsPublisher.Components;

public class SecondAlarm extends Component {

  @Override
  public void update() {
    System.out.println("Second Alarm is working");
  }
}
```
```java
package Behavioral.Observer.Example.ComponentIsPublisher.Components;

public class ThirdAlarm extends Component {

  @Override
  public void update() {
    System.out.println("Third Alarm is working");
  }
}
```
```java
package Behavioral.Observer.Example.ComponentIsPublisher;

import Behavioral.Observer.Example.ComponentIsPublisher.Components.BasementAlarm;
import Behavioral.Observer.Example.ComponentIsPublisher.Components.Component;
import Behavioral.Observer.Example.ComponentIsPublisher.Components.FirstAlarm;
import Behavioral.Observer.Example.ComponentIsPublisher.Components.FourthAlarm;
import Behavioral.Observer.Example.ComponentIsPublisher.Components.SecondAlarm;
import Behavioral.Observer.Example.ComponentIsPublisher.Components.ThirdAlarm;

//Can be Circle Notification (never stops)

//Single Responsibility is fucked up
public class Ex {

  public static void main(String[] args) {
    Component alarm0 = new BasementAlarm();
    Component alarm1 = new FirstAlarm();
    Component alarm2 = new SecondAlarm();
    Component alarm3 = new ThirdAlarm();
    Component alarm4 = new FourthAlarm();

    alarm1.addNotify(alarm0);
    alarm1.addNotify(alarm2);

    alarm2.addNotify(alarm3);
    alarm2.addNotify(alarm4);
    alarm2.addNotify(alarm1);

    alarm2.notifyComponent();
    System.out.println("///////////////////////////");
    alarm1.notifyComponent();
  }

}
```
```java
package Behavioral.Observer.Example.Delegation;

import Behavioral.Observer.Example.Delegation.Observers.User;
import Behavioral.Observer.Example.Delegation.Subject.DataBase;

public class Ex2 {

  public static void main(String[] args) {
    DataBase dataBase = new DataBase(2, "School");
    User user1 = new User(1);
    User user2 = new User(2);
    User user3 = new User(3);

    dataBase.eventManager.registerObserver(user1);
    dataBase.eventManager.registerObserver(user2);
    dataBase.eventManager.registerObserver(user3);

    dataBase.setId(123);

    dataBase.eventManager.removeObserver(user1);

    dataBase.setName("PornHub");
  }

}
```
```java
package Behavioral.Observer.Example.Delegation.Observers;

public interface Observer {

  void update(String data);
}
```
```java
package Behavioral.Observer.Example.Delegation.Observers;

public class User implements Observer {

  private int id;

  public User(int id) {
    this.id = id;
  }

  @Override
  public void update(String data) {
    System.out.println("User: " + id + " get " + data);
  }
}
```
```java
package Behavioral.Observer.Example.Delegation.Subject;

public class DataBase {

  private int id;
  private String name;
  public EventManager eventManager;

  public DataBase(int id, String name) {
    this.id = id;
    this.name = name;
    eventManager = new EventManager();
  }

  public int getId() {
    return id;
  }

  public String getName() {
    return name;
  }

  //Notify user when DB is changed

  public void setId(int id) {
    this.id = id;
    eventManager.notifyObserver("Id have changed");
  }

  public void setName(String name) {
    this.name = name;
    eventManager.notifyObserver("Name have changed");
  }
}
```
```java
package Behavioral.Observer.Example.Delegation.Subject;

import Behavioral.Observer.Example.Delegation.Observers.Observer;
import java.util.ArrayList;
import java.util.List;

public class EventManager implements Observable {

  private List<Observer> users = new ArrayList<>();

  @Override
  public void registerObserver(Observer user) {
    users.add(user);
  }

  @Override
  public void removeObserver(Observer user) {
    users.remove(user);
  }

  @Override
  public void notifyObserver(String data) {
    users.forEach(x -> x.update(data));
  }
}
```
```java
package Behavioral.Observer.Example.Delegation.Subject;

import Behavioral.Observer.Example.Delegation.Observers.Observer;
//If we have one Publisher we need only Interface

public interface Observable {

  void registerObserver(Observer observer);

  void removeObserver(Observer observer);

  void notifyObserver(String data);
}
```
```java
package Behavioral.Observer.Example.ManytoMany;

import Behavioral.Observer.Example.ManytoMany.Observers.RadioChannel;
import Behavioral.Observer.Example.ManytoMany.Observers.TVChannel;
import Behavioral.Observer.Example.ManytoMany.Subject.RUNewsPublisher;
import Behavioral.Observer.Example.ManytoMany.Subject.UANewsPublisher;

// Better use Mediator
public class Ex1 {

  public static void main(String[] args) {
    RUNewsPublisher ruNewsPublisher = new RUNewsPublisher();
    UANewsPublisher uaNewsPublisher = new UANewsPublisher();
    RadioChannel radioChannel1 = new RadioChannel();
    RadioChannel radioChannel2 = new RadioChannel();
    TVChannel tvChannel = new TVChannel();

    ruNewsPublisher.registerObserver(radioChannel1);
    ruNewsPublisher.registerObserver(tvChannel);
    uaNewsPublisher.registerObserver(radioChannel2);
    uaNewsPublisher.registerObserver(tvChannel);

    ruNewsPublisher.setNews("Java - best in the world");
    ruNewsPublisher.removeObserver(radioChannel1);
    ruNewsPublisher.setNews("Java is great");

    uaNewsPublisher.setNews("Java == love");
  }

}
```
```java
package Behavioral.Observer.Example.ManytoMany.Observers;

import Behavioral.Observer.Example.ManytoMany.Subject.ObservablePublisher;

// Better use Mediator
public interface Observer {

  //We have more than one Publisher and we want to separate update method in channels
  void update(ObservablePublisher observablePublisher, String news);

  //if we don't have this task
  //void update(String news);
}
```
```java
package Behavioral.Observer.Example.ManytoMany.Observers;

import Behavioral.Observer.Example.ManytoMany.Subject.ObservablePublisher;
import Behavioral.Observer.Example.ManytoMany.Subject.RUNewsPublisher;
import Behavioral.Observer.Example.ManytoMany.Subject.UANewsPublisher;

public class RadioChannel implements Observer {

  @Override
  public void update(ObservablePublisher observablePublisher, String news) {
    if (observablePublisher instanceof RUNewsPublisher) {
      System.out.println("Radio says that - " + news + "says Russia");
    } else if (observablePublisher instanceof UANewsPublisher) {
      System.out.println("Radio says that - " + news + "says Ukraine");
    } else {
      System.out.println(observablePublisher);
    }
  }

}
```
```java
package Behavioral.Observer.Example.ManytoMany.Observers;

import Behavioral.Observer.Example.ManytoMany.Subject.ObservablePublisher;
import Behavioral.Observer.Example.ManytoMany.Subject.RUNewsPublisher;
import Behavioral.Observer.Example.ManytoMany.Subject.UANewsPublisher;

public class TVChannel implements Observer {

  @Override
  public void update(ObservablePublisher observablePublisher, String news) {
    if (observablePublisher instanceof RUNewsPublisher) {
      System.out.println("TV shows that - " + news + "says Russia");
    } else if (observablePublisher instanceof UANewsPublisher) {
      System.out.println("TV shows that - " + news + "says Ukraine");
    }
  }
}
```
```java
package Behavioral.Observer.Example.ManytoMany.Subject;

import Behavioral.Observer.Example.ManytoMany.Observers.Observer;

//Interface for Publisher
//If we have one Publisher we need only Interface

public interface Observable {

  void registerObserver(Observer observer);

  void removeObserver(Observer observer);

  void notifyObserver();
}
```
```java
package Behavioral.Observer.Example.ManytoMany.Subject;

import Behavioral.Observer.Example.ManytoMany.Observers.Observer;
import java.util.ArrayList;
import java.util.List;

public abstract class ObservablePublisher implements Observable {

  protected List<Observer> channels = new ArrayList<>();
  protected String news;

  @Override
  public void registerObserver(Observer observer) {
    channels.add(observer);
  }

  @Override
  public void removeObserver(Observer observer) {
    channels.remove(observer);
  }

// If we don't need to separate our Publisher / or we have only one Publisher
//
//  @Override
//  public void notifyObserver() {
//    channels.forEach(ch -> ch.update(news));
//  }

  public void setNews(String news) {
    this.news = news;
    analyzingNews();
  }

  protected abstract void analyzingNews();

}
```
```java
package Behavioral.Observer.Example.ManytoMany.Subject;

public class RUNewsPublisher extends ObservablePublisher {

  @Override
  public void notifyObserver() {
    channels.forEach(ch -> ch.update(this, news));
  }

  protected void analyzingNews() {

    // Do some work with News

    // Notify our channels
    notifyObserver();
  }
}
```
```java
package Behavioral.Observer.Example.ManytoMany.Subject;

public class UANewsPublisher extends ObservablePublisher {

  @Override
  public void notifyObserver() {
    channels.forEach(ch -> ch.update(this, news));
  }

  protected void analyzingNews() {

    // Do some work with News

    // Notify our channels
    notifyObserver();
  }
}
```
```java
package Behavioral.Observer.Example.withJDK;

import Behavioral.Observer.Example.withJDK.Observers.Investor;
import Behavioral.Observer.Example.withJDK.Subject.Community;

public class Ex3 {

  public static void main(String[] args) throws InterruptedException {
    Community community = new Community();
    Investor investor1 = new Investor();
    Investor investor2 = new Investor();

    community.addObserver(investor1);
    community.addObserver(investor2);

    community.agitation();
  }

}
```
```java
package Behavioral.Observer.Example.withJDK.Observers;

import java.util.Observable;
import java.util.Observer;

public class Investor implements Observer {

  @Override
  public void update(Observable o, Object arg) {
    System.out.println("We cong. community with so big membership");
  }
}
```
```java
package Behavioral.Observer.Example.withJDK.Subject;

import java.util.Observable;
import java.util.Random;

public class Community extends Observable {

  private int members;

  public Community() {
    this.members = 0;
  }

  public int getMembers() {
    return members;
  }

  private void addMembers(int members) {
    this.members += members;
    if (hasChanged()) {
      notifyObservers("our Community have came " + members);
    }
  }

  public void agitation() throws InterruptedException {
    //Index when we notify our investors
    int i = 10;
    while (true) {

      //Add members 1 to 10

      addMembers(new Random().nextInt(10));
      Thread.sleep(500);
      System.out.println(members);

      //When members more than 10 we notify our investors
      if (members / i > 0) {
        setChanged();
        i *= 10;
      }
    }
  }
}
```
# Наблюдатель

![UML](/src/AdditionalDocs/uml/Observer.png)

**Наблюдатель** - определяет отношение "один ко многим" между объектами таким образом,
что при **изменении состояния одного объекта (Subject, Observable)** происходит автоматическое **оповещение и обновление 
всех зависимых объектов**.

[(Ex)][Ex3] JDK уже имеет реализацию паттерна через унаследование класса **Observer и Observable**.
Полезно когда нам нужно **оповещать только по условию**, а не сразу, потому что метод обновления будет действовать
только если флаг `changed = true` (set/has/clear)Changed().

Большой минус то, что это уже реализованный класс. То есть extend = наследование.


## Применимость

 - Когда при **изменении состояния одного объекта требуется что-то сделать в других**, но вы не знаете наперёд какие именно объекты должны отреагировать.

   - Эта задача может возникнуть при разработке GUI фреймворка, когда надо дать возможность сторонним классам реагировать на **клики по кнопкам**.

   - Паттерн **Наблюдатель** даёт возможность любому объекту с интерфейсом подписчика, подписываться на изменения в объектах-издателях.

 - Когда одни объекты должны наблюдать за другими, но только в определённых случаях.

   - Издатели ведут динамические списки. Все **наблюдатели могут подписываться или отписываться на обновления прямо во время выполнения** программы.

## Шаги реализации

1. Разбейте вашу функциональность на две части: **независимое ядро** и **опциональные зависимые части**. Независимое ядро станет издателем. Зависимые части станут подписчиками.

2. Создайте **интерфейс подписчиков**. В большинстве случаев, в нём достаточно определить единственный метод оповещения `update()`.

3. Создайте **интерфейс издателей** и опишите в нём **операции управления подпиской**. Помните, что издатель должен работать только с **общим интерфейсом подписчиков**.

4. [(Ex)][Ex1] Вам нужно решить, куда поместить **код ведения подписки**, ведь он обычно бывает одинаков для всех типов издателей. Самый очевидный способ - **вынести этот код в промежуточный абстрактный класс**, от которого будут **наследоваться все издатели**.

5. [(Ex)][Ex2] Но если вы интегрируете паттерн в существующие классы, то создать новый базовый класс может быть затруднительно. В этом случае, вы можете поместить **логику подписки во вспомогательный объект и делегировать ему работу из издателей**.

6. Создайте **классы конкретных издателей**. Реализуйте их так, чтобы **при каждом изменении** состояния, они **слали оповещения** всем своим подписчикам.

7. Реализуйте **метод оповещения в конкретных подписчиках**. Издатель может **отправлять какие-то данные вместе с оповещением** (например, в параметрах). Возможен и **другой вариант, когда подписчик, получив оповещение, сам берёт из объекта издателя нужные данные**. Но при этом **подписчик привяжет себя к конкретному классу издателя**. (Программировать не интерфейсами)

8. Клиент должен создавать необходимое количество объектов подписчиков и **подписывать** их у издателей.

## Преимущества и недостатки

| + | - |
| ------ | ------ |
|**Издатель не зависит** от конкретных классов подписчиков.| Наблюдатели оповещаются в случайном порядке.
|Вы можете подписывать и отписывать получателей **на лету**.|
|Реализует принцип [**открытости/закрытости**][OCP].

## Отношения с другими паттернами

 - [**Цепочка обязанностей**][Chain_of_Responsibility], [**Команда**][Command], [**Посредник**][Mediator] и **Наблюдатель** показывают различные способы работы отправителей запросов с их получателями:

   - [**Цепочка обязанностей**][Chain_of_Responsibility] передаёт запрос последовательно через цепочку потенциальных получателей,
    ожидая, что какой-то из них обработает запрос.
   
   - [**Команда**][Command] устанавливает косвенную одностороннюю связь от отправителей к получателям.
   
   - [**Посредник**][Mediator] убирает прямую связь между отправителями и получателями, заставляя их общаться опосредованно,
    через себя.
   
   - **Наблюдатель** передаёт запрос одновременно всем заинтересованным получателям, но позволяет им динамически подписывать
    или отписываться от таких оповещений.
   
 - Разница между [**Посредником**][Mediator] и **Наблюдателем** не всегда очевидна. Чаще всего они выступают как конкуренты,
    но иногда могут работать вместе.

    Цель [**Посредника**][Mediator] - убрать обоюдные зависимости между компонентами системы. 
    Вместо этого они становятся зависимыми от самого посредника. С другой стороны, 
    цель **Наблюдателя** - обеспечить динамическую одностороннюю связь, в которой одни объекты косвенно зависят от других.

    Довольно популярна реализация [**Посредника**][Mediator] при помощи **Наблюдателя**. 
    При этом объект посредника будет выступать издателем, а все остальные компоненты станут подписчиками и смогут динамически следить за событиями,
    происходящими в посреднике. В этом случае трудно понять, чем же отличаются оба паттерна.

    Но [**Посредник**][Mediator] имеет и другие реализации, когда отдельные компоненты жёстко привязаны к объекту посредника. Такой код вряд ли будет напоминать **Наблюдателя**,
    но всё же останется [**Посредником**][Mediator].

    Теперь представьте другую программу, в которой каждый компонент системы становится издателем. Компоненты могут подписываться друг на друга,
    в то же время, не привязываясь к конкретным классам. Программа будет состоять из целой сети наблюдателей, не имея центрального объекта посредника.

[Ex1]: </src/Behavioral/Observer/Example/ManytoMany/>
[Ex2]: </src/Behavioral/Observer/Example/Delegation/>
[Ex3]: </src/Behavioral/Observer/Example/withJDK/>

[OCP]: </src/AdditionalDocs/SOLID/Open-Closed_principle.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
```java
package Behavioral.State.Example;

import Behavioral.State.Example.Phone.Phone;

public class Ex {

  public static void main(String[] args) throws InterruptedException {
    Phone phone = new Phone(1111);

    phone.touchScreen();
    Thread.sleep(1000);

    phone.touchScreen();
    phone.clickLockButton();
    phone.touchScreen();
  }
}
```
```java
package Behavioral.State.Example.Phone;

import Behavioral.State.Example.States.LockScreen;
import Behavioral.State.Example.States.ScreenState;
import Behavioral.State.Example.States.UnlockedScreen;

public class Phone {

  //Context have different states

  //Double bond for changing the connection
  private ScreenState screenOffState;
  private ScreenState screenOnState;

  private ScreenState currentState;
  private int PIN;

  public Phone(int PIN) {
    this.PIN = PIN;
    screenOffState = new LockScreen(this);
    screenOnState = new UnlockedScreen(this);
    currentState = screenOffState;
  }

  //Some dependable on State method
  public void clickLockButton() {
    currentState.clickLockButton();
  }

  public void touchScreen() {
    currentState.touchScreen();
  }

  //Another method

  public void dropPhone() {
    System.out.println("Screen is a bit scratch, Y vas lapki");
  }

  public ScreenState getScreenOffState() {
    return screenOffState;
  }

  public ScreenState getScreenOnState() {
    return screenOnState;
  }

  public void setCurrentState(ScreenState currentState) {
    this.currentState = currentState;
  }

  public int getPIN() {
    return PIN;
  }
}
```
```java
package Behavioral.State.Example.States;

import Behavioral.State.Example.Phone.Phone;
import java.util.Date;
import java.util.Scanner;

public class LockScreen implements ScreenState {

  //Double bond for changing the connection
  private Phone phone;
  private Scanner sc;

  public LockScreen(Phone phone) {
    this.phone = phone;
    sc = new Scanner(System.in);
  }

  @Override
  public void touchScreen() {
    System.out.println("You see current time: " + new Date().toString());
  }

  @Override
  public void clickLockButton() {
    System.out.println("Write PIN pls :");

    int attempt = 3;
    while (attempt > 0) {
      if (pinCheck(sc.nextInt())) {
        phone.setCurrentState(phone.getScreenOnState());
        System.out.println("Welcome");
        break;
      } else {
        System.out.println("You wrote incorrect PIN, pls try again");
        attempt--;
      }
    }
  }

  private boolean pinCheck(int pin) {
    return pin == phone.getPIN();
  }
}
```
```java
package Behavioral.State.Example.States;

public interface ScreenState {

  void clickLockButton();

  void touchScreen();
}
```
```java
package Behavioral.State.Example.States;

import Behavioral.State.Example.Phone.Phone;

public class UnlockedScreen implements ScreenState {

  //Double bond for changing the connection
  private Phone phone;

  public UnlockedScreen(Phone phone) {
    this.phone = phone;
  }

  //Change state of phone
  @Override
  public void clickLockButton() {
    phone.setCurrentState(phone.getScreenOffState());
  }

  @Override
  public void touchScreen() {
    System.out.println("You touch screen... And what do you wanted to see?");
  }
}
```
# Состояние 

![UML](/src/AdditionalDocs/uml/Strategy.png)

Позволяет **менять поведение в зависимости от своего состояния**. Извне создаётся впечатление, что изменился класс объекта.

Очень важным нюансом, отличающим этот паттерн от [**Стратегии**][Strategy], является то, что **и контекст, и сами конкретные состояния могут знать друг о друге и инициировать переходы от одного состояния к другому**.

## Применимость
 
  - Когда у вас есть объект, поведение которого кардинально меняется в зависимости от внутреннего состояния. Причём типов состояний много и их код часто изменяется.

    - Паттерн предлагает создать класс для каждого такого состояния, а затем **переместить туда все поля и методы, связанные с состоянием**. Первоначальный класс будет постоянно ссылаться на один из объектов-состояний, **делегируя ему большую часть работы**. Для изменения состояния, в контекст будет подставляться другой объект.

  - Когда **код класса содержит множество больших, похожих друг на друга, условных операторов**, которые выбирают поведения в зависимости от текущих значений полей класса.

    - Паттерн предлагает переместить каждую ветку такого условного оператора в собственный класс. Тут же можно поселить и все поля, связанные с данным состоянием.

  - Когда вы сознательно **используете табличную машину состояний**, построенную на условных операторах, но вынуждены мириться с дублированием кода для похожих состояний и переходов.

    - Паттерн **Состояние** позволяет реализовать **иерархическую машину состояний, базирующуюся на наследовании**. Вы можете отнаследовать похожие состояния от одного родительского класса, и вынести туда весь дублирующий код.

## Шаги реализации

1. Определитесь с классом, который будет отыгрывать роль контекста. Это может быть как существующий класс, в котором уже есть зависимость от состояния, так и новый класс, если код состояний размазан по нескольким классам.

2. Создайте интерфейс состояния. Он должен **описывать методы, общие для всех состояний, обнаруженных в контексте**.

3. Для каждого фактического состояния, создайте класс, реализующий интерфейс состояния. Переместите весь код, связанный с конкретным состоянием в нужный класс. В конце концов, все методы интерфейса состояния должны быть реализованы.

4. Создайте **в контексте поле для хранения объектов-состояний, а также публичный метод для изменения значения этого поля**.

5. Старые методы контекста, в которых находился зависимый от состояния код, замените на вызовы соответствующих методов объекта-состояния.

6. В зависимости от бизнес-логики, разместите код, который переключает состояние контекста либо внутри контекста, либо внутри классов конкретных состояний.

## Преимущества и недостатки

| + | - |
| ------ | ------ |
 |Избавляет от множества больших условных операторов машины состояний.|Может неоправданно усложнить код, если состояний мало и они редко меняются.
 |Концентрирует в одном месте код, связанный с определённым состоянием.
 |Упрощает код контекста.
 
## Отношения с другими паттернами

- [**Мост**][Bridge], [**Стратегии**][Strategy] и **Состояние** (а также слегка и [**Адаптер**][Adapter]) имеют схожие структуры классов - все они построены на принципе [**«композиции»**][Composition], то есть делегирования работы другим объектам. Тем не менее, они отличаются тем, что решают разные проблемы. Помните, что паттерны - это не только рецепт построения кода определённым образом, но и описание проблем, которые привели к данному решению.

- **Состояние** можно рассматривать как надстройку над [**Стратегией**][Strategy]. Оба паттерна используют композицию, чтобы менять поведение основного объекта, делегируя работу вложенным объектам-помощникам. Однако в [**Стратегии**][Strategy] эти объекты не знают друг о друге и никак не связаны. В **Состоянии** сами конкретные состояния могут переключать контекст.

[Composition]: </src/AdditionalDocs/Composition.md>

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
```java
package Behavioral.Strategy.Example.Context;

import Behavioral.Strategy.Example.Strategy_Variation.IStrategy;

public class Context {

  private IStrategy strategy;

  public Context(IStrategy strategy) {
    this.strategy = strategy;
  }

  //or with Setter

  public void setStrategy(IStrategy strategy) {
    this.strategy = strategy;
  }

  //do work with super class (interface)

  public double executeStrategy(int num1, int num2) {
    return strategy.doOperation(num1, num2);
  }
}
```
```java
package Behavioral.Strategy.Example;

import Behavioral.Strategy.Example.Context.Context;
import Behavioral.Strategy.Example.Strategy_Variation.OperationAdd;
import Behavioral.Strategy.Example.Strategy_Variation.OperationMultiply;
import Behavioral.Strategy.Example.Strategy_Variation.OperationSubstract;

public class StrategyPattern {

  public static void main(String[] args) {
    Context context = new Context(new OperationAdd());
    System.out.println("10 + 5 = " + context.executeStrategy(10, 5));

    context = new Context(new OperationSubstract());
    System.out.println("10 - 5 = " + context.executeStrategy(10, 5));

    context = new Context(new OperationMultiply());
    System.out.println("10 * 5 = " + context.executeStrategy(10, 5));
  }
}
```
```java
package Behavioral.Strategy.Example.Strategy_Variation;

public interface IStrategy {

  int doOperation(int num1, int num2);
}
```
```java
package Behavioral.Strategy.Example.Strategy_Variation;

public class OperationAdd implements IStrategy {

  @Override
  public int doOperation(int num1, int num2) {
    return num1 + num2;
  }
}
```
```java
package Behavioral.Strategy.Example.Strategy_Variation;

public class OperationMultiply implements IStrategy {

  @Override
  public int doOperation(int num1, int num2) {
    return num1 * num2;
  }
}
```
```java
package Behavioral.Strategy.Example.Strategy_Variation;

public class OperationSubstract implements IStrategy {

  @Override
  public int doOperation(int num1, int num2) {
    return num1 - num2;
  }
}
```
# Стратегия

![UML](/src/AdditionalDocs/uml/Strategy.png)

**Стратегия** определяет семейство алгоритмов, инкапсулирует каждый из них 
и обеспечивает их взаимозаменяемость. Он позволяет модифицировать алгоритмы
независимо от их использования на стороне клиента.

## Применимость

 - Когда вам нужно использовать **разные вариации какого-то алгоритма внутри одного объекта**.

   - Стратегия позволяет **варьировать поведение** объекта во время выполнение программы, подставляя в него различные объекты-поведения (например, отличающиеся балансом скорости и потребления ресурсов).

 - Когда у вас есть множество **похожих классов**, отличающихся только некоторым поведением.

   - Стратегия позволяет вынести отличающееся поведение в отдельную иерархию классов и **свести первоначальные классы к одному**, сделав его поведение настраиваемым.

 - Когда вы не хотите обнажать **детали реализации** алгоритмов для других классов.

   - Стратегия позволяет **изолировать код**, данные и зависимости алгоритмов от других объектов, скрыв из внутри собственных классов.

 - Когда различные вариации алгоритмов реализованы в виде **развесистого условного оператора**. Каждая ветка такого оператора представляет вариацию алгоритма.

   - Стратегия помещает **каждую лапу** такого оператора **в отдельный класс-стратегию**. Затем контекст получает определённый объект-стратегию от клиента и делегирует ему работу. Если вдруг понадобится сменить алгоритм, в контекст можно подать другую стратегию.

## Шаги реализации

1. Определите алгоритм, который подвержен частым изменениям. Также подойдёт алгоритм, имеющий несколько вариаций, которые выбираются во время выполнения программы.

2. Создайте интерфейс стратегий, описывающий этот алгоритм. Он должен быть общим для всех вариантов алгоритма.

3. Поместите **вариации алгоритма в собственные классы**, которые реализуют этот интерфейс.

4. **В классе контекста создайте поле для хранения ссылки на текущий объект-стратегию**, а также метод для её изменения. Убедитесь в том, что контекст работает с этим объектом только через общий интерфейс стратегий.

5. Клиенты контекста должны подавать в контекст соответствующий объект-стратегию, когда хотят, чтобы тот вёл себя определённым образом.

## Преимущества и недостатки

| + | - |
| ------ | ------ |
|Горячая **замена алгоритмов** на лету.| Усложняет программу за счёт **дополнительных классов**.
|**Изолирует код** и данные алгоритмов от остальных классов.|**Клиент должен** знать, в чём разница между стратегиями, чтобы **выбрать подходящую**.
|Уход от наследования к **делегированию**.
|Реализует принцип **открытости/закрытости**.

## Отношения с другими паттернами
  
 - [**Мост**][Bridge], **Стратегия** и [**Состояние**][State] (а также слегка и [**Адаптер**][Adapter]) имеют схожие структуры классов - все они построены на принципе [**«композиции»**][Composition], то есть делегирования работы другим объектам. Тем не менее, они отличаются тем, что решают разные проблемы. Помните, что паттерны - это не только рецепт построения кода определённым образом, но и описание проблем, которые привели к данному решению.
  
 - [**Команда**][Command] и **Стратегия** похожи по духу, но отличаются масштабом и применением:
   - [**Команду**][Command] используют, чтобы превратить любые разнородные действия в объекты. Параметры операции превращаются в поля объекта. Этот объект теперь можно логировать, хранить в истории для отмены, передавать во внешние сервисы и так далее.
   
   - С другой стороны, **Стратегия** описывает разные способы сделать одно и то же действие, позволяя взаимозаменять эти способы в каком-то объекте контекста.
 
 - **Стратегия** меняет поведение объекта «изнутри», а [**Декоратор**][Decorator] изменяет его «снаружи».
  
 - [**Шаблонный метод**][Template Method] использует наследование, чтобы расширять части алгоритма. **Стратегия** использует делегирование, чтобы изменять алгоритм. [**Шаблонный метод**][Template Method] работает на уровне классов. **Стратегия** позволяет менять логику отдельных объектов.
  
 - [**Состояние**][State] можно рассматривать как надстройку над **Стратегией**. Оба паттерна используют [**композицию**][Composition], чтобы менять поведение основного объекта, делегируя работу вложенным объектам-помощникам. Однако в **Стратегии** эти объекты не знают друг о друге и никак не связаны. В [**Состоянии**][State] сами конкретные состояния могут переключать контекст.


[Composition]: </src/AdditionalDocs/Composition.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Adapter]: </src/Structural/Adapter/Adapter.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[State]: </src/Behavioral/State/State.md>
[Command]: </src/Behavioral/Command/Command.md>
[Template Method]: </src/Behavioral/Template_Method/Template_Method.md>
```java
package Behavioral.Template_Method.Example.Beverage;

public abstract class Beverage {

  final public void prepare() {
    boilWater();
    brew();
    if (isWantHug()) {

      //Some optional(can ignore) steps

      System.out.println("Cheek to cheek");
    }
  }

  //Changeable method
  abstract protected void brew();

  //our hook
  protected boolean isWantHug() {

    //Some default code

    return false;
  }


  //Structure of algorithm
  //Common steps in ALL algorithms
  private void boilWater() {
    System.out.println("Boiling water");
  }

  private void pourInCup() {
    System.out.println("Pouring in a cup");
  }
}
```
```java
package Behavioral.Template_Method.Example.Beverage;

public class Coffee extends Beverage {

  @Override
  protected void brew() {
    System.out.println("Dripping Coffee through filter");
  }

}
```
```java
package Behavioral.Template_Method.Example.Beverage;

import java.util.Scanner;

public class Tea extends Beverage {

  private Scanner sc = new Scanner(System.in);

  @Override
  protected void brew() {
    System.out.println("Steeping the tra");
  }

  //Hook
  @Override
  protected boolean isWantHug() {
    System.out.println("You want hugs");
    System.out.println("y|n");

    return sc.nextLine().equals("y");
  }
}
```
```java
package Behavioral.Template_Method.Example;

import Behavioral.Template_Method.Example.Beverage.Coffee;
import Behavioral.Template_Method.Example.Beverage.Tea;

public class Ex1 {

  public static void main(String[] args) {
    Coffee coffee = new Coffee();
    Tea tea = new Tea();

    coffee.prepare();
    System.out.println("/////");
    tea.prepare();
  }

}
```
# Шаблонный метод 

![UML](/src/AdditionalDocs/uml/Template_Method.png)

Определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. **Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры**.

**Перехватчик (hook)** - метод объявленный в абстрактном классе, но имеющий пустую реализацию (или по умолчанию). Дает возможность, по желанию, **субкалссу подключаться к алгоритму в разных точках**. (Для необязательных частей алгоритма)

Применение JAVA : **`java.util.Arrays.sort()`** - Не похожа на обычную реализацию (через наследование), так как `sort()` статический. Нужно для сравниваемых объектов реализовать интерфейс `Comparable` метод `compereTo()`, который используется в методе `sort()`.

## Применимость

 - Когда подклассы должны **расширять базовый алгоритм, не меняя его структуры**.

   - Шаблонный метод позволяет подклассам расширять определённые шаги алгоритма через наследование, не меняя при этом структуру алгоритмов, объявленную в родительском классе.

 - Когда у вас есть несколько классов, делающих одно и то же с незначительными отличиями. Если вы редактируете один класс, то приходится вносить такие же правки и в остальные классы.

   - Паттерн шаблонный метод предлагает **создать для похожих классов общий суперкласс и оформить в нём главный алгоритма в виде шагов**. Отличающиеся шаги можно переопределить в подклассах.

     Это позволит **убрать дублирование кода в нескольких классах с похожим поведением, но отличающихся в деталях**.

## Шаги реализации
1. Изучите алгоритм и подумайте, можно ли его разбить на шаги. Какие шаги будут стандартными для всех вариаций алгоритма, а какие - изменчивыми.

2. Создайте абстрактный базовый класс. Определите в нём шаблонный метод. Этот метод должен состоять из вызовов шагов алгоритма. **Имеет смысл сделать шаблонный метод финальным**, чтобы подклассы не могли его переопределить.

3. Добавьте в абстрактный класс методы для каждого из шагов алгоритма. **Стандартные шаги должны иметь реализацию по умолчанию. Изменяемые шаги должны быть объявлены абстрактными.** Их нужно будет реализовать в подклассах.

4. Подумайте о введении в алгоритм хуков. Чаще всего, хуки располагают между основными шагами алгоритма, а также до и после всех шагов.

5. Создайте конкретные классы, унаследовав их от абстрактного класса. Реализуйте в них все недостающие шаги и хуки.

## Преимущества и недостатки
 | + | - |
 | ------ | ------ |
 |Облегчает повторное использование кода. |Вы можете нарушить [**Принцип подстановки Барбары Лисков**][LSP], изменяя базовое поведение одного из шагов алгоритма через подкласс.
 |Вы **жёстко ограничены скелетом существующего алгоритма**. |С ростом количества шагов, шаблонный метод становится слишком сложно поддерживать.
 
## Отношения с другими паттернами

- [**Фабричный метод**][Factory_Method] можно рассматривать как частный случай **Шаблонного метода**. Кроме того, [**Фабричный метод**][Factory_Method] нередко бывает частью большого класса с **Шаблонными методами**.

- **Шаблонный метод** использует наследование, чтобы расширять **части алгоритма**. [**Стратегия**][Strategy] использует делегирование, чтобы изменять алгоритм. **Шаблонный метод** работает на уровне классов. [**Стратегия**][Strategy] позволяет менять логику отдельных объектов.


[LSP]: </src/AdditionalDocs/SOLID/Liskov_Substitution_principle.md>

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
```java
package Behavioral.Visitor.Example;

import Behavioral.Visitor.Example.Shapes.Circle;
import Behavioral.Visitor.Example.Shapes.Rectangle;
import Behavioral.Visitor.Example.Shapes.Shape;
import Behavioral.Visitor.Example.Visitors.PaintDraw;
import Behavioral.Visitor.Example.Visitors.Visitor;
import Behavioral.Visitor.Example.Visitors.XMLExportVisitor;

// Adding new Type of Shape (Dot, Sphere ...) is bad
// bc we need to add new code to ALL visitors

public class Ex {

  public static void main(String[] args) {
    Shape circle = new Circle("1", 23);
    Shape circle2 = new Circle("2", 2);
    Shape rectangle = new Rectangle("1", 20, 30);
    Shape rectangle2 = new Rectangle("2", 2, 3000);

    Visitor paint = new PaintDraw();
    Visitor xml = new XMLExportVisitor();

    circle.accept(paint);
    circle2.accept(paint);
    rectangle2.accept(paint);

    circle.accept(xml);
    rectangle2.accept(xml);
  }
}
```
```java
package Behavioral.Visitor.Example.Shapes;

import Behavioral.Visitor.Example.Visitors.Visitor;

public class Circle extends Shape {

  private int r;

  public Circle(String name, int r) {
    super(name);
    this.r = r;
  }

  public void expand() {
    System.out.println("Expanding.. NAME: " + name);
  }

  @Override
  public void accept(Visitor visitor) {
    visitor.visit(this);
  }
}
```
```java
package Behavioral.Visitor.Example.Shapes;

import Behavioral.Visitor.Example.Visitors.Visitor;

public class Rectangle extends Shape {

  private int x;
  private int y;

  public Rectangle(String name, int x, int y) {
    super(name);
    this.x = x;
    this.y = y;
  }

  public void rotate() {
    System.out.println("Vgux vgux NAME: " + name);
  }

  @Override
  public void accept(Visitor visitor) {
    visitor.visit(this);
  }
}
```
```java
package Behavioral.Visitor.Example.Shapes;

import Behavioral.Visitor.Example.Visitors.Visitor;

// If we will add some new Shapes we fucked up
// bc we need add new logic to ALL Visitors

public abstract class Shape {

  protected String name;

  public Shape(String name) {
    this.name = name;
  }

  public abstract void accept(Visitor visitor);
}
```
```java
package Behavioral.Visitor.Example.Visitors;

import Behavioral.Visitor.Example.Shapes.Circle;
import Behavioral.Visitor.Example.Shapes.Rectangle;

public class PaintDraw implements Visitor {

  @Override
  public void visit(Rectangle rectangle) {
    System.out.println("Rectangle in Paint");
    rectangle.rotate();
  }

  @Override
  public void visit(Circle circle) {
    System.out.println("Circle in Paint");
    circle.expand();
  }
}
```
```java
package Behavioral.Visitor.Example.Visitors;

import Behavioral.Visitor.Example.Shapes.Circle;
import Behavioral.Visitor.Example.Shapes.Rectangle;

//Adding new Visitors is norm
public interface Visitor {

  void visit(Rectangle rectangle);

  void visit(Circle circle);
}
```
```java
package Behavioral.Visitor.Example.Visitors;

import Behavioral.Visitor.Example.Shapes.Circle;
import Behavioral.Visitor.Example.Shapes.Rectangle;

public class XMLExportVisitor implements Visitor {

  @Override
  public void visit(Rectangle rectangle) {
    System.out.println("Rectangle in XML LOL");
  }

  @Override
  public void visit(Circle circle) {
    System.out.println("Circle in XML OR");
  }
}
```
# Посетитель

![UML](/src/AdditionalDocs/uml/Visitor.png)

Позволяет **создавать новые операции, не меняя классы объектов, над которыми эти операции могут выполняться**.

[***Проблема раннего и позднего связывания**][BindingTypes]

## Применимость

 - Когда вам нужно выполнить операцию над всеми элементами сложной структуры объектов (например, деревом).

   - **Посетитель** позволяет применять одну и ту же операцию к объектам различных классов.

 - Когда над объектами сложной структуры объектов надо выполнять некоторые, **не связанные между собой операций, но вы не хотите «засорять» классы такими операциями**.

   - **Посетитель** позволяет извлечь родственные операции из классов, составляющих структуру объектов, поместив их в один класс-посетитель. **Если структура объектов является общей для нескольких приложений, то паттерн позволит в каждое приложение включить только нужные операции**.

 - Когда **новое поведение имеет смысл только для некоторых классов из существующей иерархии**.

   - **Посетитель** позволяет определить поведение только для этих классов и оставить его пустым для всех остальных.

## Шаги реализации
 
1. Создайте **интерфейс посетителя и объявите в нём методы «посещения» для каждого класса компонента, который существует в программе**.

2. **Опишите интерфейс компонентов**. Если вы работаете с уже существующими классами, то объявите абстрактный метод принятия посетителей в базовом классе иерархии компонентов.

3. Реализуйте **методы принятия во всех конкретных компонентах**. Они должны **переадресовывать вызовы тому методу посетителя, в котором класс параметра совпадает с текущим классом компонента**.

4. Иерархия компонентов должна знать только о **базовом интерфейсе посетителей**. С другой стороны, **посетители будут знать обо всех классах компонентов**.

5. Для **каждого нового поведения создайте свой конкретный класс**. Приспособьте это поведение для всех посещаемых компонентов, **реализовав все методы интерфейса посетителей**.

   Вы можете столкнуться с ситуацией, **когда посетителю нужен будет доступ к приватным полям компонентов**. **В этом случае, вы можете либо раскрыть доступ к этим полям, нарушив инкапсуляцию компонентов, либо сделать класс посетителя вложенным в класс компонента**, если вам повезло писать на языке, который поддерживает вложенность классов.

6. Клиент будет создавать объекты посетителей, а затем передавать их компонентам, используя метод принятия.

## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |Упрощает **добавление новых операций над всей связанной структурой объектов**.|Паттерн **неоправдан, если иерархия компонентов часто меняется**.
 |Объединяет родственные операции в одном классе. |Может привести к нарушению инкапсуляции компонентов.
 |Посетитель **может накоплять состояние при обходе структуры компонентов**.
 
## Отношения с другими паттернами

- **Посетитель** можно рассматривать как расширенный аналог [**Команды**][Command], который способен работать сразу с несколькими видами получателей.

- Вы можете выполнить какое-то действие над всем деревом [**Компоновщика**][Composite] при помощи **Посетителя**.

- **Посетитель** можно использовать совместно с [**Итератором**][Iterator]. [**Итератор**][Iterator] будет отвечать за обход структуры данных, а **Посетитель** - за выполнение действий над каждым её компонентом.

[BindingTypes]: </src/AdditionalDocs/BindingTypes/>

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
# Строитель

![UML](/src/AdditionalDocs/uml/Builder.png)

Позволяет создавать сложные объекты пошагово.
 
**Строитель** даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.

## Применимость

- Когда вы хотите избавиться от «*телескопического конструктора*».

  - Допустим, у вас есть один конструктор с десятью опциональными параметрами. Его неудобно вызывать, поэтому вы создали ещё десять конструкторов с меньшим количеством параметров. Всё что они делают - это переадресуют вызов к главному конструктору, подавая какие-то значения по умолчанию в качестве опциональных параметров.
  
```java
class Pizza {
    Pizza(int size) { ... }        
    Pizza(int size, boolean cheese) { ... }    
    Pizza(int size, boolean cheese, boolean pepperoni) { ... }
    ...
```

Паттерн **Строитель** позволяет **собирать объекты пошагово, вызывая только те шаги, которые вам нужны**. А значит, больше не нужно пытаться запихнуть в конструктор все возможные опции продукта.

- Когда ваш код должен создавать **разные представления какого-то объекта**. Например, деревянные и железобетонные дома.

  - **Строитель** можно применить, если создание нескольких представлений объекта состоит из одинаковых этапов, которые отличаются в деталях.

    **Интерфейс строителей определит все возможные этапы конструирования**. Каждому представлению будет соответствовать собственный класс-строитель. А **порядок этапов строительства будет задавать класс-директор** (возможно что и сам клиент).

- Когда вам нужно собирать сложные составные объекты, например, деревья [**Компоновщика**][Composite].

  - **Строитель** конструирует объекты пошагово, а не за один проход. Более того, шаги строительства **можно выполнять рекурсивно**. А без этого не построить древовидную структуру вроде [**Компоновщика**][Composite].

    Заметьте, что **Строитель** не позволяет посторонним объектам иметь доступ к конструируемому объекту пока тот не будет полностью готов. Это предотвращает клиентский код от получения незаконченных «битых» объектов.

## Шаги реализации

1. Убедитесь в том, что создание разных представлений объекта **можно свести к общим шагам**.

2. Опишите эти шаги в общем интерфейсе строителей.

3. Для каждого из представлений объекта-продукта создайте по одному классу-строителю и реализуйте их методы строительства.

   Не забудьте про метод получения результата. Обычно, конкретные строители определяют собственные методы получения результата строительства. Вы не можете описать эти методы в интерфейсе строителей, так **продукты не обязательно должны иметь общий базовый класс или интерфейс**. Но вы всегда можете добавить метод получения результата в общий интерфейс, если ваши строители производят однородные продукты с общим предком.

4. Подумайте о создании класса директора. Его методы будут создавать различные конфигурации продуктов, вызывая разные шаги одного и того же строителя.

5. **Клиентский код должен будет создавать и объекты строителей, и/(или нет) объект директора**. Перед началом строительства, клиент должен связать определённого строителя с директором. Это можно сделать либо через конструктор, либо через сеттер, либо подав строителя напрямую в в строительный метод директора.

6. **Результат строительства можно вернуть из директора, но только если метод возврата продукта удалось поместить в общий интерфейс строителей. Иначе, вы жёстко привяжете директора к конкретным классам строителей**.

## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |Позволяет создавать продукты пошагово.|Усложняет код программы за счёт дополнительных классов.
 |Позволяет использовать **один и тот же код для создания различных продуктов**. |Клиент будет привязан к конкретным классам строителей, так как **в интерфейсе строителя может не быть метода получения результата**.
 |Изолирует сложный код сборки продукта от его основной бизнес-логики.
 
 
## Отношения с другими паттернами

- Многие архитектуры начинаются с применения [**Фабричного метода**][Factory_Method] (более простого и расширяемого через подклассы) и эволюционируют в сторону [**Абстрактной фабрики**][Abstract_Factory], [**Прототипа**][Prototype] или **Строителя** (более гибких, но и более сложных).

- **Строитель** концентрируется на постройке сложных объектов шаг за шагом. [**Абстрактная фабрика**][Abstract_Factory] специализируется на создании семейств связанных продуктов. **Строитель** возвращает продукт только после выполнения всех шагов, а [**Абстрактная фабрика**][Abstract_Factory] возвращает продукт сразу же.

- **Строитель** позволяет пошагово сооружать дерево [**Компоновщика**][Composite].

- Паттерн **Строитель** может быть построен в виде [**Моста**][Bridge]: директор будет играть роль абстракции, а строители - реализации.

- [**Абстрактная фабрика**][Abstract_Factory], **Строитель** и [**Прототип**][Prototype] могут быть реализованы при помощи [**Одиночки**][Singleton].


[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
```java
package Creational.Builder.Example.BuilderDirector.Builders;

import Creational.Builder.Example.BuilderDirector.Object.House;

public interface Builder {

  void setWall(int wall);

  void setFoundation();

  void setWindow(int window);

  void setRoof();

  void setDoor(int door);

  House getHouse();
}
```
```java
package Creational.Builder.Example.BuilderDirector.Builders;

import Creational.Builder.Example.BuilderDirector.Object.House;

public class CheepBuilder implements Builder {

  private int price;
  private int wall;
  private int door;
  private int window;
  private String roof;
  private String foundation;

  @Override
  public void setWall(int wall) {
    this.wall = wall;
    price += 200 * wall;
  }

  @Override
  public void setWindow(int window) {
    this.window = window;
    price += 100 * window;
  }

  @Override
  public void setRoof() {
    roof = "Cheap";
    price += 400;
  }

  @Override
  public void setFoundation() {
    foundation = "Cheap";
    price += 400;
  }

  @Override
  public void setDoor(int door) {
    this.door = door;
    price += 50 * door;
  }

  @Override
  public House getHouse() {
    House house = new House(wall, door, window, price, foundation, roof);
    price = 0;
    return house;
  }
}
```
```java
package Creational.Builder.Example.BuilderDirector.Builders;

import Creational.Builder.Example.BuilderDirector.Object.House;

public class RichBuilder implements Builder {

  private int price;
  private int wall;
  private int door;
  private int window;
  private String roof;
  private String foundation;

  @Override
  public void setWall(int wall) {
    this.wall = wall;
    price += 600 * wall;
  }

  @Override
  public void setWindow(int window) {
    this.window = window;
    price += 300 * window;
  }

  @Override
  public void setRoof() {
    roof = "rich";
    price += 1000;
  }

  @Override
  public void setFoundation() {
    foundation = "rich";
    price += 1000;
  }

  @Override
  public void setDoor(int door) {
    this.door = door;
    price += 220 * door;
  }

  @Override
  public House getHouse() {
    House house = new House(wall, door, window, price, foundation, roof);
    price = 0;
    return house;
  }
}
```
```java
package Creational.Builder.Example.BuilderDirector.Directors;

import Creational.Builder.Example.BuilderDirector.Builders.Builder;
import Creational.Builder.Example.BuilderDirector.Object.House;

// Can be abstract (Bridge realisation)
public class Director {

  private Builder builder;

  public Director(Builder builder) {
    this.builder = builder;
  }

  public void changeBuilder(Builder builder) {
    this.builder = builder;
  }

  public House getBigHousePrice() {
    builder.setFoundation();
    builder.setDoor(11);
    builder.setWall(20);
    builder.setWindow(15);
    builder.setRoof();

    return builder.getHouse();
  }

  //Can be in another director
  public House getSmallHousePrice() {
    builder.setFoundation();
    builder.setDoor(6);
    builder.setWall(10);
    builder.setWindow(5);
    builder.setRoof();

    return builder.getHouse();
  }
}
```
```java
package Creational.Builder.Example.BuilderDirector;

import Creational.Builder.Example.BuilderDirector.Builders.Builder;
import Creational.Builder.Example.BuilderDirector.Builders.CheepBuilder;
import Creational.Builder.Example.BuilderDirector.Builders.RichBuilder;
import Creational.Builder.Example.BuilderDirector.Directors.Director;

//We can create individual interface for each directors(Bridge) but y menya lapki
public class Ex {

  public static void main(String[] args) {
    Builder cheap = new CheepBuilder();
    Builder rich = new RichBuilder();

    Director director = new Director(cheap);
    System.out.println(director.getBigHousePrice().toString());
    System.out.println(director.getBigHousePrice().toString());

    System.out.println(director.getSmallHousePrice().toString());

    director.changeBuilder(rich);
    System.out.println(director.getBigHousePrice().toString());

    System.out.println(director.getSmallHousePrice().toString());

  }

}
```
```java
package Creational.Builder.Example.BuilderDirector.Object;

public class House {

  private final int wall;
  private final int door;
  private final int window;
  private final int price;
  private final String foundation;
  private final String roof;

  public House(int wall, int door, int window, int price, String foundation, String roof) {
    this.wall = wall;
    this.door = door;
    this.window = window;
    this.price = price;
    this.foundation = foundation;
    this.roof = roof;
  }

  public int getWall() {
    return wall;
  }

  public int getDoor() {
    return door;
  }

  public int getWindow() {
    return window;
  }

  public int getPrice() {
    return price;
  }

  public String getFoundation() {
    return foundation;
  }

  public String getRoof() {
    return roof;
  }

  @Override
  public String toString() {
    return "House{" +
      "wall=" + wall +
      ", door=" + door +
      ", window=" + window +
      ", price=" + price +
      ", foundation='" + foundation + '\'' +
      ", roof='" + roof + '\'' +
      '}';
  }
}
```
```java
package Creational.Builder.Example.Inner;

// https://habrahabr.ru/post/244521/

/*
 объект, получаемый из такого билдера,
 не потокобезопасен из-за того,
 что поля в нем не объявлены как final.
*/

/*
   Метод build билдера возвращает один и тот же объект
   и если после его вызова продолжить выставлять поля через методы билдера,
   поля уже созданного объекта будут меняться
*/
public class ElegantHouse {

  private String owner;
  private int doors;
  private int windows;
  private double cost;
  private boolean pool;
  private boolean garage;
  //...


  // Weeeeeeeeery bad if was public
  private ElegantHouse() {
  }

  //Getters

  public String getOwner() {
    return owner;
  }

  public int getDoors() {
    return doors;
  }

  public int getWindows() {
    return windows;
  }

  public double getCost() {
    return cost;
  }

  public boolean isPool() {
    return pool;
  }

  public boolean isGarage() {
    return garage;
  }

  public static Builder newBuilder() {
    return new ElegantHouse().new Builder();
  }

  //Our inner Builder
  class Builder {

    //if constructor was public
    //we can change parameters
    private Builder() {
    }

    //Setters

    public Builder setOwner(String owner) {
      ElegantHouse.this.owner = owner;
      return this;
    }

    public Builder setDoors(int doors) {
      ElegantHouse.this.doors = doors;
      return this;
    }

    public Builder setWindows(int windows) {
      ElegantHouse.this.windows = windows;
      return this;
    }

    public Builder setCost(double cost) {
      ElegantHouse.this.cost = cost;
      return this;
    }

    public Builder setPool(boolean pool) {
      ElegantHouse.this.pool = pool;
      return this;
    }

    public Builder setGarage(boolean garage) {
      ElegantHouse.this.garage = garage;
      return this;
    }

    /*
    Метод build билдера возвращает один и тот же объект
    и если после его вызова продолжить выставлять поля через методы билдера,
    поля уже созданного объекта будут меняться
    */
    public ElegantHouse build() {
      return ElegantHouse.this;
    }

    /*
    Если вы часто передаете билдер туда-сюда
    и переиспользуете его для повторной генерации объектов,
    Используйте:

    public ElegantHouse build(){
      ElegantHouse elegantHouse = new ElegantHouse();
      elegantHouse.owner = ElegantHouse.this.owner;
      elegantHouse.doors = ElegantHouse.this.doors;
      elegantHouse.cost = ElegantHouse.this.cost;
      elegantHouse.garage = ElegantHouse.this.garage;
      elegantHouse.pool = ElegantHouse.this.pool;
      elegantHouse.windows = ElegantHouse.this.windows;
      return elegantHouse;
    }
    */

  }
}
```
```java
package Creational.Builder.Example.Inner;

public class Ex {

  public static void main(String[] args) {

    //You can do like that, but this method have A LOT OF ISSUE

    ElegantHouse elegantHouse = ElegantHouse.newBuilder()
      .setCost(200)
      .setGarage(false)
      .setOwner("lol")
      .setWindows(3)
      .build();
  }

}
```
```java
package Creational.Builder.Example.StaticNested;

public class Ex {

  public static void main(String[] args) {
    FinalHouse house = new FinalHouse.Builder("Happy Family")
      .setCost(300)
      .setDoors(4)
      .setGarage(true)
      .setWindows(20)
      .build();

    //We also can use default parameters which in Builder
    FinalHouse house1 = new FinalHouse.Builder("Default Family").build();

  }

}
```
```java
package Creational.Builder.Example.StaticNested;

public class FinalHouse {

  //immutable
  private final String owner;
  private final int doors;
  private final int windows;
  private final double cost;
  private final boolean pool;
  private final boolean garage;
  //...


  // Weeeeeeeeery bad if was public
  private FinalHouse(String owner, int doors, int windows, double cost, boolean pool,
    boolean garage) {
    this.owner = owner;
    this.doors = doors;
    this.windows = windows;
    this.cost = cost;
    this.pool = pool;
    this.garage = garage;
  }
  //Getters

  public String getOwner() {
    return owner;
  }

  public int getDoors() {
    return doors;
  }

  public int getWindows() {
    return windows;
  }

  public double getCost() {
    return cost;
  }

  public boolean isPool() {
    return pool;
  }

  public boolean isGarage() {
    return garage;
  }


  //Our STATIC inner Builder
  static class Builder {

    private String owner;
    private int doors = 1;
    private int windows = 4;
    private double cost = 200;
    private boolean pool = false;
    private boolean garage = false;

    public Builder(String owner) {
      this.owner = owner;
    }

    //Setters

    public Builder setDoors(int doors) {
      this.doors = doors;
      return this;
    }

    public Builder setWindows(int windows) {
      this.windows = windows;
      return this;
    }

    public Builder setCost(double cost) {
      this.cost = cost;
      return this;
    }

    public Builder setPool(boolean pool) {
      this.pool = pool;
      return this;
    }

    public Builder setGarage(boolean garage) {
      this.garage = garage;
      return this;
    }

    public FinalHouse build() {
      return new FinalHouse(owner, doors, windows, cost, pool, garage);
    }
  }
}
```
# Абстрактная фабрика 

![UML](/src/AdditionalDocs/uml/Abstract_Factory.png)

Позволяет создавать **семейства связанных объектов**, не привязываясь к конкретным классам создаваемых объектов.(Через общий интерфейс фабрик)

## Применимость

 - Когда бизнес-логика программы должна работать с **разными видами связанных друг с другом продуктов**, не завися от конкретных классов продуктов.

   - Абстрактная фабрика скрывает от клиентского кода подробности того, как и какие конкретно объекты будут созданы. Но при этом клиентский код может работать со всеми типами создаваемых продуктов, так как их общий интерфейс был заранее определён.

 - Когда в программе **уже используется Фабричный метод**, но очередные изменения предполагают введение новых типов продуктов.

   - В хорошей программе, каждый класс отвечает только за одну вещь. **Если класс имеет слишком много фабричных методов**, они способны затуманить его основную функцию. Поэтому имеет смысл вынести всю логику создания продуктов в отдельную иерархию классов, применив абстрактную фабрику.

## Шаги реализации

1. Создайте таблицу соотношений типов продуктов к вариациям семейств продуктов.

2. Сведите все вариации продуктов к общим интерфейсам.

3. Определите **интерфейс абстрактной фабрики**. Он должен иметь **фабричные методы для создания каждого из типов продуктов**.

4. Создайте классы конкретных фабрик, реализовав интерфейс абстрактной фабрики. Этих классов должно быть столько же, сколько и вариаций семейств продуктов.

5. Измените код инициализации программы так, чтобы она создавала определённую фабрику и передавала её в клиентский код.

6. Замените в клиентском коде участки создания продуктов через конструктор вызовами соответствующих методов фабрики.

## Преимущества и недостатки

 | + | - |
 | ------ | ------ |
 |Гарантирует сочетаемость создаваемых продуктов.|Усложняет код программы за счёт **множества дополнительных классов**.
 |Избавляет клиентский код от привязки к конкретным классам продуктов.|Требует наличия всех типов продуктов в каждой вариации.
 |**Выделяет код производства продуктов** в одно место, упрощая поддержку кода.
 |Упрощает добавление новых продуктов в программу.
 |Реализует принцип [**Open/closed**][OCP].
 
 ## Отношения с другими паттернами
 
 - Многие архитектуры начинаются с применения [**Фабричного метода**][Factory_Method] (более простого и расширяемого через подклассы) и эволюционируют в сторону **Абстрактной фабрики**, [**Прототипа**][Prototype] или [**Строителя**][Builder] (более гибких, но и более сложных).
 
 - [**Строитель**][Builder] концентрируется на постройке сложных объектов шаг за шагом. **Абстрактная фабрика** специализируется на создании семейств связанных продуктов. [**Строитель**][Builder] возвращает продукт только после выполнения всех шагов, а **Абстрактная фабрика** возвращает продукт сразу же.
 
 - Классы **Абстрактной фабрики** чаще всего реализуются с помощью [**Фабричного метода**][Factory_Method], хотя они могут быть построены и на основе [**Прототипа**][Prototype].
 
- **Абстрактная фабрика** может быть использована вместо [**Фасада**][Facade] для того, чтобы скрыть платформо-зависимые классы.
 
 - **Абстрактная фабрика** может работать совместно с [**Мостом**][Bridge]. Это особенно полезно, если у вас есть абстракции, которые могут работать только с некоторыми из реализаций. В этом случае фабрика будет определять типы создаваемых абстракций и реализаций.
 
 - **Абстрактная фабрика**, [**Строитель**][Builder] и [**Прототип**][Prototype] могут быть реализованы при помощи [**Одиночки**][Singleton].
 
 
[OCP]: </src/AdditionalDocs/SOLID/Open-Closed_principle.md>
 
 
[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>

```java
package Creational.Factorys.Abstract_Factory.Example;

import Creational.Factorys.Abstract_Factory.Example.Factorys.ChicagoPizzaFactory;
import Creational.Factorys.Abstract_Factory.Example.Factorys.NYPizzaFactory;
import Creational.Factorys.Abstract_Factory.Example.Factorys.PizzaFactory;
import Creational.Factorys.Abstract_Factory.Example.Products.Pizzas.Margarita.Margarita;
import Creational.Factorys.Abstract_Factory.Example.Products.Pizzas.Neapolitan.Neapolitan;

public class Abstract_Factory {

  public static void main(String[] args) {
    PizzaFactory pizzaFactory = new ChicagoPizzaFactory();

    Margarita margarita = pizzaFactory.makeMargarita();
    Neapolitan neapolitan = pizzaFactory.makeNeapolitan();
    margarita.prepare();
    neapolitan.prepare();

    pizzaFactory = new NYPizzaFactory();

    margarita = pizzaFactory.makeMargarita();
    neapolitan = pizzaFactory.makeNeapolitan();
    margarita.prepare();
    neapolitan.prepare();


  }

}
```
```java
package Creational.Factorys.Abstract_Factory.Example.Factorys;

import Creational.Factorys.Abstract_Factory.Example.Products.Pizzas.Margarita.ChicagoMargarita;
import Creational.Factorys.Abstract_Factory.Example.Products.Pizzas.Margarita.Margarita;
import Creational.Factorys.Abstract_Factory.Example.Products.Pizzas.Neapolitan.ChicagoNeapolitan;
import Creational.Factorys.Abstract_Factory.Example.Products.Pizzas.Neapolitan.Neapolitan;

public class ChicagoPizzaFactory implements PizzaFactory {

  @Override
  public Neapolitan makeNeapolitan() {

    // Create new specific Neapolitan

    return new ChicagoNeapolitan();
  }

  @Override
  public Margarita makeMargarita() {

    // Create new specific Margarita

    return new ChicagoMargarita();
  }

}
```
```java
package Creational.Factorys.Abstract_Factory.Example.Factorys;

import Creational.Factorys.Abstract_Factory.Example.Products.Pizzas.Margarita.Margarita;
import Creational.Factorys.Abstract_Factory.Example.Products.Pizzas.Margarita.NYMargarita;
import Creational.Factorys.Abstract_Factory.Example.Products.Pizzas.Neapolitan.NYNeapolitan;
import Creational.Factorys.Abstract_Factory.Example.Products.Pizzas.Neapolitan.Neapolitan;

public class NYPizzaFactory implements PizzaFactory {

  @Override
  public Neapolitan makeNeapolitan() {

    // Create new specific Neapolitan

    return new NYNeapolitan();
  }

  @Override
  public Margarita makeMargarita() {

    // Create new specific Margarita

    return new NYMargarita();
  }
}
```
```java
package Creational.Factorys.Abstract_Factory.Example.Factorys;

import Creational.Factorys.Abstract_Factory.Example.Products.Pizzas.Margarita.Margarita;
import Creational.Factorys.Abstract_Factory.Example.Products.Pizzas.Neapolitan.Neapolitan;

public interface PizzaFactory {

  Neapolitan makeNeapolitan();

  Margarita makeMargarita();
}
```
```java
package Creational.Factorys.Abstract_Factory.Example.Products.Pizzas.Margarita;

public class ChicagoMargarita extends Margarita {

  public ChicagoMargarita() {
    name = "Chicago " + name;
  }
}
```
```java
package Creational.Factorys.Abstract_Factory.Example.Products.Pizzas.Margarita;

import Creational.Factorys.Abstract_Factory.Example.Products.Pizzas.Pizza;

public abstract class Margarita extends Pizza {

  protected Margarita() {
    name = "Chicago Margarita";
  }
}
```
```java
package Creational.Factorys.Abstract_Factory.Example.Products.Pizzas.Margarita;

public class NYMargarita extends Margarita {

  public NYMargarita() {
    name = "NY " + name;
  }
}
```
```java
package Creational.Factorys.Abstract_Factory.Example.Products.Pizzas.Neapolitan;

public class ChicagoNeapolitan extends Neapolitan {

  public ChicagoNeapolitan() {
    name = "Chicago " + name;
  }
}
```
```java
package Creational.Factorys.Abstract_Factory.Example.Products.Pizzas.Neapolitan;

import Creational.Factorys.Abstract_Factory.Example.Products.Pizzas.Pizza;

public abstract class Neapolitan extends Pizza {

  protected Neapolitan() {
    name = "Neapolitan";
  }
}
```
```java
package Creational.Factorys.Abstract_Factory.Example.Products.Pizzas.Neapolitan;

public class NYNeapolitan extends Neapolitan {

  public NYNeapolitan() {
    name = "NY" + name;
  }
}
```
```java
package Creational.Factorys.Abstract_Factory.Example.Products.Pizzas;

public abstract class Pizza {

  protected String name;

  // Some common operation for all products

  public void prepare() {
    System.out.println(name + " is Preparing");
  }

  public void bake() {
    System.out.println("Bake for 25 min");
  }

  public void cut() {
    System.out.println("Cutting the " + name);
  }

  public String getName() {
    return name;
  }
}
```
# 1. Фабрика
**Фабрика** - это **общая концепция проектирования функций, методов и классов**, когда какая-то одна часть программы отвечает за создание других частей программы.

Вы можете услышать слово Фабрика от других людей, когда они имеют в виду:

 - функцию или метод создающую все объекты программы;
 - класс, создающий пользователей системы;
 - статический метод, оборачивающий конструктор класса;
 - один из классических фабричных паттернов, приведённых ниже.

# 2. Создающий метод
**Создающий метод** - это простой метод-обёртка над вызовом конструктора продукта. Выделив создающий метод, вы изолируете любые изменения в конструировании продуктов от основного кода. Например, вы можете вовсе убрать вызов конструктора из создающего метода, отдавая вместо нового какой-то существующий объект.

Многие называют его фабричным методом, только потому, что он создаёт новые объекты. Типичная логика: *«этот метод создаёт объекты, а раз все фабрики создают что-то, значит этот метод - фабричный»*. И это вносит основную путаницу между понятием **Создающего метода** и паттерном **Фабричный метод**.

В этом примере, метод next является создающим методом:

```java
class Number {
    private String value;

    public Number(String value) {
        this.value = value;
    }

    public Number next() {
        return new Number (value + 1);
    }
}
```

# 3. Статический фабричный метод

**Статический фабричный метод** - **вариация создающего метода, объявленная как `static`**. Если этот метод создаёт объекты своего же класса, то, по сути, он выступает в роли альтернативного конструктора. Это может быть полезно, если:

  - **Требуется создать разные по функциональности конструкторы, у которых бы совпадали сигнатуры** (например, `Random(int max)` и `Random(int min)`). Это невозможно во многих языках программирования, но создав статический метод, вы можете обойти это ограничение.

  - **Хочется повторно использовать готовые объекты, вместо создания новых (например, паттерн Одиночка)**. При вызове конструктора вы всегда создаёте новый объект. Это можно обойти, если вынести вызов конструктора в новый метод. В этом методе вы можете сначала поискать готовый объект в каком-то кеше, и только если его нет, создать новый объект.

В следующем примере,**метод load является статическим фабричным методом** - он предоставляет удобный способ загрузить пользователя из базы данных.

```java
class User {
    private String name, email, phone;

    public User(String name, String email,String phone) {
        this.name = name;
        this.email = email;
        this.phone = phone;
    }

    public static User load(String name) {
      User user = DB.load_data(name);
      if (user == null) 
        user = new User(name, "email", "phone");
        return user;
    }
}
```

# 4. Паттерн Простая фабрика

**Паттерн Простая фабрика** - это класс, в котором есть **один метод с большим условным оператором**, выбирающим создаваемый продукт. Этот метод вызывают с неким параметром, по которому определяется какой из продуктов нужно создать. У простой фабрики, обычно, нет подклассов.

Обычно, простую фабрику путают с общим понятием **Фабрики** или с любым из **фабричных паттернов**.

Если объявить класс простой фабрики абстрактным (Java, C#), это не сделает его одним и тем же, что и абстрактная фабрика!

Вот пример простой фабрики:

```java
class UserFactory {
    public static function create(String type) {
        switch (type) {
           case "user": return new User();
           case "customer": return new Customer();
           case "admin": return new Admin();
            default:
                throw new Exception("Wrong user type passed.");
        }
    }
}
```

**Простая фабрика находится в шаге от того, чтобы стать Фабричным методом**.

# 5. Паттерн Фабричный метод
**Паттерн Фабричный метод** - **это устройство классов**, при котором подклассы могут переопределять тип создаваемого в суперклассе продукта.

**Если вы имеете иерархию продуктов и абстрактный создающий метод, который переопределяется в подклассах, то перед вами паттерн Фабричный метод**.

```java
class Department {
    public abstract Employee createEmployee(int id);

    public void fire(int id) {
        employee = this.createEmployee(id);
        employee.paySallary();
        employee.dismiss();
    }
}

class ITDepartment extends Department {
    @Override
    public Employee createEmployee(int id) {
        return new Programmer(id);
    }
}

class AccountingDepartment extends Department {
    @Override
    public Employee createEmployee(int id) {
        return new Accountant(id);
    }
}
```
# 6. Паттерн Абстрактная фабрика
**Паттерн Абстрактная фабрика** - **это устройство классов**, облегчающее создание семейств продуктов.

Что такое семейство продуктов? Например, классы Транспорт + Двигатель +  Управление. Вариациями этого семейства могут стать:

*Автомобиль + Двигатель Внутреннего Сгорания + Руль*

*Самолет + Реактивный Двигатель + Штурвал*

**Если у вас нет семейств продуктов, значит не может быть и абстрактной фабрики.**

Многие путают паттерн абстрактная фабрика с классом простой фабрики, объявленным как `abstract`, но это далеко не одно и то же!
```java
package Creational.Factorys.Factory_Method.Example.Factorys;

import Creational.Factorys.Factory_Method.Example.Products.Margarita;
import Creational.Factorys.Factory_Method.Example.Products.Pizza;

public class MargaritaFactory extends PizzaFactory {

  @Override
  protected Pizza makePizza() {
    return new Margarita();
  }
}
```
```java
package Creational.Factorys.Factory_Method.Example.Factorys;

import Creational.Factorys.Factory_Method.Example.Products.Neapolitan;
import Creational.Factorys.Factory_Method.Example.Products.Pizza;

public class NeapolitanFactory extends PizzaFactory {

  @Override
  protected Pizza makePizza() {
    return new Neapolitan();
  }
}
```
```java
package Creational.Factorys.Factory_Method.Example.Factorys;

import Creational.Factorys.Factory_Method.Example.Products.Pizza;

public abstract class PizzaFactory {

  public Pizza orderPizza() {
    Pizza pizza;

    pizza = makePizza();

    //Working with product
    pizza.prepare();
    pizza.bake();
    pizza.cut();

    return pizza;
  }

  //Create pizza
  protected abstract Pizza makePizza();

}
```
```java
package Creational.Factorys.Factory_Method.Example;

import Creational.Factorys.Factory_Method.Example.Factorys.MargaritaFactory;
import Creational.Factorys.Factory_Method.Example.Factorys.PizzaFactory;
import Creational.Factorys.Factory_Method.Example.Products.Pizza;

public class Factory_Method {

  public static void main(String[] args) {

  /*
  We only need change one line
  Or we can do static create method
  But we create problem with inheritance and tests
  */

    PizzaFactory pizzaFactory = new MargaritaFactory();

    //do work

    Pizza pizza = pizzaFactory.orderPizza();

    //do work

    Pizza pizza2 = pizzaFactory.orderPizza();
    Pizza pizza3 = pizzaFactory.orderPizza();

  }
}
```
```java
package Creational.Factorys.Factory_Method.Example.Products;

public class Margarita extends Pizza {

  public Margarita() {
    name = "Margarita";
  }
}
```
```java
package Creational.Factorys.Factory_Method.Example.Products;

public class Neapolitan extends Pizza {

  public Neapolitan() {
    name = "Neapolitan";
  }
}
```
```java
package Creational.Factorys.Factory_Method.Example.Products;

public abstract class Pizza {

  String name;

  // Some common operation for all products

  public void prepare() {
    System.out.println(name + " is Preparing");
  }

  public void bake() {
    System.out.println("Bake for 25 min");
  }

  public void cut() {
    System.out.println("Cutting the " + name);
  }

  public String getName() {
    return name;
  }
}
```
 # Фабричный метод
 
 ![UML](/src/AdditionalDocs/uml/Factory_Method.png)
 
**Фабричный метод** - определяет общий интерфейс для создания объектов в суперклассе, позволяя **подклассам изменять тип создаваемых объектов**.

 ## Применимость
 
 - Когда **заранее неизвестны типы и зависимости объектов**, с которыми должен работать ваш код.

   - Фабричный метод **отделяет код производства продуктов** от остального кода, который эти продукты использует.

     Благодаря этому, код производства **можно расширять, не трогая основной код**. Так, чтобы добавить поддержку нового продукта, вам нужно создать новый подкласс и определить в нём фабричный метод, возвращая оттуда экземпляр нового продукта.

 - Когда вы хотите дать возможность пользователям **расширять части вашего фреймворка или библиотеки**.

   - Пользователи могут расширять классы вашего фреймворка через **наследование**. Но как сделать так, чтобы фреймворк создавал объекты из этих новых классов, а не из стандартных?

     Решением будет дать пользователям возможность **расширять не только желаемые компоненты, но и классы, которые создают эти компоненты**. А для этого создающие классы должны иметь конкретные создающие методы, которые можно определить.

     Например, вы используете готовый UI фреймворк для своего приложения. Но вот беда, требуется иметь круглые кнопки, вместо стандартных прямоугольных. Вы создаёте класс RoundButton. Но как сказать главному классу фреймворка (UIFramework), чтобы он теперь создавал круглые кнопки, вместо стандартных.

     Для этого вы создаёте подкласс UIWithRoundButtons из базового класса фреймворка, переопределяете в нём метод создания кнопки (createButton) и вписываете туда создание своего класса кнопок. Затем, используете  UIWithRoundButtons вместо стандартного UIFramework.

 - Когда вы хотите экономить системные ресурсы, повторно **используя уже созданные объекты, вместо создания новых**.

   - Такая проблема обычно возникает при работе с тяжёлыми ресурсоёмкими объектами, такими как подключение к базе данных, файловой системе и т.д.

Представьте, сколько действий вам нужно совершить, чтобы повторно использовать существующие объекты:

 1. Сперва вам следует создать общее хранилище, чтобы хранить вы нём все создаваемые объекты.
 2. При запросе нового объекта, нужно будет заглянуть в хранилище и проверить, есть ли там неиспользуемый объект.
 3. А затем вернуть его клиентскому коду.
 4. Но если свободных объектов нет - создать новый, не забыв добавить его в хранилище.
 
**Весь этот код нужно куда-то поместить, чтобы не засорять клиентский код.**

 ## Шаги реализации

1. Приведите все создаваемые продукты к **общему интерфейсу**.

2. В классе, который производит продукты, создайте **пустой фабричный метод**. В качестве возвращаемого типа укажите общий интерфейс продукта.

3. Затем, пройдитесь по коду класса и найдите все участки, **создающие продукты**. Поочерёдно **замените эти участки вызовами фабричного метода**, перенося в него код создания различных продуктов.

   В фабричный метод, возможно, придётся добавить несколько параметров, контролирующих какой из продуктов нужно создать.

4. Для каждого типа продуктов заведите подкласс и **переопределите в нём фабричный метод**. Переместите туда код создания соответствующего продукта из суперкласса.

4. Если создаваемых продуктов слишком много для существующих подклассов создателя, вы можете подумать о введении параметров в фабричный метод, которые позволят возвращать различные продукты в пределах одного подкласса.
(**объединить по смыслу продукты в 1 фабрику**)

*Например, у вас есть класс Почта с подклассами АвиаПочта и НаземнаяПочта, а также классы продуктов Самолёт, Грузовик и Поезд. Авиа соответствует  Самолётам, но для НаземнойПочты есть сразу два продукта. Вы могли бы создать новый подкласс почты для поездов, но проблему можно решить и по-другому. Клиентский код может передавать в фабричный метод НаземнойПочты аргумент, контролирующий какой из продуктов будет создан.*

5. Если после всех перемещений **фабричный метод стал пустым**, можете сделать его **абстрактным**. Если в нём что-то осталось - это будет его реализацией по умолчанию.

 ## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |Избавляет класс от привязки к конкретным классам продуктов.|Может привести к созданию **больших параллельных иерархий классов**, так как для каждого класса продукта надо создать свой подкласс создателя.
 |**Выделяет код производства продуктов** в одно место, упрощая поддержку кода.
 |Упрощает добавление новых продуктов в программу.
 |Реализует принцип [**открытости/закрытости**][OCP].

 ## Отношения с другими паттернами

 - Многие архитектуры начинаются с применения **Фабричного метода** (более простого и расширяемого через подклассы) и эволюционируют в сторону [**Абстрактной фабрики**][Abstract_Factory], [**Прототипа**][Prototype] или [**Строителя**][Builder] (более гибких, но и более сложных).

 - Классы [**Абстрактной фабрики**][Abstract_Factory] чаще всего реализуются с помощью **Фабричного метода**, хотя они могут быть построены и на основе [**Прототипа**][Prototype].

 - **Фабричный метод** можно использовать вместе с [**Итератором**][Iterator], чтобы подклассы коллекций могли создавать подходящие им итераторы.

 - [**Прототип**][Prototype] не опирается на наследование, но ему нужна сложная операция инициализации. **Фабричный метод** наоборот, построен на наследовании, но не требует сложной инициализации.

 - **Фабричный метод** можно рассматривать как частный случай [**Шаблонного метода**][Template_Method]. Кроме того, **Фабричный метод** нередко бывает частью большого класса с [**Шаблонными методами**][Template_Method].

[OCP]: </src/AdditionalDocs/SOLID/Open-Closed_principle.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
```java
package Creational.Object_Pool.Example.Ex1;

import Creational.Object_Pool.Example.Ex1.Obj.ExpensiveResource;
import Creational.Object_Pool.Example.Ex1.ObjectPools.ExpensiveResourcePool;

/*
Possible improvements
 - add variable pool size – increase to max size when needed;
 - add mechanism to clean the pool to min when the pool is idle;
 - clean the memory on shutdown;
 - keep the used objects in a separate container – in case that accidentally are not return the pool to be clean after a specific period of time. This will avoid the pool to be blocked;
 - keep alive mechanism – in case that objects need to be kept in a specific state. e.g. if the pooled objects are database connections to check from time to time if the connection is still open.
 - validation/clean mechanism for objects that become invalid.
*/

public class Ex {

  public static void main(String[] args) {
    ExpensiveResourcePool pool = new ExpensiveResourcePool();
    ExpensiveResource obj1 = pool.getObj();
    ExpensiveResource obj2 = pool.getObj();
    ExpensiveResource obj3 = pool.getObj();
    System.out.println(pool);
    pool.release(obj1);
    pool.release(obj2);
    System.out.println(pool);
    pool.getObj();
    System.out.println(pool);
  }
}
```
```java
package Creational.Object_Pool.Example.Ex1.Obj;

public class ExpensiveResource {

  private String name;

  public ExpensiveResource(String name) {
    this.name = name;
    try {
      Thread.sleep(1000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }

  public void doSomething() {
    System.out.println("I am resource " + this.name + ".");
  }
}
```
```java
package Creational.Object_Pool.Example.Ex1.ObjectPools;

import Creational.Object_Pool.Example.Ex1.Obj.ExpensiveResource;

public class ExpensiveResourcePool extends ObjectPool<ExpensiveResource> {

  static int i = 0;

  @Override
  protected ExpensiveResource create() {
    i++;
    return new ExpensiveResource(String.valueOf(i));
  }
}
```
```java
package Creational.Object_Pool.Example.Ex1.ObjectPools;

import java.util.HashSet;
import java.util.Set;

public abstract class ObjectPool<T> {

  private Set<T> available = new HashSet<>();
  private Set<T> unavailable = new HashSet<>();

  protected abstract T create();

  /*
   * Checkout object from pool
   */
  public synchronized T getObj() {
    if (available.isEmpty()) {
      available.add(create());
    }
    T inst = available.iterator().next();
    available.remove(inst);
    unavailable.add(inst);
    return inst;
  }

  public synchronized void release(T inst) {
    available.add(inst);
    unavailable.remove(inst);
  }

  @Override
  public String toString() {
    return "Pool available = " + available.size() +
      "\n unavailable = " + unavailable.size();
  }
}
```
```java
package Creational.Object_Pool.Example.Ex2;

/*
Possible improvements
 - add variable pool size – increase to max size when needed;
 - add mechanism to clean the pool to min when the pool is idle;
 - clean the memory on shutdown;
 - keep the used objects in a separate container – in case that accidentally are not return the pool to be clean after a specific period of time. This will avoid the pool to be blocked;
 - keep alive mechanism – in case that objects need to be kept in a specific state. e.g. if the pooled objects are database connections to check from time to time if the connection is still open.
 - validation/clean mechanism for objects that become invalid.
*/

import Creational.Object_Pool.Example.Ex2.Obj.ExpensiveResource;
import Creational.Object_Pool.Example.Ex2.ObjectPool.ExpensiveResourcePool;

public class Ex {

  public static void main(String[] args) {
    final ExpensiveResourcePool pool = new ExpensiveResourcePool(3);

    System.out.println("Simple usage");
    System.out.println();
    System.out.println("Pool size:" + pool.size());

    /* simple usage - get the object */
    ExpensiveResource obj0 = pool.get();
    /* simple usage - use the object */
    obj0.doSomething();

    /* to check that the object was removed from the pool */
    System.out.println("Pool size:" + pool.size());

    /* simple usage - return the object */
    pool.release(obj0);

    System.out.println();
    System.out.println("extended usage");
    System.out.println();

    ExpensiveResource obj1 = pool.get();
    ExpensiveResource obj2 = pool.get();
    ExpensiveResource obj3 = pool.get();

    /* to check that the object was removed from the pool */
    System.out.println("Pool size:" + pool.size());
    obj1.doSomething();
    obj2.doSomething();
    obj3.doSomething();

    /* create a new thread to simulate the long operation for obj1 - this will avoid blocking the test app */
    Runnable exec = () -> {
      try {
        Thread.sleep(5 * 1000);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
      pool.release(obj1);
    };
    Thread thread = new Thread(exec);
    thread.start();

    /* will wait until the thread will finish and will return the object to the pool - 5 sec
     * will be the same object as for obj1.
     */
    System.out.println("Pool size:" + pool.size());
    ExpensiveResource obj4 = pool.get();
    obj4.doSomething();

    /*return all objects to the pool */
    pool.release(obj4);
    pool.release(obj2);
    pool.release(obj3);

    /* check the pool size */
    System.out.println("Pool size:" + pool.size());

    /* shutdown the pool*/
    pool.shutdown();

    /* check the pool size */
    System.out.println("Pool size:" + pool.size());
  }

}
```
```java
package Creational.Object_Pool.Example.Ex2.Obj;

public class ExpensiveResource {

  private String name;

  public ExpensiveResource(String name) {
    this.name = name;
    try {
      Thread.sleep(1000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }

  public void doSomething() {
    System.out.println("I am resource " + this.name + ".");
  }
}
```
```java
package Creational.Object_Pool.Example.Ex2.ObjectPool;

import Creational.Object_Pool.Example.Ex2.Obj.ExpensiveResource;
import java.util.UUID;

public class ExpensiveResourcePool extends ObjectPool<ExpensiveResource> {

  public ExpensiveResourcePool(int size) {
    super(size);
  }

  @Override
  public ExpensiveResource createNew() {
    //return an object with random name
    return new ExpensiveResource(UUID.randomUUID().toString());
  }
}
```
```java
package Creational.Object_Pool.Example.Ex2.ObjectPool;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public abstract class ObjectPool<T> implements Pool<T>, ObjFactory<T> {

  private int size;

  private boolean shutdown;

  private BlockingQueue<T> objects;

  public ObjectPool(int size) {
    this.size = size;
    shutdown = false;
    init();
  }

  /*
   * initiate the pool with fix size
   */
  private void init() {
    objects = new LinkedBlockingQueue<>();
    for (int i = 0; i < size; i++) {
      objects.add(createNew());
    }
  }

  @Override
  public T get() {
    if (!shutdown) {
      T t = null;

      try {
        t = objects.take();
      } catch (Exception e) {
        e.printStackTrace();
      }
      return t;
    }
    throw new IllegalStateException("Object pool is already shutdown.");
  }

  @Override
  public void release(T t) {
    try {
      objects.offer(t);
    } catch (Exception e) {
      e.printStackTrace();
    }
  }

  //For simplicity of this example I only remove the objects from the pool.
  //In real life you might need to release the memory too. e.g.
  //if is a database connection pool, you need to close the connection before remove the object from the pool.
  @Override
  public void shutdown() {
    objects.clear();
  }

  public int size() {
    return objects.size();
  }

}

```
```java
package Creational.Object_Pool.Example.Ex2.ObjectPool;

public interface ObjFactory<T> {

  /**
   * Returns a new instance of an object type T.
   *
   * @return T an new instance of the object type T
   */
  T createNew();
}
```
```java
package Creational.Object_Pool.Example.Ex2.ObjectPool;

public interface Pool<T> {

  /*
   * @return one of the pooled objects.
   */
  T get();

  /*
   * @param object T to be return back to pool
   */
  void release(T object);

  /*
   * Shuts down the pool. Should release all resources.
   */
  void shutdown();
}
```
# Объектный пул

![UML](/src/AdditionalDocs/uml/ObjectPool.png)

Набор инициализированных и **готовых к использованию объектов**. Когда системе требуется объект, он не создаётся, а берётся из пула. Когда объект больше не нужен, он не уничтожается, а возвращается в пул.

**!!!**

*Не рекомендуется использовать объединение объектов с определенными языками, такими как **Java**, особенно для объектов, которые используют только память и не имеют внешних ресурсов. Распределение объектов относительно **быстро на современных языках со сборщиками мусора**; Большинство сборщиков мусора сканируют «живые» ссылки на объекты, а не память, которую эти объекты используют для своего контента. Это означает, что любое количество «мертвых» объектов без ссылок может быть отброшено с минимальными затратами. Напротив, **сохранение большого количества «живых», но неиспользуемых объектов увеличивает продолжительность сбора мусора.***

**!!!**

Java supports thread pooling via java.util.concurrent.ExecutorService and other related classes.

## Применимость

- Когда **создание объекта в начале работы и уничтожение его в конце приводит к большим затратам**.
 
  - Особенно заметно повышение производительности, когда объекты **часто создаются-уничтожаются, но одновременно существует лишь небольшое их число**.
  
- Когда есть нескольким клиентам нужен **один и тот же ресурс в разное время**.

## Шаги реализации

1. Создайте класс `ObjectPool` с `private` массивом объектов внутри;

2. Создайте `acquire и release` методы в классе `ObjectPool`;

3. Убедитесь, что ваш **ObjectPool** - [**Singleton**][Singleton]

## Преимущества и недостатки

 | + | - |
 | ------ | ------ |
|Повышает производительность приложения| **JAVA использует сборщик мусора**|
|управляет соединениями и обеспечивает способ повторного использования и обмена ими|Существуют ["ловушки"](https://en.wikipedia.org/wiki/Object_pool_pattern) при использовании таких объектов|
|Может предоставить ограничение для максимального количества объектов, которые могут быть созданы|

## Отношения с другими паттернами

- [**Фабричный метод**][Factory_method] может использоваться для инкапсуляции логики создания объектов. Однако после их создания он не управляет ими,  **Пул объектов** отслеживает созданные им объекты.
 
- Пулы объектов обычно реализуются как [**Singleton**][Singleton].

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Object_Pool]: </src/Creational/Object_Pool/Object_Pool.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
```java
package Creational.Prototype.Example.CopyConstructor;

public class Ex {

  public static void main(String[] args) {
    User u1 = new User("u1", 20);

    User u2 = new User(u1);

    //Static Factory
    User u3 = User.getInstance(u1);
  }

}
```
```java
package Creational.Prototype.Example.CopyConstructor;

//About initialization fields take care developer of the class

public class User {

  private String name;
  private int age;

  public User(String name, int age) {
    this.name = name;
    this.age = age;
  }

  // Copy constructor 
  public User(User nUser) {
    this(nUser.getName(), nUser.getAge());
  }

  // Another variant
  public static User getInstance(User nUser) {
    return new User(nUser.getName(), nUser.getAge());
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }

}
```
```java
package Creational.Prototype.Example.Serialization;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

public class Ex {

  public static void main(String[] args) throws IOException, ClassNotFoundException {
    User u1 = new User("u1", 23);

    //Create a thread chain with an object output stream at the end
    ObjectOutputStream ous = new ObjectOutputStream(new FileOutputStream("test1.dat"));
    ous.writeObject(u1);
    System.out.println(u1);
    ous.close();

    //Objects are read in the same order in which they were written to the file
    ObjectInputStream ois = new ObjectInputStream(new FileInputStream("test1.dat"));
    User clone = (User) ois.readObject();
    System.out.println(clone);
    ois.close();
  }
}
```
```java
package Creational.Prototype.Example.Serialization;

import java.io.Serializable;

public class User implements Serializable {

  private String name;
  private int age;

  public User(String name, int age) {
    this.name = name;
    this.age = age;
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }

  @Override
  public String toString() {
    return "User{" +
      "name='" + name + '\'' +
      ", age=" + age +
      '}';
  }
}
```
```java
package Creational.Prototype.Example.WithJDK;

import java.util.GregorianCalendar;

public class Ex {

  public static void main(String[] args) {
    User u1 = new User("u1", 23);
    User u2 = null;
    u1.setCalendar(new GregorianCalendar(1999, 2, 2));
    System.out.println(u1.toString());

    try {
      u2 = (User) u1.clone();
      //Different objects bc Calendar impl Cloneable
      u2.setAge(222);
      u2.setCalendar(new GregorianCalendar(1, 1, 1));
    } catch (CloneNotSupportedException e) {
      e.printStackTrace();
    }

    System.out.println("U1 ==  " + u1.toString());

    System.out.println("U2 ==  " + u2.toString());
  }
}
```
```java
package Creational.Prototype.Example.WithJDK;

import java.util.Calendar;

//Have problem in use
public class User implements Cloneable {

  private String name;
  private int age;

  //For nested (deep clone)
  //All nested classes need to implements Cloneable
  private Calendar calendar;


  public User(String name, int age) {
    //Some heavy operation (to DataBase ...)
    this.name = name;
    this.age = age;
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }

  public void setAge(int age) {
    this.age = age;
  }

  public Calendar getCalendar() {
    return calendar;
  }

  public void setCalendar(Calendar calendar) {
    this.calendar = calendar;
  }

  @Override
  protected Object clone() throws CloneNotSupportedException {
    return super.clone();
  }

  @Override
  public String toString() {
    return "User{" +
      "name='" + name + '\'' +
      ", age=" + age +
      ", calendar=" + calendar.getTime() +
      '}';
  }
}
```
# Прототип

![UML](/src/AdditionalDocs/uml/Prototype.png)

Позволяет создавать новые объекты на основе некоторого объекта-прототипа.

## Применимость
 
 - Когда ваш **код не должен зависеть от классов копируемых объектов**.

   - Такое часто бывает, если ваш код работает с объектами, поданными извне через какой-то общий интерфейс. Вы не можете привязаться к их классам, даже если бы хотели, так как их конкретные классы неизвестны.

     Паттерн **Прототип** предоставляет клиенту общий интерфейс для работы со всеми прототипами. Клиенту **не нужно зависеть от всех классов копируемых объектов, а только от интерфейса клонирования**.

 - Когда вы имеете уйму подклассов, которые отличаются начальными значениями полей. Кто-то создал эти классы, чтобы быстро создавать объекты с определённой конфигурацией.

   - **Прототип** предлагает использовать набор прототипов, вместо создания подклассов для популярных конфигураций объектов.

    Таким образом, вместо порождения объектов из подклассов, вы будете копировать существующие объекты-прототипы, в которых уже настроено внутреннее состояние. Это позволит избежать взрывного роста количества классов в программе и уменьшить её сложность.

## Шаги реализации
!!!

(Поверхностное копирование)
- [Конструктор копирования][Ex1]

(Глубокое копирование)
- [Cloneable][Ex2]
- [Serialization][Ex3]

!!!

1. Создайте **интерфейс прототипов с единственным методом clone (Cloneable)**. Если у вас уже есть иерархия продуктов, метод клонирования можно объявить непосредственно в каждом из её классов.

2. Добавьте **в классы будущих прототипов альтернативный конструктор, принимающий в качестве аргумента объект текущего класса**. Этот конструктор должен скопировать из поданного объекта значения всех полей, объявленных в рамках текущего класса, а затем передать выполнение родительскому конструктору, чтобы тот позаботился об остальных полях.

   Если ваш язык программирования не поддерживает перегрузку методов, то копирование значений можно проводить и в другом методе, специально созданном для этих целей. Конструктор удобнее тем, что позволяет клонировать объект за один вызов.

3. **Метод клонирования обычно состоит всего из одной строки: вызова оператора new с конструктором прототипа. Все классы, поддерживающие клонирование, должны явно определить метод clone, чтобы подать собственный класс в оператор new. В обратном случае, результатом клонирования окажется объект родительского класса**.

4. Опционально, создайте **центральное хранилище прототипов**. В нём можно хранить вариации объектов, возможно даже одного класса, но по-разному настроенных.

   Вы можете разместить это хранилище либо в новом фабричном классе, либо в фабричном методе базового класса прототипов. Такой фабричный метод должен на основании входящих аргументов искать в каталоге прототипов подходящий экземпляр, а затем вызывать его метод клонирования и возвращать полученный объект.

    Наконец, нужно будет избавиться от прямых вызовов конструкторов объектов, заменив их вызовами фабричного метода хранилища прототипов.

 ## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |Позволяет клонировать объекты, не привязываясь к их конкретным классам.|Сложно клонировать составные объекты, имеющие ссылки на другие объекты.
 |Меньше повторяющегося кода инициализации объектов.
 |Ускоряет создание объектов.
 |Альтернатива созданию подклассов для конструирования сложных объектов.
 
## Отношения с другими паттернами

- Многие архитектуры начинаются с применения [**Фабричного метода**][Factory_method] (более простого и расширяемого через подклассы) и эволюционируют в сторону [**Абстрактной фабрики**][Abstract_Factory], **Прототипа** или [**Строителя**][Builder] (более гибких, но и более сложных).

- Классы [**Абстрактной фабрики**][Abstract_Factory] чаще всего реализуются с помощью [**Фабричного метода**][Factory_method], хотя они могут быть построены и на основе **Прототипа**.

- Если [**Команду**][Command] нужно копировать перед вставкой в историю выполненных команд, вам может помочь **Прототип**.

- Архитектура, построенная на [**Компоновщиках**][Composite] и [**Декораторах**][Decorator], часто может быть улучшена за счёт внедрения **Прототипа**. Он позволяет клонировать сложные структуры объектов, а не собирать их заново.

- **Прототип** не опирается на наследование, но ему нужна сложная операция инициализации. [**Фабричный метод**][Factory_method] наоборот, построен на наследовании, но не требует сложной инициализации.

- [**Снимок**][Memento] иногда можно заменить **Прототипом**, если объект, чьё состояние требуется сохранять в истории, довольно простой, не имеет активных ссылок на внешние ресурсы, либо их можно легко восстановить.

- [**Абстрактной фабрика**][Abstract_Factory], [**Строитель**][Builder] и **Прототип** могут быть реализованы при помощи [**Одиночки**][Singleton]. 

[Ex1]: </src/Creational/Prototype/Example/CopyConstructor/>
[Ex2]: </src/Creational/Prototype/Example/WithJDK/>
[Ex3]: </src/Creational/Prototype/Example/Serialization/>

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
```java
package Creational.Singleton.Example.Pre_creation;

//Thread save
public class Server {

  //Not Lazy loading

  private static Server ourInstance = new Server();

  public static Server getInstance() {
    return ourInstance;
  }

  private Server() {
  }
}
```
```java
package Creational.Singleton.Example.Simple;

//Not Thread save
public class Server {

  //Lazy loading

  private static Server server;

  public static Server getInstance() {
    if (server == null) {
      server = new Server();
    }
    return server;
  }

  private Server() {
  }
}
```
```java
package Creational.Singleton.Example.ThreadSync;

//Thread save
public class Server {

  //JDK 5
  //Lazy loading

  private static volatile Server ourInstance;

  /*
  Or we can do only
  public static synchronized getInstance()
  but this have performance issue
  (we need synchronized only 1 time, not every getInstance())
  */
  public static Server getInstance() {
    if (ourInstance == null) {
      synchronized (Server.class) {
        if (ourInstance == null) {
          ourInstance = new Server();
        }
      }
    }
    return ourInstance;
  }

  private Server() {
  }
}
```
# Одиночка

![UML](/src/AdditionalDocs/uml/Singleton.png)

Гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

**Одиночка** решает сразу две проблемы **(нарушая принцип единственной ответственности класса)**.

## Применимость
  - Когда в программе **должен быть единственный экземпляр** какого-то класса, доступный всем клиентам (например, общий доступ к базе данных из разных частей программы).

    - Одиночка **скрывает от клиентов все способы создания нового объекта**, кроме специального метода. Этот метод либо создаёт объект, либо отдаёт существующий объект, если он уже был создан.

  - Когда вам хочется иметь больше контроля над глобальными переменными.

    - В отличие от глобальных переменных, **Одиночка** гарантирует, что никакой другой код не заменит созданный экземпляр класса, поэтому вы всегда уверены в наличие лишь одного объекта-одиночки.

      Тем не менее, в любой момент вы можете расширить это ограничение и позволить любое количество объектов-одиночек, поменяв код в одном месте (метод `getInstance()`).

 ## Шаги реализации
1. Добавьте в класс **приватное статическое поле** (+ `volatile` ), которое будет содержать одиночный объект.

2. Объявите **статический создающий метод**(+ `synchronized` ), который будет использоваться для получения одиночки.

3. Добавьте **«ленивую инициализацию»** (создание объекта при первом вызове метода) в создающий метод одиночки.

4. Сделайте **конструктор класса приватным**.

5. В клиентском коде замените вызовы конструктора вызовами создающего метода.

 ## Преимущества и недостатки
 | + | - |
 | ------ | ------ |
 |Гарантирует наличие единственного экземпляра класса. |Нарушает принцип единственной ответственности класса.
 |Предоставляет к нему глобальную точку доступа. |Маскирует плохой дизайн.
 |Реализует отложенную инициализацию объекта-одиночки. |Проблемы мультипоточности.
 | |Требует постоянного создания Mock-объектов при юнит-тестирования.


 
 ## Отношения с другими паттернами

- [**Фасад**][Facade] можно сделать **Одиночкой**, так как обычно нужен только один объект-фасад.

- Паттерн [**Легковес**][Flyweight] может напоминать **Одиночку**, если для конкретной задачи у вас получилось уменьшить количество объектов к одному. Но помните, что между паттернами есть два кардинальных отличия:

    1. В отличие от **Одиночки**, вы можете иметь множество объектов-легковесов.
    2. Объекты-легковесов должны быть неизменяемыми, тогда как объект-одиночки допускает изменение своего состояния.
 
- [**Абстрактная фабрика**][Abstract_Factory], [**Строитель**][Builder] и [**Прототип**][Prototype] могут быть реализованы при помощи **Одиночки**.


[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
```java
import java.io.IOException;
import java.nio.file.DirectoryStream.Filter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;

public class Solution {

  public static void main(String[] args) {
    Path mainFile = Paths.get("main.md");
    Path rootDir = Paths.get(System.getProperty("user.dir") + "//src");
    Path readme = Paths.get(System.getProperty("user.dir") + "//README.md");

    init(mainFile,readme);
    dirWalk(rootDir, mainFile);

  }

  static void dirWalk(Path rootDir, Path mainFile) {
    Filter<Path> filter = entry -> {
      if (Files.isDirectory(entry)) {
        dirWalk(entry, mainFile);
        return false;
      } else {
        return Files.isDirectory(entry) || entry.toString().endsWith(".md") || entry.toString().endsWith("java");
      }
    };

    try {
      Files.newDirectoryStream(rootDir, filter).forEach(x -> writeToFile(mainFile, x));
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  static void writeToFile(Path copyTo, Path copyFrom) {
    try {
      if (copyFrom.toString().endsWith(".java")) {
        Files.write(copyTo, "```java\n".getBytes(), StandardOpenOption.APPEND);
        Files.write(copyTo, Files.readAllLines(copyFrom), StandardOpenOption.APPEND);
        Files.write(copyTo, "```\n".getBytes(), StandardOpenOption.APPEND);
      }else
        Files.write(copyTo, Files.readAllLines(copyFrom), StandardOpenOption.APPEND);
    } catch (IOException e) {
      e.printStackTrace();
    }

  }

  static void init(Path mainFile ,Path readme) {
    try {
      Files.deleteIfExists(mainFile);
      Files.copy(readme,mainFile);
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

}

```
# Адаптер

![UML](/src/AdditionalDocs/uml/Adapter.png)

**Преобразует интерфейс класса к другому интерфейсу**, на который рассчитан клиент. Обеспечивает совместную работу классов, невозможную в обычных условиях из-за несовместимости интерфейсов.

## Применимость

 - Когда вы хотите использовать сторонний класс, но его **интерфейс не соответствует остальному коду приложения**.

   - Адаптер позволяет создать объект-прокладку, который будет превращать вызовы приложения в формат, понятный стороннему классу.

 - Когда вам нужно использовать несколько существующих подклассов, но в них **не хватает какой-то общей функциональности**. Причём **расширять суперкласс вы не можете** (Похоже на [**Декоратор**][Decorator]).

   - Вы могли бы создать ещё один уровень подклассов, и добавить в них недостающую функциональность. Но при этом *придётся дублировать один и тот же код в обеих ветках подклассов*.

     Более элегантное решение - **поместить недостающую функциональность в адаптер и приспособить его для работы с суперклассом**. Такой адаптер сможет работать со всеми подклассами иерархии. Это решение будет сильно напоминать паттерн [**Посетитель**][Visitor].

 ## Шаги реализации

1. Убедитесь, что у вас есть **два класса с неудобными интерфейсами**:

   - *полезный сервис* - служебный класс, который вы не можете изменять (он либо сторонний, либо от него зависит другой код);
 
   - *один или несколько клиентов* - классов приложения, несовместимых с сервисом из-за неудобного или несовпадающего интерфейса.

2. Опишите клиентский интерфейс, через который классы приложения смогли бы использовать сторонний класс.

3. Создайте класс адаптера, реализовав этот интерфейс.

4. **Поместите в адаптер поле-ссылку на объект-сервис**. В большинстве случаев, это поле заполняется объектом, переданным в конструктор адаптера. В случае простой адаптации этот объект можно передавать через параметры методов адаптера.

5. Реализуйте все методы клиентского интерфейса в адаптере. **Адаптер должен делегировать основную работу сервису**.

6. Приложение должно использовать адаптер только через клиентский интерфейс. Это позволит легко изменять и добавлять адаптеры в будущем.

## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |Отделяет и скрывает от клиента подробности преобразования различных интерфейсов.|Усложняет код программы за счёт дополнительных классов.
 
## Отношения с другими паттернами
 
 - [**Мост**][Bridge] проектируют загодя, чтобы развивать большие части приложения отдельно друг от друга. **Адаптер** применяется постфактум, чтобы заставить несовместимые классы работать вместе.

 - **Адаптер** меняет интерфейс существующего объекта. [**Декоратор**][Decorator] улучшает другой объект без изменения его интерфейса. Причём [**Декоратор**][Decorator] поддерживает рекурсивную вложенность, чего не скажешь об **Адаптере**.

 - **Адаптер** предоставляет классу альтернативный интерфейс. [**Декоратор**][Decorator] предоставляет расширенный интерфейс. [**Заместитель**][Proxy] предоставляет тот же интерфейс.

 - [**Фасад**][Facade] задаёт новый интерфейс, тогда как **Адаптер** повторно использует старый. **Адаптер** оборачивает только один класс, а [**Фасад**][Facade] оборачивает целую подсистему. Кроме того, **Адаптер** позволяет двум существующим интерфейсам работать сообща, вместо того, чтобы задать полностью новый.

 - [**Мост**][Bridge], [**Стратегия**][Strategy] и [**Состояние**][State] (а также слегка и **Адаптер**) имеют схожие структуры классов - все они построены на принципе [**«композиции»**][Composition], то есть делегирования работы другим объектам. Тем не менее, они отличаются тем, что решают разные проблемы. Помните, что паттерны - это не только рецепт построения кода определённым образом, но и описание проблем, которые привели к данному решению.


[Composition]: </src/AdditionalDocs/Composition.md>

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
```java
package Structural.Adapter.Example.Adapter;

import java.util.Enumeration;
import java.util.Iterator;

/*
 * We want replace our old Enumeration on more new Iterator
 */
public class MyIterator implements Iterator {

  private Enumeration enumeration;

  public MyIterator(Enumeration enumeration) {
    this.enumeration = enumeration;
  }

  @Override
  public boolean hasNext() {
    return enumeration.hasMoreElements();
  }

  @Override
  public Object next() {
    return enumeration.nextElement();
  }

  @Override
  public void remove() {
    throw new UnsupportedOperationException("remove is not supported in Enumeration");
  }
}
```
```java
package Structural.Adapter.Example;

import Structural.Adapter.Example.Adapter.MyIterator;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.Vector;

/*
 * We want replace our old Enumeration on more new Iterator
 */
public class Ex1 {

  public static void main(String[] args) {
    Vector<String> vector = new Vector<>(Arrays.asList("A", "B", "C", "D"));

    Enumeration enumeration = vector.elements();
    /*
     * elements() return Enumeration so we need to use Adapter
     * Also we can use (Iterator) vector.elements()
     */

    //Create Interface
    Iterator iterator = new MyIterator(enumeration);
    while (iterator.hasNext()) {
      System.out.println(iterator.next());
    }

    //Get Exception
    iterator.remove();
  }
}
```
# Мост

![UML](/src/AdditionalDocs/uml/Bridge/Bridge.png)

Разделяет один или несколько классов на **две отдельные иерархии - абстракцию и реализацию**, позволяя изменять их независимо друг от друга.

 ***«Абстракция»*** (или *«интерфейс»*) - это образный слой управления чем-либо. Он не делает работу самостоятельно, а **делегирует её слою *«реализации»* (иногда называемому *«платформой»*)**.

!!!
**Только не путайте эти термины с интерфейсами или абстрактными классами из вашего языка программирования, это не одно и то же.**

Если говорить о реальных программах, то **абстракцией может выступать графический интерфейс программы**, а **реализацией - API к которому интерфейс обращается по реакции на действия пользователя**.

## Применимость
 
 - Когда вы хотите разделить монолитный класс, который содержит **несколько различных реализаций какой-то функциональности (например, может работать с разными системами баз данных)**.

   - Чем больше класс, тем тяжелее разобраться в его коде, тем больше это затягивает разработку. Кроме того, изменения, вносимые в одну из реализаций, приводят к редактированию всего класса, что может привести к ошибкам.

      **Мост** позволяет разделить монолитный класс на несколько отдельных иерархий. После этого вы можете менять их код независимо друг от друга. Это упрощает работу над кодом и уменьшает вероятность внесения ошибок.

 - Когда класс нужно **расширять в двух независимых плоскостях**.

    - **Мост** предлагает выделить одну из таких плоскостей в отдельную иерархию классов, **храня ссылку на один из её объектов в первоначальном классе**.

 - Когда вы хотите, чтобы **реализацию можно было бы изменять во время выполнения программы**.

   - **Мост** позволяет заменять реализацию даже во время выполнения программы, так как конкретная реализация не «вшита» в класс абстракции.

     Кстати, из-за этого пункта **Мост** часто путают со [**Стратегией**][Strategy]. Обратите внимания, что у **Моста** этот пункт стоит на последнем месте по значимости, так как его **главная задача - структурная**.

## Шаги реализации
 
1. Определите, существует ли в ваших классах **два непересекающихся измерения**. Это может быть **функциональность/платформа, предметная-область/инфраструктура, фронт-энд/бэк-энд или интерфейс/реализация**.

2. Продумайте, какие операции будут нужны клиентам и опишите их в базовом классе абстракции.

3. **Определите поведения доступные на всех платформах** и выделите из них ту часть, **которая будет нужная абстракции**. На основании этого опишите общий интерфейс реализации.

4. Для каждой платформы создайте свой класс конкретной реализации. Все они должны следовать общему интерфейсу, который мы выделили перед этим.

5. **Добавьте в класс абстракции ссылку на объект реализации**. Реализуйте методы абстракции, **делегируя основную работу связанному объекту реализации**.

6. Если у вас есть несколько вариаций абстракции, создайте для каждой из них свой подкласс.

7. Клиент должен **подать объект реализации в конструктор абстракции**, чтобы связать их воедино. После этого он может свободно использовать объект абстракции, забыв о реализации.

## Преимущества и недостатки
 
  | + | - |
  | ------ | ------ |
 |Позволяет строить платформо-независимые программы.|Усложняет код программы за счёт дополнительных классов.
 |Скрывает лишние или опасные детали реализации от клиентского кода.
 |Реализует принцип [**открытости/закрытости**][OCP].
 
 ## Отношения с другими паттернами

- **Мост** проектируют загодя, чтобы развивать большие части приложения отдельно друг от друга. [**Адаптер**][Adapter] применяется постфактум, чтобы заставить несовместимые классы работать вместе.

- **Мост**, [**Стратегия**][Strategy] и [**Состояние**][State] (а также слегка и [**Адаптер**][Adapter]) имеют схожие структуры классов - все они построены на принципе [**«композиции»**][Composition], то есть делегирования работы другим объектам. Тем не менее, они отличаются тем, что решают разные проблемы. Помните, что паттерны - это не только рецепт построения кода определённым образом, но и описание проблем, которые привели к данному решению.

- [**Абстрактная фабрика**][Abstract_Factory] может работать совместно с **Мостом**. Это особенно полезно, если у вас есть абстракции, которые могут работать только с некоторыми из реализаций. В этом случае фабрика будет определять типы создаваемых абстракций и реализаций.

- Паттерн [**Строитель**][Builder] может быть построен в виде **Моста**: директор будет играть роль абстракции, а строители - реализации.

[OCP]: </src/AdditionalDocs/SOLID/Open-Closed_principle.md>
[Composition]: </src/AdditionalDocs/Composition.md>

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
```java
package Structural.Bridge.Example.Devices;

public interface Device {

  int getVolume();

  void setVolume(int volume);

  int getChannel();

  void nextChannel();

  boolean isEnable();

  void disable();

  void enable();

}
```
```java
package Structural.Bridge.Example.Devices;

public class Radio implements Device {

  private int volume = 0;
  private int channel = 0;
  private boolean enable = false;

  @Override
  public int getVolume() {
    return volume;
  }

  @Override
  public void setVolume(int volume) {
    this.volume = volume;
  }

  @Override
  public int getChannel() {
    return channel;
  }

  @Override
  public void nextChannel() {
    System.out.println("Next channel on Radio");
    channel += 130;
  }

  @Override
  public boolean isEnable() {
    return enable;
  }

  @Override
  public void disable() {
    enable = false;
  }

  @Override
  public void enable() {
    enable = true;
  }
}
```
```java
package Structural.Bridge.Example.Devices;

public class TV implements Device {

  private int volume = 0;
  private int channel = 0;
  private boolean enable = false;

  @Override
  public int getVolume() {
    return volume;
  }

  @Override
  public void setVolume(int volume) {
    this.volume = volume;
  }

  @Override
  public int getChannel() {
    return channel;
  }

  @Override
  public void nextChannel() {
    System.out.println("Next channel on TV");
    channel += 1;
  }

  @Override
  public boolean isEnable() {
    return enable;
  }

  @Override
  public void disable() {
    enable = false;
  }

  @Override
  public void enable() {
    enable = true;
  }
}
```
```java
package Structural.Bridge.Example;

import Structural.Bridge.Example.Devices.Device;
import Structural.Bridge.Example.Devices.Radio;
import Structural.Bridge.Example.Devices.TV;
import Structural.Bridge.Example.RemoteControllers.NewConsole;
import Structural.Bridge.Example.RemoteControllers.PrimitiveConsole;
import Structural.Bridge.Example.RemoteControllers.TouchScreen;

public class Ex {

  public static void main(String[] args) {
    Device tv = new TV();
    Device radio = new Radio();

    TouchScreen touchScreen = new TouchScreen(tv);
    NewConsole newConsole = new NewConsole(tv);
    PrimitiveConsole primitiveConsole = new PrimitiveConsole(radio);

    touchScreen.power();
    touchScreen.changeChanel();
    touchScreen.changeChanel();
    newConsole.changeChanel();
    newConsole.mute();

    primitiveConsole.power();
    primitiveConsole.changeChanel();

    //We can do now with radio
    NewConsole newConsole1 = new NewConsole(radio);
    newConsole1.mute();
  }
}
```
```java
package Structural.Bridge.Example.RemoteControllers;

import Structural.Bridge.Example.Devices.Device;

public class NewConsole extends RemoteController {

  public NewConsole(Device device) {
    super(device);
  }

  @Override
  public void changeChanel() {
    System.out.println("Click button");
    device.nextChannel();
  }

  public void mute() {
    device.setVolume(0);
  }
}
```
```java
package Structural.Bridge.Example.RemoteControllers;

import Structural.Bridge.Example.Devices.Device;

public class PrimitiveConsole extends RemoteController {

  public PrimitiveConsole(Device device) {
    super(device);
  }

  @Override
  public void changeChanel() {
    System.out.println("Twist the wheel");
    device.nextChannel();
  }
}
```
```java
package Structural.Bridge.Example.RemoteControllers;

import Structural.Bridge.Example.Devices.Device;

//Abstraction delegate his behavior
public abstract class RemoteController {

  protected Device device;

  public RemoteController(Device device) {
    this.device = device;
  }

  public void power() {
    if (device.isEnable()) {
      device.disable();
    } else {
      device.enable();
    }
  }

  public void volumeUp() {
    device.setVolume(device.getVolume() + 10);
  }

  public void volumeDown() {
    device.setVolume(device.getVolume() - 10);
  }

  public abstract void changeChanel();


}
```
```java
package Structural.Bridge.Example.RemoteControllers;

import Structural.Bridge.Example.Devices.Device;

public class TouchScreen extends RemoteController {

  public TouchScreen(Device device) {
    super(device);
  }

  @Override
  public void changeChanel() {
    System.out.println("Swipe left");
    device.nextChannel();
  }

  public void mute() {
    device.setVolume(0);
  }
}
```
# Компоновщик

![UML](/src/AdditionalDocs/uml/Composite/Composite.png)

Объединяет объекты в **древовидную структуру** для представления иерархии от частного к целому. **Компоновщик** позволяет клиентам **обращаться к отдельным объектам и к группам объектов одинаково**.

**Лист** - это простой элемент дерева, не имеющий ответвлений.

**Контейнер** (или *«композит»* или **узел**) - это составной элемент дерева. Он содержит набор дочерних компонентов, но ничего не знает об их типах. Это могут быть как простые компоненты-листья, так и другие компоненты-контейнеры. Но это не является проблемой, так как все дочерние элементы следуют общему интерфейсу.

## Применимость

 - Когда вам нужно представить **древовидную структуру** объектов.

   - Паттерн **Компоновщик** предлагает хранить в составных объектах ссылки на другие простые или составные объекты. Те, в свою очередь, тоже могут хранить свои вложенные объекты и так далее. В итоге вы можете строить сложную древовидную структуру данных, используя всего две основные разновидности объектов.

 - Когда клиенты должны **единообразно трактовать простые и составные объекты**.

   - Благодаря тому, что **простые и составные объекты реализуют общий интерфейс**, клиенту безразлично с каким именно объектом ему предстоит работать.

## Шаги реализации

1. Убедитесь, что вашу бизнес-логику можно представить как **древовидную структуру**. Попытайтесь разбить её на простые элементы и контейнеры. Помните, что **контейнеры могут содержать как простые элементы, так и другие контейнеры**.

2. Создайте **общий интерфейс компонентов**, который объединит операции контейнеров и простых элементов дерева. **Интерфейс будет удачным, если вы сможете взаимозаменять простые и составные компоненты без потери смысла**.

3. Создайте класс компонентов-листьев, не имеющих дальнейших ответвлений. Имейте в виду, что программа может содержать несколько видов таких классов.

4. Создайте класс компонентов-контейнеров, и добавьте в него **массив для хранения ссылок на вложенные компоненты**. Этот массив должен быть способен содержать как простые, так и составные компоненты, поэтому убедитесь, что **он объявлен с типом интерфейса компонентов**.

    Реализуйте в контейнере методы интерфейса компонентов, помня о том, что **контейнеры должны делегировать основную работу своим дочерним компонентам**.

5. Добавьте операции **добавления и удаления дочерних элементов в класс контейнеров**.

   [(Ex)](/src/Structural/Composite/Example/Simple_No_ISP/) Имейте в виду, что **методы добавления/удаления дочерних элементов можно поместить и в интерфейс компонентов**. Да, это **нарушит принцип разделения интерфейса**, так как реализации методов будут пустыми в компонентах-листьях. **Но зато все компоненты дерева станут действительно одинаковыми для клиента**.

## Преимущества и недостатки

| + | - |
| ------ | ------ |
|Упрощает архитектуру клиента при работе со сложным деревом компонентов.|**Создаёт слишком общий дизайн классов**.
|Облегчает добавление новых видов компонентов.

 
 ## Отношения с другими паттернами

- [**Строитель**][Builder] позволяет пошагово сооружать дерево **Компоновщика**.

- [**Цепочку обязанностей**][Chain_of_Responsibility] часто используют вместе с **Компоновщиком**. В этом случае, запрос передаётся от дочерних компонентов к их родителям.

- [(Ex)](/src/Structural/Composite/Example/With_Iterator/)Вы можете обходить дерево **Компоновщика**, используя [**Итератор**][Iterator].

- Вы можете выполнить какое-то действие над всем деревом **Компоновщика** при помощи [**Посетителя**][Visitor].

- **Компоновщик** часто совмещают с [**Легковесом**][Flyweight], чтобы реализовать общие ветки дерева и сэкономить при этом память.

- **Компоновщик** и [**Декоратор**][Decorator] имеют похожие структуры классов из-за того, что оба построены на рекурсивной вложенности. Она позволяет связать в одну структуру бесконечное количество объектов.

  [**Декоратор**][Decorator] оборачивает только один объект, а узел **Компоновщика** может иметь много детей. [**Декоратор**][Decorator] добавляет вложенному объекту новую функциональность, а **Компоновщик** не добавляет ничего нового, но «суммирует» результаты всех своих детей.

  Но они могут и сотрудничать: **Компоновщик** может использовать [**Декоратор**][Decorator], чтобы переопределить функции отдельных частей дерева компонентов.

- Архитектура, построенная на **Компоновщиках** и [**Декораторах**][Decorator], часто может быть улучшена за счёт внедрения [**Прототипа**][Prototype]. Он позволяет клонировать сложные структуры объектов, а не собирать их заново.

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
```java
package Structural.Composite.Example.Simple_No_ISP;

/*
 * This example is violates the Interface Segregation principle,
 * but for transparency of the code.
 * (Client always work with MenuComponent,
 * so he can not ot worry about the instanceOf() )
 * But he also need catch the exception.
 */

import Structural.Composite.Example.Simple_No_ISP.Restoran.Menu.Menu;
import Structural.Composite.Example.Simple_No_ISP.Restoran.MenuComponent;
import Structural.Composite.Example.Simple_No_ISP.Restoran.MenuItem.Dish;
import Structural.Composite.Example.Simple_No_ISP.Restoran.Waitress;

// Some menus may have a different menu in the himself.
// Security is low bc he can use add(MenuComponent) in Dish, which not good.
public class Ex {

  public static void main(String[] args) {

    //Create Menus
    MenuComponent desertMenu1 = new Menu("Desert in haven menu");
    MenuComponent desertMenu2 = new Menu("Special propose menu");
    MenuComponent desertMenu3 = new Menu("Christmas menu");

    MenuComponent dinnerMenu = new Menu("Dinner for Gentlemen");

    //Adding item for mainMenu (on top of the tree)
    MenuComponent mainMenu = new Menu("Main menu : ");
    mainMenu.add(desertMenu1);
    mainMenu.add(dinnerMenu);
    Waitress waitress = new Waitress(mainMenu);

    //Adding item for another elements
    desertMenu1.add(new Dish("Waffles", 0.99));
    desertMenu1.add(new Dish("Desert", 2.90));
    desertMenu1.add(desertMenu2);

    desertMenu2.add(new Dish("Pancake with milk", 5.25));
    desertMenu2.add(desertMenu3);

    desertMenu3.add(new Dish("Santa sperm", 0.01));

    dinnerMenu.add(new Dish("HotDog", 3.99));
    dinnerMenu.add(new Dish("BLT", 10.99));
    dinnerMenu.add(new Dish("Soup", 7.99));

    waitress.getMenu();
  }
}
```
```java
package Structural.Composite.Example.Simple_No_ISP.Restoran.Menu;

import Structural.Composite.Example.Simple_No_ISP.Restoran.MenuComponent;
import java.util.ArrayList;
import java.util.List;

/*
 * Composite.
 */

//Menu implements only his method
public class Menu extends MenuComponent {

  private List<MenuComponent> menu;
  private String name;

  public Menu(String name) {
    this.name = name;
    menu = new ArrayList<>();
  }

  @Override
  public String getName() {
    return name;
  }

  @Override
  public void add(MenuComponent menuComponent) {
    menu.add(menuComponent);
  }

  @Override
  public void remove(MenuComponent menuComponent) {
    menu.remove(menuComponent);
  }

  @Override
  public void print() {
    System.out.println("/////////////////");
    System.out.println("Menu : " + getName() + " have : ");
    for (MenuComponent menuComponent : menu) {
      menuComponent.print();
    }
  }

}
```
```java
package Structural.Composite.Example.Simple_No_ISP.Restoran;

/*
 * This example is violates the Interface Segregation principle,
 * but for transparency of the code.
 * (Client always work with MenuComponent,
 * so he can not ot worry about the instanceOf())
 * But he also need catch the exception.
 */

public abstract class MenuComponent {

  //Need in Menu and in MenuItem (dish)
  public String getName() {
    throw new UnsupportedOperationException();
  }

  //Need in Menu and in MenuItem (dish)
  public void print() {
    throw new UnsupportedOperationException();
  }

  //Need only in MenuItem (dish)
  public double getPrice() {
    throw new UnsupportedOperationException();
  }

  //Need only in Menu (for work with his elements)
  public void add(MenuComponent menuComponent) {
    throw new UnsupportedOperationException();
  }

  //Need only in Menu (for work with his elements)
  public void remove(MenuComponent menuComponent) {
    throw new UnsupportedOperationException();
  }
}
```
```java
package Structural.Composite.Example.Simple_No_ISP.Restoran.MenuItem;

import Structural.Composite.Example.Simple_No_ISP.Restoran.MenuComponent;

//MenyItem (Dish) implements only his method
public class Dish extends MenuComponent {

  private String name;
  private double price;

  public Dish(String name, double price) {
    this.name = name;
    this.price = price;
  }

  @Override
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  @Override
  public double getPrice() {
    return price;
  }

  public void setPrice(double price) {
    this.price = price;
  }

  @Override
  public void print() {
    System.out.println(" - Name is: " + getName() + " which will be cost = " + getPrice());
  }
}
```
```java
package Structural.Composite.Example.Simple_No_ISP.Restoran;

public class Waitress {

  private MenuComponent mainMenu;

  public Waitress(MenuComponent mainMenu) {
    this.mainMenu = mainMenu;
  }

  //Print all elements, bc we call top of the tree.
  public void getMenu() {
    mainMenu.print();
  }
}
```
```java
package Structural.Composite.Example.With_Iterator;

/*
 * This example is violates the Interface Segregation principle,
 * but for transparency of the code.
 * (Client always work with MenuComponent,
 * so he can not ot worry about the instanceOf() )
 * But he also need catch the exception.
 */

import Structural.Composite.Example.With_Iterator.Restoran.Menu.Menu;
import Structural.Composite.Example.With_Iterator.Restoran.MenuComponent;
import Structural.Composite.Example.With_Iterator.Restoran.MenuItem.Dish;
import Structural.Composite.Example.With_Iterator.Restoran.Waitress;

//Some menus may have a different menu in the himself
// Security is low bc he can use add(MenuComponent) in Dish, which not good
public class Ex {

  public static void main(String[] args) {
    //Create Menus
    MenuComponent desertMenu1 = new Menu("Desert in haven menu");
    MenuComponent desertMenu2 = new Menu("Special propose menu");
    MenuComponent desertMenu3 = new Menu("Christmas menu");

    MenuComponent dinnerMenu = new Menu("Dinner for Gentlemen");

    //Adding item to mainMenu (top of the tree)
    MenuComponent mainMenu = new Menu("Main menu : ");
    mainMenu.add(desertMenu1);
    mainMenu.add(dinnerMenu);
    Waitress waitress = new Waitress(mainMenu);

    //Adding item to another elements
    desertMenu1.add(new Dish("Waffles", 0.99));
    desertMenu1.add(new Dish("Desert", 2.90));
    desertMenu1.add(desertMenu2);

    desertMenu2.add(new Dish("Pancake with milk", 5.25));
    desertMenu2.add(desertMenu3);

    desertMenu3.add(new Dish("Santa sperm", 0.01));

    dinnerMenu.add(new Dish("HotDog", 3.99));
    dinnerMenu.add(new Dish("BLT", 10.99));
    dinnerMenu.add(new Dish("Soup", 7.99));

    waitress.getMenuWithMinPrice(5.00);
  }
}
```
```java
package Structural.Composite.Example.With_Iterator.Iterators;

import Structural.Composite.Example.With_Iterator.Restoran.Menu.Menu;
import Structural.Composite.Example.With_Iterator.Restoran.MenuComponent;
import java.util.Iterator;
import java.util.Stack;

public class CompositeIterator implements Iterator<MenuComponent> {

  private Stack<Iterator<MenuComponent>> stack = new Stack<>();

  public CompositeIterator(
    Iterator<MenuComponent> iterator) {
    stack.push(iterator);
  }

  @Override
  public MenuComponent next() {
    if (hasNext()) {
      Iterator<MenuComponent> iterator = stack.peek();
      MenuComponent component = iterator.next();
      if (component instanceof Menu) {
        //Need to go through the nested combination
        stack.push(component.createIterator());
      }
      return component;
    } else {
      return null;
    }
  }

  @Override
  public boolean hasNext() {
    if (stack.isEmpty()) {
      return false;
    } else {
      Iterator<MenuComponent> iterator = stack.peek();
      if (!iterator.hasNext()) {
        //If iterator is on last element (does not have next element)
        //delete iterator from stack and then use next Iterator.
        stack.pop();
        return hasNext();
      } else {
        return true;
      }
    }
  }
}
```
```java
package Structural.Composite.Example.With_Iterator.Iterators;

import Structural.Composite.Example.With_Iterator.Restoran.MenuComponent;
import java.util.Iterator;

public class NullIterator implements Iterator<MenuComponent> {

  @Override
  public boolean hasNext() {
    return false;
  }

  @Override
  public MenuComponent next() {
    return null;
  }

  @Override
  public void remove() {
    throw new UnsupportedOperationException();
  }
}
```
```java
package Structural.Composite.Example.With_Iterator.Restoran.Menu;

import Structural.Composite.Example.With_Iterator.Iterators.CompositeIterator;
import Structural.Composite.Example.With_Iterator.Restoran.MenuComponent;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

//Menu implements only his method
public class Menu extends MenuComponent {

  private Iterator<MenuComponent> iterator;
  private List<MenuComponent> menu;
  private String name;

  public Menu(String name) {
    this.name = name;
    menu = new ArrayList<>();
  }

  @Override
  public String getName() {
    return name;
  }

  @Override
  public void add(MenuComponent menuComponent) {
    menu.add(menuComponent);
  }

  @Override
  public void remove(MenuComponent menuComponent) {
    menu.remove(menuComponent);
  }

  @Override
  public Iterator<MenuComponent> createIterator() {
    if (iterator == null) {
      iterator = new CompositeIterator(menu.iterator());
    }
    return iterator;
  }

  @Override
  public void print() {
    System.out.println("/////////////////");
    System.out.println("Menu : " + getName() + " have : ");
    for (MenuComponent menuComponent : menu) {
      menuComponent.print();
    }
  }

}
```
```java
package Structural.Composite.Example.With_Iterator.Restoran;

/*
 * This example is violates the Interface Segregation principle,
 * but for transparency of the code.
 * (Client always work with MenuComponent,
 * so he can not ot worry about the instanceOf() )
 * But he also need catch the exception.
 */

import java.util.Iterator;

public abstract class MenuComponent {

  //Need in Menu and in MenuItem (dish)
  public abstract String getName();

  //Need in Menu and in MenuItem (dish)
  public abstract void print();

  //Need only in MenuItem (dish)
  public double getPrice() {
    throw new UnsupportedOperationException();
  }

  //Need only in Menu (for work with his elements)
  public void add(MenuComponent menuComponent) {
    throw new UnsupportedOperationException();
  }

  //Need only in Menu (for work with his elements)
  public void remove(MenuComponent menuComponent) {
    throw new UnsupportedOperationException();
  }

  //Need in Menu and in MenuItem (dish)
  public abstract Iterator<MenuComponent> createIterator();
}
```
```java
package Structural.Composite.Example.With_Iterator.Restoran.MenuItem;

import Structural.Composite.Example.With_Iterator.Iterators.NullIterator;
import Structural.Composite.Example.With_Iterator.Restoran.MenuComponent;
import java.util.Iterator;

//MenuItem (Dish) implements only his method
public class Dish extends MenuComponent {

  private String name;
  private double price;

  public Dish(String name, double price) {
    this.name = name;
    this.price = price;
  }

  @Override
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  @Override
  public double getPrice() {
    return price;
  }

  @Override
  public Iterator<MenuComponent> createIterator() {
    return new NullIterator();
  }

  public void setPrice(double price) {
    this.price = price;
  }

  @Override
  public void print() {
    System.out.println(" - Name is: " + getName() + " which will be cost = " + getPrice());
  }
}
```
```java
package Structural.Composite.Example.With_Iterator.Restoran;

import java.util.Iterator;

public class Waitress {

  private MenuComponent mainMenu;

  public Waitress(MenuComponent mainMenu) {
    this.mainMenu = mainMenu;
  }

  //Get all of the menu, bc we call top of the tree
  public void getMenu() {
    mainMenu.print();
  }

  public void getMenuWithMinPrice(double price) {
    Iterator<MenuComponent> iterator = mainMenu.createIterator();
    System.out.println("All with price above " + price);
    while (iterator.hasNext()) {
      MenuComponent menuComponent = iterator.next();
      try {

        //Price is only in the Dish

        if (menuComponent.getPrice() >= price) {
          menuComponent.print();
        }
      } catch (UnsupportedOperationException ignored) {
      }
    }
  }
}
```
# Декоратор 

![UML](/src/AdditionalDocs/uml/Decorator.png)

Позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».

 **Декоратор** имеет альтернативное название - «обёртка». Оно удачнее описывает суть паттерна: вы **помещаете целевой объект в другой объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к результату что-то своё**.

1. Декораторы **имеют тот же супертип**, что и декорируемые объекты;

2. Объект можно завернуть в 1 или несколько декораторов;

3. (из 1 следует) можно передать декорируемый объект вместо исходного;

4. Декоратор **добавляет свое действие до и/или после делегирования операций декорируемому объекту**, выполняющему остальную роботу 

5. Объект может быть **декорирован** в любой момент времени, т.е. **динамически и с произвольным кол. декораторов**.

!!! 
**Если программировать на уровне конкретного объекта Декоратор не подходит**.

## Применимость

 - Когда вам нужно **добавлять обязанности объектам на лету**, незаметно для кода, который их использует.

   - Объекты помещают в обёртки, имеющие дополнительные поведения. Обёртки и сами объекты имеют одинаковый интерфейс, поэтому клиентам без разницы с чем работать - с обычным объектом или обёрнутым.

 - Когда **нельзя расширить обязанности объекта с помощью наследования**.

   - Во многих языках программирования есть ключевое слово `final`, которое может заблокировать наследование класса. Расширить такие классы можно только с помощью **Декоратора**.

## Шаги реализации

 1. Убедитесь, что в вашей задаче есть **один основной компонент и несколько опциональных дополнений или надстроек над ним**.

 2. Создайте **интерфейс** компонента, который описывал бы все общие методы как для **основного компонента, так и для его дополнений**.

 3. Создайте **класс конкретного компонента** и поместите в него основную бизнес-логику.

 4. Создайте базовый класс декораторов. Он должен иметь **поле для хранения ссылки на вложенный объект-компонент**. Все методы базового декоратора должны делегировать действие вложенному объекту.

 5. И конкретный компонент, и базовый декоратор должны следовать одному и тому же интерфейсу компонента.

 6. Теперь создайте классы конкретных декораторов, наследуя их от базового декоратора. **Конкретный декоратор должен выполнять свою добавочную функциональность, а затем (или перед этим) вызывать эту же операцию обёрнутого объекта**.

 7. **Клиент берёт на себя ответственность за конфигурацию и порядок обёртывания объектов**.
 
## Преимущества и недостатки

| + | - |
| ------ | ------ |
|Большая гибкость, чем у наследования|Трудно конфигурировать многократно обёрнутые объекты.
|Позволяет добавлять обязанности на лету|**Обилие крошечных классов**. 
|Можно добавлять несколько новых обязанностей сразу.
|Позволяет иметь **несколько мелких объектов вместо одного объекта** на все случаи жизни.

## Отношения с другими паттернами

 - [**Адаптер**][Adapter] меняет интерфейс существующего объекта. **Декоратор** улучшает другой объект без изменения его интерфейса. Причём Декоратор поддерживает рекурсивную вложенность, чего не скажешь об Адаптере.

 - [**Адаптер**][Adapter] предоставляет классу альтернативный интерфейс. **Декоратор** предоставляет расширенный интерфейс. [**Заместитель**][Proxy] предоставляет тот же интерфейс.

 - [**Цепочка обязанностей**][Chain_of_Responsibility] и **Декоратор** имеют очень похожие структуры. Оба паттерна базируются на принципе **рекурсивного выполнения операции через серию связанных объектов**. Но есть и несколько важных отличий.

   Обработчики в [**Цепочке обязанностей**][Chain_of_Responsibility] могут выполнять **произвольные действия, независимые друг от друга,** а также в любой момент **прерывать дальнейшую передачу** по цепочке. С другой стороны Декораторы расширяют какое-то определённое действие, не ломая интерфейс базовой операции и не прерывая выполнение остальных декораторов.

- [**Компоновщик**][Composite] и **Декоратор** имеют похожие структуры классов из-за того, что оба построены на **рекурсивной вложенности**. Она позволяет связать в одну структуру бесконечное количество объектов.

    **Декоратор** оборачивает только один объект, а узел [**Компоновщика**][Composite] может иметь много детей. **Декоратор** добавляет вложенному объекту новую функциональность, а [**Компоновщик**][Composite] не добавляет ничего нового, но «суммирует» результаты всех своих детей.

    Но они могут и сотрудничать: [**Компоновщик**][Composite] может использовать **Декоратор**, чтобы переопределить функции отдельных частей дерева компонентов.

 - Архитектура, построенная на [**Компоновщиках**][Composite] и **Декораторах**, часто может быть улучшена за счёт внедрения [**Прототипа**][Prototype]. Он позволяет **клонировать сложные структуры объектов, а не собирать их заново**.

 - [**Стратегия**][Strategy] меняет поведение объекта **«изнутри»**, а **Декоратор** изменяет его **«снаружи»**.

 - **Декоратор** и [**Заместитель**][Proxy] имеют похожие структуры, но разные назначения. Они похожи тем, что оба построены на **композиции и делегировании** работы другому объекту. Паттерны отличаются тем, что [**Заместитель**][Proxy] **сам управляет жизнью сервисного объекта**, а обёртывание **Декораторов** контролируется клиентом.

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
```java
package Structural.Decorator.Example;

import Structural.Decorator.Example.Products.Beverage;
import Structural.Decorator.Example.Products.DarkRoast;
import Structural.Decorator.Example.Products.Espresso;
import Structural.Decorator.Example.Supplements.Milk;
import Structural.Decorator.Example.Supplements.Soy;

public class Decorator {

  public static void main(String[] args) {
    Beverage myDrinks = new DarkRoast();

    System.out.println(myDrinks.getDescription() + "That will be cost " + myDrinks.cost());

    //Add some milk with Soy in drink
    myDrinks = new Milk(myDrinks);
    myDrinks = new Soy(myDrinks);

    //Or we can do like that
    Beverage drink1 = new Milk(new Milk(new Soy(new Espresso())));

    System.out.println(myDrinks.getDescription() + "That will be cost " + myDrinks.cost());


  }


}
```
```java
package Structural.Decorator.Example.Products;

/*
 * Common interface for all drinks
 */

public interface Beverage {

  String getDescription();

  double cost();
}
```
```java
package Structural.Decorator.Example.Products;

public class DarkRoast implements Beverage {

  @Override
  public String getDescription() {
    return "DarkRoast";
  }

  @Override
  public double cost() {
    return 2.2;
  }
}
```
```java
package Structural.Decorator.Example.Products;

public class Espresso implements Beverage {

  @Override
  public String getDescription() {
    return "Espresso";
  }

  @Override
  public double cost() {
    return 1.5;
  }
}
```
```java
package Structural.Decorator.Example.Supplements;

import Structural.Decorator.Example.Products.Beverage;

/*
 *Concrete class decorator
 */

public class Milk extends SupplementsDecorator {

  public Milk(Beverage beverage) {
    super(beverage);
  }

  @Override
  public String getDescription() {
    return beverage.getDescription() + ", milk";
  }

  @Override
  public double cost() {
    return beverage.cost() + 0.10;
  }
}
```
```java
package Structural.Decorator.Example.Supplements;

import Structural.Decorator.Example.Products.Beverage;

/*
 *Concrete class decorator
 */

public class Soy extends SupplementsDecorator {

  public Soy(Beverage beverage) {
    super(beverage);
  }

  @Override
  public String getDescription() {
    return beverage.getDescription() + ", soy";
  }

  @Override
  public double cost() {
    return beverage.cost() + 0.25;
  }
}
```
```java
package Structural.Decorator.Example.Supplements;

import Structural.Decorator.Example.Products.Beverage;

/*
 * Common class for all Decorators(Supplements)
 * Sometimes can be ignored(not exists)
 */

public abstract class SupplementsDecorator implements Beverage {

  protected Beverage beverage;

  public SupplementsDecorator(Beverage beverage) {
    this.beverage = beverage;
  }

  @Override
  public abstract String getDescription();

  @Override
  public abstract double cost();
}
```
```java
package Structural.Facade.Example;

import Structural.Facade.Example.Facade.Computer;
import Structural.Facade.Example.Subsystem.Mather;
import Structural.Facade.Example.Subsystem.Proz;
import Structural.Facade.Example.Subsystem.Video_Card;

public class Ex1 {

  public static void main(String[] args) {
    // Init components
    Video_Card video_card = new Video_Card();
    Proz proz = new Proz();
    Mather mather = new Mather();

    Computer computer = new Computer(video_card, proz, mather);
    computer.computerOn();

    //some work
    computer.computerOff();
  }
}
```
```java
package Structural.Facade.Example.Facade;

import Structural.Facade.Example.Subsystem.Mather;
import Structural.Facade.Example.Subsystem.Proz;
import Structural.Facade.Example.Subsystem.Video_Card;

/*
 * We can create additional Facade = Computer_Peripherals
 * (in case if we want to add Mouse, Keyboard, Monitor
 * If the responsibility of the facade begins to blur.
 */

public class Computer {

  private Video_Card video_card;
  private Proz proz;
  private Mather mather;

  public Computer(Video_Card video_card, Proz proz, Mather mather) {
    this.video_card = video_card;
    this.proz = proz;
    this.mather = mather;
  }

  public void computerOn() {
    mather.powerOn();
    proz.powerOn();
    video_card.powerOn();
    video_card.showPicture();

    //Mb some another method

  }

  public void computerOff() {
    mather.powerOff();
    proz.powerOff();
    video_card.powerOff();

    //Mb some another method

  }

}

```
```java
package Structural.Facade.Example.Subsystem;

public class Mather {

  public void powerOn() {
    System.out.println("Mather is on");
  }

  public void powerOff() {
    System.out.println("Mather is off");
  }

  //Some methods

}
```
```java
package Structural.Facade.Example.Subsystem;

public class Proz {

  public void powerOn() {
    System.out.println("Proz is on");
  }

  public void powerOff() {
    System.out.println("Prozz is off");
  }

  //Some methods

}
```
```java
package Structural.Facade.Example.Subsystem;

public class Video_Card {

  public void powerOn() {
    System.out.println("Video card is on");
  }

  public void powerOff() {
    System.out.println("Video card is off");
  }

  public void showPicture() {
    System.out.println("Video card shows picture");
  }

  //Some methods

}
```
# Фасад

![UML](/src/AdditionalDocs/uml/Facade.png)

Предоставляет **унифицированный интерфейс к группе интерфейсов подсистемы**. Фасад определяет высокоуровневый интерфейс, упрощая работу с подсистемой 

## Применимость

 - Когда вам нужно представить **простой или урезанный интерфейс к сложной подсистеме**.

   - Часто подсистемы усложняются по мере развития. Применение большинства паттернов приводит к появлению меньших классов, но в большем количестве. Такую подсистему проще повторно использовать и настраивать под конкретные нужды, но вместе с тем применять подсистему без настройки становится труднее. **Фасад** предлагает некоторый вид системы по умолчанию, устраивающий большинство клиентов.

 - Когда вы хотите **разложить подсистему на отдельные слои**.

    - Используйте фасады для определения точек входа на каждый уровень подсистемы. Если подсистемы зависят друг от друга, то зависимость можно упростить, разрешив подсистемам обмениваться информацией только через фасады.

      *Например, возьмём ту же сложную система видеоконвертации. Вы хотите разбить её на слои работы с аудио и видео. Для каждой из этих частей можно попытаться создать фасад и заставить классы аудио и видео обработки общаться друг с другом через эти фасады, а не напрямую.*

 ## Шаги реализации
 
1. Определите можно ли создать **более простой интерфейс, чем тот, который предоставляет сложная подсистема**. Вы на правильном пути, если этот интерфейс избавит клиента от знания о подробностях подсистемы.

2. Создайте класс фасада, реализующий этот интерфейс. Он должен переадресовывать вызовы клиента нужным объектам подсистемы. **Фасад должен будет позаботиться о том, чтобы правильно инициализировать объекты подсистемы**.

3. Вы получите максимум пользы, если **клиент будет работать только с фасадом**. В этом случае, изменения в подсистеме будут затрагивать только код фасада, а клиентский код останется рабочим.

4. **Если ответственность фасада начинает размываться, подумайте о введении дополнительных фасадов**.

 ## Преимущества и недостатки
  
 | + | - |
 | ------ | ------ |
 |Изолирует клиентов от компонентов системы.|Фасад рискует стать [**божественным объектом**][God-Object], привязанным ко всем классам программы.
 |Уменьшает зависимость между подсистемой и клиентами.
 
 ## Отношения с другими паттернами

 - **Фасад** задаёт новый интерфейс, тогда как [**Адаптер**][Adapter] повторно использует старый. [**Адаптер**][Adapter] оборачивает только один класс, а **Фасад** оборачивает целую подсистему. Кроме того, [**Адаптер**][Adapter] позволяет двум существующим интерфейсам работать сообща, вместо того, чтобы задать полностью новый.

 - [**Абстрактная фабрика**][Abstract_Factory] может быть использована вместо **Фасада** для того, чтобы скрыть платформо-зависимые классы.

 - [**Легковес**][Flyweight] показывает, как создавать много мелких объектов, а **Фасад** показывает, как создать один объект, который отображает целую подсистему.

 - [**Посредник**][Mediator] и **Фасад** похожи тем, что пытаются организовать работу множества существующих классов.

   - **Фасад** создаёт упрощённый интерфейс к подсистеме, не внося в неё никакой добавочной функциональности. Сама подсистема не знает о существовании **Фасада**. Классы подсистемы общаются друг с другом напрямую.
  
   - [**Посредник**][Mediator] централизует общение между компонентами системы. Компоненты системы знают только о существовании [**Посредника**][Mediator], у них нет прямого доступа к другим компонентам.
 
 - **Фасад** можно сделать [**Одиночкой**][Singleton], так как обычно нужен только один объект-фасад.

 - **Фасад** похож на [**Заместитель**][Proxy] тем, что замещает сложную подсистему и может сам её инициализировать. Но в отличие от **Фасада**, [**Заместитель**][Proxy] имеет тот же интерфейс, что его служебный объект, благодаря чему их можно взаимозаменять.

[God-Object]:</src/AdditionalDocs/AntiPatterns/God-Object.md>

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
```java
package Structural.Flyweight.Example.Elements;

//Changeable parameters
public class Bullet {

  private int speed;
  private BulletType bulletType;

  public Bullet(int speed, BulletType bulletType) {
    this.speed = speed;
    this.bulletType = bulletType;
  }

  public int getSpeed() {
    return speed;
  }

  public BulletType getBulletType() {
    return bulletType;
  }

  public void setSpeed(int speed) {
    this.speed = speed;
  }

  public void setBulletType(BulletType bulletType) {
    this.bulletType = bulletType;
  }
}
```
```java
package Structural.Flyweight.Example.Elements;

import java.util.HashMap;
import java.util.Map;

public class BulletFactory {

  private BulletFactory() {
  }

  //Also can use Set<>
  private static Map<String, BulletType> bullets = new HashMap<>();

  public static BulletType getBulletType(String name, String sprite) {
    BulletType bulletType = bullets.get(name);
    if (bulletType == null) {
      bulletType = new BulletType(sprite);
      bullets.put(name, bulletType);
    }
    return bulletType;
  }
}
```
```java
package Structural.Flyweight.Example.Elements;

//Unchangeable parameters
public class BulletType {

  //FINAL
  private final String sprite; //Some heavy elements
  //...

  public BulletType(String sprite) {
    this.sprite = sprite;
  }

  public String getSprite() {
    return sprite;
  }
}
```
```java
package Structural.Flyweight.Example;

import Structural.Flyweight.Example.Weapons.Gun;

public class Ex {

  public static void main(String[] args) {
    //Also can add Pistol ...
    Gun gun = new Gun();

    for (int i = 0; i < 100; i++) {
      gun.fire();
    }
  }

}
```
```java
package Structural.Flyweight.Example.Weapons;

import Structural.Flyweight.Example.Elements.Bullet;
import Structural.Flyweight.Example.Elements.BulletFactory;
import Structural.Flyweight.Example.Elements.BulletType;
import java.util.ArrayList;
import java.util.List;

public class Gun {

  private List<Bullet> bullets = new ArrayList<>();

  public void fire() {
    BulletType bulletType = BulletFactory.getBulletType("Gun", "GunSprite.png");
    Bullet bullet = new Bullet(200, bulletType);
    bullets.add(bullet);
    System.out.println("Bullet was add to game");
  }
}
```
# Приспособленец 

![UML](/src/AdditionalDocs/uml/Flyweight.png)

Позволяет вместить большее количество объектов в отведённую оперативной память за счёт **экономного разделения общего состояния объектов между собой, вместо хранения одинаковых данных в каждом объекте.**

**Неизменяемые данные объекта принято называть «*внутренним состоянием*». Все остальные данные - это «*внешнее состояние*»**.

#### Неизменяемость Легковесов

Так как **объекты легковесов** будут использованы в разных контекстах, вы должны быть уверены в том, что **их состояние невозможно изменять после создания (*final*)**. Всё внутреннее состояние легковес должен получать через параметры конструктора. Он не должен иметь сеттеров и публичных полей.

#### Фабрика Легковесов

**Flyweight** дополняет шаблон [**Factory Method**][Factory_Method] таким образом, что при обращении клиента [**Factory Method**][Factory_Method] для создания нового объекта ищет уже созданный объект с такими же параметрами, что и у требуемого, и возвращает его клиенту. Если такого объекта нет, то фабрика создаст новый.

Обычно этот метод добавляют в контейнер легковесов либо создают отдельный класс-фабрику. Его даже можно сделать статическим и поместить в класс легковесов.

## Применимость

- Когда **не хватает оперативной памяти для поддержки всех нужных объектов**.

  - Эффективность паттерна **Легковес** во многом зависит от того, как и где он используется. Применяйте этот паттерн, когда выполнены все перечисленные условия:

     - в приложении используется большое число объектов;

     - (из-за этого) высоки расходы оперативной памяти;

     - большую часть состояния объектов можно вынести за пределы их классов;

     - многие группы объектов можно заменить относительно небольшим количеством разделяемых объектов, поскольку внешнее состояние вынесено.

## Шаги реализации

1. Разделите поля класса, который станет легковесом, на две части:

   - **внутреннее состояние**: значения этих полей одинаковы для большого числа объектов.

   - **внешнее состояние (контекст)**: значения полей уникальны для каждого объекта.
   
2. **Оставьте поля внутреннего состояние в классе**, но убедитесь, что их значения неизменяемы. **Эти поля должны инициализироваться только через конструктор (final)**.

3. Превратите **поля внешнего состояния в аргументы методов**, где эти поля использовались. Затем, удалите поля из класса.

4. **Создайте фабрику, которая будет кешировать и повторно отдавать уже созданные объекты**. Клиент должен запрашивать легковеса с определённым внутренним состоянием из этой фабрики, а не создавать его напрямую.

5. Клиент должен хранить или вычислять значения внешнего состояния (контекст) и передавать его в методы объекта легковеса.

 ## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |Экономит оперативную память.|Расходует процессорное время на поиск/вычисление контекста.
 | |Усложняет код программы за счёт множества дополнительных классов.
 
 ## Отношения с другими паттернами

- [**Компоновщик**][Composite] часто совмещают с **Легковесом**, чтобы реализовать общие ветки дерева и сэкономить при этом память.

- **Легковес** показывает, как создавать много мелких объектов, а [**Фасад**][Facade] показывает, как создать один объект, который отображает целую подсистему.

- Паттерн **Легковес** может напоминать [**Одиночку**][Singleton], если для конкретной задачи у вас получилось уменьшить количество объектов к одному. Но помните, что между паттернами есть два кардинальных отличия:

  - В отличие от [**Одиночки**][Singleton], вы можете иметь множество объектов-легковесов.

  - Объекты-легковесов должны быть неизменяемыми, тогда как **объект-одиночки допускает изменение своего состояния**.
 
 
[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
```java
package Structural.Private_Class_Data.Example;

public class Circle {

  private CircleData circleData;

  public Circle(double r, String color, String name) {
    circleData = new CircleData(r, color, name);
  }

  public double Circumference() {
    return 2 * circleData.getR() * Math.PI;
  }

  public double Diameter() {
    return this.circleData.getR() * 2;
  }

}
```
```java
package Structural.Private_Class_Data.Example;

public class CircleData {

  private double R;
  private String color;
  private String name;
  //...

  public CircleData(double r, String color, String name) {
    R = r;
    this.color = color;
    this.name = name;
  }

  public double getR() {
    return R;
  }

  public String getColor() {
    return color;
  }

  public String getName() {
    return name;
  }

  //...
}
```
# Выделение частного класса данных

![UML](/src/AdditionalDocs/uml/Private_Class_Data.png)

Инкапсулирует данные перемещая их в другой класс. **Не дает возможности изменять переменные даже самому классу (так как они в другом классе)**

(Замена `final`)

!!!

[Java - не нужно. Больше для С#](https://stackoverflow.com/questions/42540998/private-class-data-design-pattern-in-java)

!!!
## Применимость
  
  - Когда мы хотим сделать `final after constructor`.

  - Когда у класса много атрибутов.
    
    - Мы выделяем новый класс, (или классы) которые вмещают в себя все нужные данные.

## Шаги реализации

1. Создать Дата-класс, который будет иметь одну ответственность, используя методы рефакторинга: **выделения поля и выделения метода**. Добавить все поля, которые нужно сокрыть.

2. Создайте **связь между старым и новым классом**. Старый класс, должен создавать Дата-класс передавая данные через конструктор.



[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Object_Pool]: </src/Creational/Object_Pool/Object_Pool.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>
[Proxy]: </src/Structural/Private_Class_Data/Private_Class_Data.md>


[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
```java
package Structural.Proxy.Example.Cached_proxy;

import Structural.Proxy.Example.Cached_proxy.ImageLoader.ImageLoader;
import Structural.Proxy.Example.Cached_proxy.ImageLoader.ImageLoaderProxy;

public class Ex {

  public static void main(String[] args) {
    ImageLoader imageLoader = new ImageLoaderProxy();

    System.out.println(imageLoader.getImage("Cat").toString());
    System.out.println(imageLoader.getImage("Dog").toString());
    System.out.println(imageLoader.getImage("Cat").toString());
    System.out.println(imageLoader.getImage("Cat").toString());
  }
}
```
```java
package Structural.Proxy.Example.Cached_proxy.ImageLoader;

import Structural.Proxy.Example.Cached_proxy.Object.Image;

public interface ImageLoader {

  Image getImage(String path);
}
```
```java
package Structural.Proxy.Example.Cached_proxy.ImageLoader;

import Structural.Proxy.Example.Cached_proxy.Object.Image;

public class ImageLoaderClass implements ImageLoader {

  @Override
  public Image getImage(String path) {
    Image image = null;
    try {
      image = load(path);
      image = render(image);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    return image;
  }

  private Image render(Image image) throws InterruptedException {
    System.out.println(image.getName() + " is rendering...");

    //Mock process
    Thread.sleep(image.getSize());

    return image;
  }

  private Image load(String path) throws InterruptedException {
    //Some hard work, which need a lot of time
    //Mock process
    Thread.sleep(2000);

    Image image = new Image(path, 1000);
    System.out.println("Our image " + path + " was loaded ");
    return image;
  }
}
```
```java
package Structural.Proxy.Example.Cached_proxy.ImageLoader;

import Structural.Proxy.Example.Cached_proxy.Object.Image;
import java.util.HashMap;
import java.util.Map;

public class ImageLoaderProxy implements ImageLoader {

  private Map<String, Image> cache = new HashMap<>();
  private ImageLoaderClass imageLoaderClass;

  //We can also send through constructor
  public ImageLoaderProxy(ImageLoaderClass imageLoaderClass) {
    this.imageLoaderClass = imageLoaderClass;
  }

  //Or crate in class Proxy
  public ImageLoaderProxy() {
    imageLoaderClass = new ImageLoaderClass();
  }

  @Override
  public Image getImage(String path) {
    if (cache.containsKey(path)) {

      //Get from cache

      System.out.println("\nGet from cache LOL :");
      return cache.get(path);
    }
    Image image = imageLoaderClass.getImage(path);
    cache.put(path, image);
    return image;
  }
}
```
```java
package Structural.Proxy.Example.Cached_proxy.Object;

public class Image {

  private String name;
  private int size;

  public Image(String name, int size) {
    this.name = name;
    this.size = size;
  }

  public String getName() {
    return name;
  }

  public int getSize() {
    return size;
  }

  @Override
  public String toString() {
    return "Image{" +
      "name='" + name + '\'' +
      ", size=" + size +
      '}';
  }
}
```
```java
package Structural.Proxy.Example.Protection_proxy.Account.Users;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

//Proxy
public class Guest implements InvocationHandler {

  private IUser user;

  public Guest(IUser user) {
    this.user = user;
  }

  @Override
  public Object invoke(Object proxy, Method method, Object[] args)
    throws IllegalAccessException {
    try {
      if (method.getName().startsWith("get") || method.getName().equals("upRang") || method
        .getName().equals("toString")) {
        return method.invoke(user, args);
      } else if (method.getName().startsWith("set")) {
        throw new IllegalAccessException("You can't change not your's info");
      }
    } catch (InvocationTargetException e) {
      e.printStackTrace();
    }
    //When we invoke another method, do nothing
    return null;
  }
}

```
```java
package Structural.Proxy.Example.Protection_proxy.Account.Users;

public interface IUser {

  String getNick();

  String getStatus();

  int getRang();

  void setNick(String nick);

  void setStatus(String status);

  void upRang();
}
```
```java
package Structural.Proxy.Example.Protection_proxy.Account.Users;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

//Proxy
public class Owner implements InvocationHandler {

  private IUser user;

  public Owner(IUser user) {
    this.user = user;
  }

  @Override
  public Object invoke(Object proxy, Method method, Object[] args)
    throws IllegalAccessException {
    try {
      if (method.getName().startsWith("get") || method.getName().startsWith("set") || method
        .getName().equals("toString")) {
        return method.invoke(user, args);
      } else if (method.getName().equals("upRang")) {
        throw new IllegalAccessException("You can't up rang");
      }
    } catch (InvocationTargetException e) {
      e.printStackTrace();
    }
    //When we invoke another method, do nothing
    return null;
  }
}

```
```java
package Structural.Proxy.Example.Protection_proxy.Account.Users;

public class User implements IUser {

  private String nick;
  private String status;
  private int rang = 0;

  public User(String nick, String status) {
    this.nick = nick;
    this.status = status;
  }

  public String getNick() {
    return nick;
  }

  public void setNick(String nick) {
    this.nick = nick;
  }

  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }

  public int getRang() {
    return rang;
  }

  public void upRang() {
    rang++;
  }

  @Override
  public String toString() {
    return "nick = '" + nick + '\'' +
      ", status='" + status + '\'' +
      ", rang=" + rang + '\n';
  }
}
```
```java
package Structural.Proxy.Example.Protection_proxy;

import Structural.Proxy.Example.Protection_proxy.Account.Users.Guest;
import Structural.Proxy.Example.Protection_proxy.Account.Users.IUser;
import Structural.Proxy.Example.Protection_proxy.Account.Users.Owner;
import Structural.Proxy.Example.Protection_proxy.Account.Users.User;
import java.lang.reflect.Proxy;

public class Ex {

  public static void main(String[] args) {
    Ex ex = new Ex();
    ex.accountTest();
  }

  public void accountTest() {
    IUser vlad = new User("Vlad", "Gay");
    IUser dima = getGuestProxy(vlad);
    vlad = getOwnerProxy(vlad);

    //!!! Be careful, do not wrap up Proxy in Proxy

    /*
    vlad = getOwnerProxy(vlad);
    IUser dima = getGuestProxy(vlad);
    */

    System.out.println(vlad.toString());

    vlad.setNick("Ivanovator");
    vlad.getRang();
    dima.getNick();
    dima.getStatus();

    System.out.println(vlad.toString());
    try {
      vlad.upRang();  //Can't

      dima.setStatus("loves Dima");  //Can't
    } catch (Exception e) {
      System.out.println("You need to have privileges");
    }

    dima.upRang();
    dima.upRang();
    dima.upRang();

    System.out.println(vlad.toString());


  }

  //Create dynamic proxy

  private IUser getOwnerProxy(IUser user) {

    return (IUser) Proxy.newProxyInstance(
      user.getClass().getClassLoader(),
      user.getClass().getInterfaces(),  //get All Interfaces which need implement
      new Owner(user));
  }

  private IUser getGuestProxy(IUser user) {

    return (IUser) Proxy.newProxyInstance(
      user.getClass().getClassLoader(),
      user.getClass().getInterfaces(),  //get All Interfaces which need implement
      new Guest(user));
  }
}
```
```java
package Structural.Proxy.Example.Virtual_proxy.DBConnection;

public interface DataBase {

  void connect();
}
```
```java
package Structural.Proxy.Example.Virtual_proxy.DBConnection;

public class DataBaseClass implements DataBase {

  private boolean connection = false;
  private String type = "MySQL";

  //We use connect() when we create new class.
  public DataBaseClass() {
    connect();
  }

  @Override
  public void connect() {

    //Some hard work, which need a lot of time.
    //Sometimes, can be never used.
    try {
      //Mock process
      Thread.sleep(2000);
      System.out.println("Data base was connected");
      connection = true;
    } catch (InterruptedException e) {
      e.printStackTrace();
    }

  }


  public String getType() {
    return type;
  }

  public boolean isConnection() {
    return connection;
  }
}
```
```java
package Structural.Proxy.Example.Virtual_proxy.DBConnection;

public class DataBaseProxy implements DataBase {

  private DataBaseClass dataBaseClass = null;

  //We can also send through constructor
  public DataBaseProxy(DataBaseClass dataBaseClass) {
    this.dataBaseClass = dataBaseClass;
  }

  //Or crate in class Proxy
  public DataBaseProxy() {
    //dataBaseClass = new DataBaseClass();
  }


  @Override
  public void connect() {
    if (dataBaseClass == null) {

      //Create Only when we need to something from class
      //We can do something before or after some operation with object

      System.out.println("Please, wait... ");
      dataBaseClass = new DataBaseClass();
    }

    if (dataBaseClass.isConnection()) {
      System.out.println("Connection is successful");
    }
  }

  //Also use method from DataBaseClass()
}
```
```java
package Structural.Proxy.Example.Virtual_proxy;

import Structural.Proxy.Example.Virtual_proxy.DBConnection.DataBase;
import Structural.Proxy.Example.Virtual_proxy.DBConnection.DataBaseProxy;

//For Lazy loading
public class Ex {

  public static void main(String[] args) throws InterruptedException {
    DataBase dataBaseCon = new DataBaseProxy();

    System.out.println("Not connect() when we create object");
    Thread.sleep(3000);
    dataBaseCon.connect();

    //Use connect after first connection
    dataBaseCon.connect();

  }

}
```
# Заместитель 

![UML](/src/AdditionalDocs/uml/Proxy.png)

Предоставляет суррогатный объект, управляющий доступом к другому объекту.

## Виды:

- [(Ex)](http://www.informit.com/articles/article.aspx?p=1398608) **Удалённый заместитель (*remote proxies*)**: обеспечивает связь с «Субъектом», который находится в другом адресном пространстве или на удалённой машине. Также может отвечать за кодирование запроса и его аргументов и отправку закодированного запроса реальному «Субъекту»;

- [(Ex)](/src/Structural/Proxy/Example/Virtual_proxy/) **Виртуальный заместитель (*virtual proxies*)**: **Lazy loading** обеспечивает создание реального «Субъекта» только тогда, когда он действительно понадобится. Также может кэшировать часть информации о реальном «Субъекте», чтобы отложить его создание;

- [(Ex)](/src/Structural/Proxy/Example/Protection_proxy/) **Защищающий заместитель (*protection proxies*)**: может проверять, имеет ли вызывающий объект необходимые для выполнения запроса права;

- [(Ex)](/src/Structural/Proxy/Example/Cached_proxy/) **Кэширующий прокси**: обеспечивает временное хранение результатов расчёта до отдачи их множественным клиентам, которые могут разделить эти результаты;

- **Копировать-при-записи**: обеспечивает копирование «субъекта» при выполнении клиентом определённых действий (частный случай «**виртуального прокси**»);

- **Протоколирующий прокси**: сохраняет в лог все вызовы «Субъекта» с их параметрами;

- **Экранирующий прокси**: защищает «Субъект» от опасных клиентов (или наоборот);

- **Синхронизирующий прокси**: производит синхронизированный контроль доступа к «Субъекту» в асинхронной многопоточной среде;

- ***«Умная»* ссылка (*smart reference proxy*)**: производит дополнительные действия, когда на «Субъект» создается ссылка, например, рассчитывает количество активных ссылок на «Субъект».

## Применимость

 - **Ленивая инициализация (виртуальный прокси)**. Когда у вас есть тяжёлый объект, грузящий данные из файловой системы или базы данных.

   - Вместо того чтобы грузить данные сразу после старта программы, можно сэкономить ресурсы и создать объект тогда, когда он действительно понадобится.

 - **Защита доступа (защищающий прокси)**. Когда в программе есть разные типы пользователей и вам хочется **защищать объект от неавторизованного доступа**. Например, если ваши объекты - это важная часть операционной системы, а пользователи - сторонние программы (хорошие или вредоносные).

   - Прокси может проверять доступ при каждом вызове и передавать выполнение служебному объекту, если доступ разрешён.

 - **Локальный запуск сервиса (удалённый прокси)**. Когда настоящий сервисный объект находится на удалённом сервере.

   - В этом случае заместитель транслирует запросы клиента в вызовы по сети, в протоколе, понятном удалённому сервису.

 - **Логирование запросов (логирующий прокси)**. Когда требуется хранить историю обращений к сервисному объекту.

   - Заместитель может сохранять историю обращения клиента к сервисному объекту.

 - **Кеширование объектов («умная» ссылка)** (Похоже на [Объектный пул][Object_Pool]) Когда нужно кешировать результаты запросов клиентов и управлять их жизненным циклом.

   - **Заместитель может подсчитывать количество ссылок на сервисный объект**, которые были отданы клиенту и остаются активными. Когда все ссылки освобождаются - можно будет освободить и сам сервисный объект (например, закрыть подключение к базе данных).

     Кроме того, **Заместитель** может отслеживать, не менял ли клиент сервисный объект. Это позволит использовать объекты повторно и сильно экономить ресурсы, особенно если речь идёт о больших прожорливых сервисах.

## Шаги реализации

1. Определите интерфейс, который бы сделал заместитель и оригинальный объект взаимозаменяемыми.

2. Создайте класс заместителя. Он **должен содержать ссылку на сервисный объект**. Чаще всего, сервисный объект создаётся самим заместителем. В редких случаях, заместитель получает готовый сервисный объект от клиента через конструктор.

3. Реализуйте методы заместителя в зависимости от его предназначения. В большинстве случаев, проделав какую-то полезную работу, **методы заместителя должны передать запрос сервисному объекту**.

4. **Подумайте о введении фабрики, которая решала бы какой из объектов создавать - заместитель или реальный сервисный объект**. Но с другой стороны, эта логика может быть помещена в создающий метод самого заместителя.

5. Подумайте, не реализовать ли вам **ленивую инициализацию сервисного объекта при первом обращении клиента к методам заместителя**.

## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |Позволяет **контролировать сервисный объект незаметно для клиента**.|Увеличивает время отклика от сервиса.
 |Может работать, даже если сервисный объект ещё не создан.|Усложняет программу за счёт дополнительных классов.
 |Может **контролировать жизненный цикл служебного объекта**.
  
 ## Отношения с другими паттернами

- [**Адаптер**][Adapter] предоставляет классу *альтернативный интерфейс*. [**Декоратор**][Decorator] предоставляет *расширенный интерфейс*. **Заместитель** предоставляет тот же интерфейс.

- [**Фасад**][Facade] похож на **Заместитель** тем, что замещает сложную подсистему и может сам её инициализировать. Но в отличие от [**Фасада**][Facade], **Заместитель** имеет тот же интерфейс, что его служебный объект, благодаря чему их можно взаимозаменять.

- [**Декоратор**][Decorator] и **Заместитель** имеют похожие структуры, но разные назначения. Они похожи тем, что оба построены на композиции и делегировании работы другому объекту. Паттерны отличаются тем, что **Заместитель** сам управляет жизнью сервисного объекта, а обёртывание [**Декораторов**][Decorator] контролируется клиентом.

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Object_Pool]: </src/Creational/Object_Pool/Object_Pool.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
