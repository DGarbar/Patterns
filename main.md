# Принципы проектирования
(НЕ ЗАКОНЫ)

* **Изменяемые аспекты** приложения должны быть **отделенны** от постоянных;

* Программировать на уровне **интерфейсов**, а не на уровне реализаций;

* [**Композиция**][Composition]* лучше наследования;

* Стремиться к [**слабой связанности**][LowCoupling]* взаимодействующих объектов;

  - Выделять уровень абстракции, чтобы работать с **супер типом** (Полиморфизм)
  
* Используйте только одну точку. `(Class.method())`[**Принцип минимальной информированности**][Demetra];
  
## Solid
 
* У класса должна быть только 1 обязанность. Только 1 причина для изменения. [**Single Responsibility S_olid**][SRP];

* Классы открыты для расширения, но закрыты для изменения. [**Open/closed s_O_lid**][OCP];

* Наследующий класс должен дополнять, а не замещать поведение базового класса. [**Liskov Substitution so_L_id**][LSP];

* Клиенты не должны зависеть от методов, которые они не используют. [**Interface Segregation sol_I_d**][ISP];

* [**Инверсия управления (Голливудский принцип)**][IoC] ->>> [**Dependency-Inversion soli_D**][DIP];

## Ключевые принципы

* Don’t repeat yourself - [DRY][DRY];

* Keep it simple stupid - [KISS][KISS];

* You ain’t gonna need it - [YAGNI][YAGNI];

## Паттерны проектирования 

 | [**Порождающие**][Creational]: удобное и безопасное **создание** новых объектов | [**Структурные**][Structural]: **построение** удобных в поддержке иерархий классов | [**Поведенческие**][Behavioral]: эффективного и безопасного **взаимодействия** между объектами программы |
 | :------: | :------: |:------: |
 | [**Фабричный метод**][Factory_Method] | [**Адаптер**][Adapter] | [**Цепочка обязанностей**][Chain_of_Responsibility] |
 | [**Абстрактная фабрика**][Abstract_Factory] | [**Мост**][Bridge] | [**Команда**][Command] |
 | [**Строитель**][Builder] | [**Компоновщик**][Composite] | [**Итератор**][Iterator] |
 | [**Пул объектов**][Object_Pool] |[**Декоратор**][Decorator] | [**Посредник**][Mediator] |
 | [**Прототип**][Prototype] | [**Фасад**][Facade] | [**Снимок**][Memento] |
 | [**Одиночка**][Singleton] | [**Легковес**][Flyweight] | [**Наблюдатель**][Observer] |
 |  | [**Заместитель**][Proxy] |[**Состояние**][State] |
 |  | [**Выделение частного класса данных**][Private_Class_Data] |  [**Стратегия**][Strategy] |
 |  |  | [**Шаблонный метод**][Template_Method] |
 |  |  | [**Посетитель**][Visitor] |
 |  |  | [**Null объект**][Null_Object] |
 
 
[DRY]: </src/AdditionalDocs/DRY.md>
[KISS]: </src/AdditionalDocs/KISS.md>
[YAGNI]: </src/AdditionalDocs/YAGNI.md>

[BindingTypes]: </src/AdditionalDocs/BindingTypes/>  
[LowCoupling]: </src/AdditionalDocs/LowCoupling.md>
[Composition]: </src/AdditionalDocs/Composition.md>
[Demetra]: </src/AdditionalDocs/Principle_of_Least_Knowledge.md>
[IoC]: </src/AdditionalDocs/Inversion_of_Control.md>
[God-Object]: </src/AdditionalDocs/AntiPatterns/God-Object.md>
[SRP]: </src/AdditionalDocs/SOLID/Single_Responsibility_principle.md>
[OCP]: </src/AdditionalDocs/SOLID/Open-Closed_principle.md>
[LSP]: </src/AdditionalDocs/SOLID/Liskov_Substitution_principle.md>
[ISP]: </src/AdditionalDocs/SOLID/Interface_Segregation_principle.md>
[DIP]: </src/AdditionalDocs/SOLID/Dependency_Inversion_principle.md>


[Creational]: </src/Creational/>
[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Object_Pool]: </src/Creational/Object_Pool/Object_Pool.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Structural]: </src/Structural/>
[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>
[Private_Class_Data]: </src/Structural/Private_Class_Data/Private_Class_Data.md>


[Behavioral]: </src/Behavioral/>
[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
[Null_Object]: </src/Behavioral/Null_Object/Null_Object.md>

# Объект-бог

**Объект-бог** (God object) - антипаттерн объектно-ориентированного программирования, описывающий объект, который **хранит в себе «слишком много» или делает «слишком много»**.
***

Вместо того, чтобы общаться друг с другом непосредственно, другие объекты полагаются на божественный объект. Так как на божественный объект ссылается так много кода, его обслуживание (внесение изменений) становится сложным: велик риск сломать существующую функциональность.


Хотя божественные объекты считаются плохой практикой программирования, поскольку вредят поддерживаемости кода, **они могут быть полезны для работы при ограниченных ресурсах** (в микроконтроллерах или мобильных телефонах), где производительность важнее, чем поддерживаемость кода.

# Двойная диспетчеризация

**Двойная диспетчеризация** (double dispatch) - это трюк, позволяющий **обойти ограниченность раннего связывания в перегруженных методах**.
***

Вот как это делается:

```
class Visitor is
    method visit(s: Shape) is
        print("Visited shape")
    method visit(d: Dot)
        print("Visited dot")

interface Graphic is
    method accept(v: Visitor)

class Shape implements Graphic is
    method accept(v: Visitor)
        // Компилятор знает, что здесь `this` это `Shape`.
        v.visit(this)

class Dot extends Shape is
    method accept(v: Visitor)
        // Компилятор знает, что здесь `this` это `Dot`.
        // А значит можно статически связать этот вызов
        // с реализацией visit(d: Dot).
        v.visit(this)


Visitor v = new Visitor();
Graphic g = new Dot();

// Метод accept() – переопределен, но не перегружен. А значит, связан
// динамически. Поэтому реализация `accept` будет выбрана во время выполнения 
// уже из того класса, объект которого его вызвал (класс Dot).
g.accept(v);

// Выведет "Visited dot".
```

# Early binding, Static Binding
Присоединение вызова метода к телу метода называется связыванием.

- **Раннее**, потому что оно происходит ещё на этапе компиляции программы.
- **Статическое**, потому что его уже не изменить во время выполнения.
***

```
method exportShape(shape: Shape) is
    Exporter exporter = new Exporter()
    exporter.export(shape);
```
 В классе `Exporter` у нас есть пять версий метода с таким именем, которые **отличаются только типом параметра**. Похоже, здесь тоже придётся динамически отслеживать тип передаваемого параметра и по нему определять какой из методов выбрать.

Но здесь нас ждёт засада. Что если кто-то подаст в метод `exportShape` такой объект, для которого не существует метода `export(<?>)` в классе  `Exporter`? Например, объект `Ellipse`, для которого у нас нет экспорта. Действительно, у нас **нет гарантии что необходимый метод будет существовать, как это было с переопределенными методами. А значит, возникнет неоднозначная ситуация**.

Именно поэтому все **разработчики компиляторов выбирают безопасную тропинку и применяют раннее или статическое связывание для перегруженных методов**:

Вернемся к нашему примеру. Мы уверены в том, что имеем параметр с типом `Shape`. Мы знаем что в `Exporter` существует подходящая реализация: `export(s: Shape)`. Значит, этот участок кода мы жёстко связываем с известной реализацией метода.

**И поэтому даже если мы подадим в параметрах один из подклассов `Shape`, всё равно будет вызвана реализация `export(s: Shape)`.**

**(Грубо говоря, следить надо за ссылкой, а не за `new Object()`)**

**Для всех методов Java используется механизм позднего связывания, если только метод не был объявлен как `private` и в ситуациях описанных ниже**. Вызов `private` метода компилируется в инструкцию байт-кода *invokespecial*, которая вызывает реализацию метода из конкретного класса, определенного в момент компиляции. Вызов метода с другим уровнем доступа компилируется в *invokevirtual*, которая уже смотрит на тип объекта по ссылке в момент исполнения. Финальные неприватные методы тоже вызываются через *invokevirtual*.

**В инструкцию байт-кода *invokespesial* (Early) компилируются**:

- Инициализационный вызов (`<init>`) при создании объекта???

- Вызов `private` метода

- `static method`

- `final`

- Overload method

- Вызов метода с использованием ключевого слова `super`

- constructor

```java
public class Root{
  private void prt(){System.out.println("Root");}
  public static void main(String[] args){
    Root root = new Branch();
    root.prt(); // Root
    Branch branch = (Branch) root;
    branch.prt(); // Branch
  }
}
class Branch extends Root{
  final void prt() {System.out.println("Branch");}
}
```

# Dynamic binding, Runtime binding

Присоединение вызова метода к телу метода называется связыванием.

- **Поздним**, потому что мы связываем объект и реализацию уже после компиляции.
- **Динамическим**, потому что мы делаем это при каждом прохождении через этот участок.
***

```
class Exporter is
    method export(s: Shape) is
        print("Exporting shape")
    method export(d: Dot)
        print("Exporting dot")
    method export(c: Circle)
        print("Exporting circle")
    method export(r: Rectangle)
        print("Exporting rectangle")
    method export(cs: CompoundGraphic)
        print("Exporting compound")
```

Кажется, что всё хорошо. Но давайте испробуем такой класс в деле:

```
class App() is
    method export(shape: Shape) is
        Exporter exporter = new Exporter()
        exporter.export(shape);

app.export(new Circle());
// К сожалению, выведет "Exporting shape".
```

Итак, вызов метода `draw` в классе `Shape`. Но нам известно ещё и о четырёх классах переопределяющих этот метод. Можно ли уже сейчас понять какую реализацию нужно выбрать? Похоже, что нет, ведь для этого придётся запустить программу и узнать какой же объект будет подан в параметр. Но одно вы знаете точно — какой бы объект ни был передан, он точно будет иметь реализацию `draw`. *(Для примера, можно заполнять массив через рандом фигур)*

В результате машинный код, который вы создадите, будет **каждый раз при проходе через этот участок проверять что за объект этот `s`**, и выбирать реализацию метода `draw` из соответствующего класса.


```java
class King {
    King() {
        System.out.println("Call King constructor");
        speech();   //polymorphic method overriden in AerysTargaryen 
    } 
    public void speech() {
        System.out.println("I'm the King of the Andals!");
    }
}
 
class AerysTargaryen extends King {
    private String victimName;
 
    AerysTargaryen() {
        System.out.println("Call Aerys Targaryen constructor");
        victimName = "Lyanna Stark";
        speech();
    }
 
    @Override
    public void speech() {
        System.out.println("Burn " + victimName + "!");
    }
}
 
class Kingdom {
    public static void main(String[] args) {
        King king = new AerysTargaryen();
    }
}
```
Результат работы программы обусловлен выполнение алгоритма инициализации объекта:

1. Память, выделенная под новый объект, заполняется двоичными нулями.

2. Конструкторы базовых классов вызываются по иерархии. В этот момент вызывается переопределенный метод `speech()` ( перед вызовом конструктора класса `AerysTargaryen`), где обнаруживается, что переменная `victimName` равна null из-за первого этапа.

3. Вызываются инициализаторы членов класса в порядке их определения.

4. Исполняется тело конструктора производного класса.

**В частности из-за таких поведенческих моментов стоит придерживаться следующего правила написания конструкторов:**

 - **выполняйте в конструкторе лишь самые необходимые и простые действия по инициализации объекта**;
 
 - **по возможности избегайте вызова методов, не определенных как `private` или `final` (что в данном контексте одно и то же)**. 

# Композиция

Повторное использование кода может быть достигнуто с помощью как наследования, так и композиции.
Но при этом **задействование композиции обеспечивает более высокий уровень инкапсуляции**, чем наследование,
так как изменения в back-end классе не обязательно затронут код, который относится к front-end классу.

**Композиция** - это техника проектирования, применяющая в классах отношения типа **«has a»** (имеет, включает в себя).
Для повторного использования кода могут применяться как наследование в java, так и композиция объекта.
***

## Суть композиции 

Заключается в выражении отношения **«has a»** между объектами.
Подумайте о стуле. У стула есть (has a) сидение. У стула есть (has a) спинка. У стула есть (has a) определенное количество ножек.
Фраза "has a" / "есть" предполагает отношения, в которых стул имеет или, как минимум, использует другой объект. Это как раз и есть отношения "has a", являющиеся основой композиции.

#### Преимущества

* Контроль видимости;
* Реализация может быть заменена во время выполнения (run-time);
* [**Слабая связанность**][LowCoupling]*, так как класс-интерфейс не зависит от реализации.

### Различия между композицией и наследованием

| Композиция (has a / имеет) | Наследование (is a / является) |
| ------ | ------ |	
|	Поддерживает полиморфизм и повторное использование кода. | Поддерживает полиморфизм и повторное использование кода.|
|	Объект во время выполнения (run-time) уже создан.|	Объект создается динамически во время компиляции.|
|	Реализация может быть заменена во время выполнения (run-time).| Реализация может быть заменена во время компиляции.|
|	Подкласс не зависит от класса-родителя, что благоприятствует слабому связыванию (особенно под управлением интерфейса).|	Подкласс зависит от реализации класса-родителя, поэтому связывание считается сильным.|
|	В Доме есть Ванная комната. Неправильно говорить, что Дом - это Ванная комната.|	Наследование является однонаправленным: Дом - это Здание. Но здание не является домом.|

**!!! Не используйте наследование только для того, чтобы обеспечить повторное использование кода.
Если **нет отношений “is a“** (является), для этих целей используется **композиция**.**

### Разница между композицией и агрегацией в отношениях объектов.

**Агрегация (Делегирование)** - это взаимосвязь, при которой один класс вписывается в коллекцию. Это часть целого отношения, где **часть может существовать без целого**. Такие отношения гораздо слабее. Нет циклической зависимости. Например: **заказ и продукт**.
 - Один **объект получает ссылку (указатель)** на другой объект в процессе конструирования.
 
**Композиция** - это взаимосвязь, при которой один класс вписывается в коллекцию. Это часть целого отношения, **при которой часть не может существовать без целого**. Если целое уничтожается, все его составляющие тоже будут уничтожены. Это более сильные отношения. Например: многоугольник и его вершины, **заказ и его компонент**.
 - Один **объект создает другой объект** и время жизни "части" зависит от времени жизни целого.

[LowCoupling]: <LowCoupling.md>

# DRY – Don’t repeat yourself (не повторяй себя)

(DIE - Duplication is Evil)

- Принцип разработки программного обеспечения, нацеленный на **снижение повторения информации различного рода**, особенно в системах со множеством слоёв абстрагирования.
***

Когда принцип **DRY** применяется успешно, изменение единственного элемента системы не требует внесения изменений в другие, логически не связанные элементы.

**DRY** всегда приводит к декомпозиции сложных алгоритмов на простые функции. А декомпозиция сложных операций на более простые (и повторно используемые) значительно упрощает понимание программного кода. **Повторное использование функций, вынесенных из сложных алгоритмов, позволяет сократить время разработки и тестирования новой функциональности.**

Доступ к конкретному функционалу должен быть доступен в одном месте, унифицирован и сгруппирован по какому-либо принципу, а не «разбросан» по системе в произвольных вариациях.

Нарушения принципа **DRY** называют **WET** — *«Write Everything Twice»* или *"We enjoy typing"*.

# Инверсия управления (Голливудский принцип)

**Inversion of Control** - это некий абстрактный принцип, набор рекомендаций для написания слабо связанного кода. Суть которого в том, что каждый компонент системы должен быть **как можно более изолированным от других**, не полагаясь в своей работе на детали конкретной реализации других компонентов.
***

**Компоненты высокого уровня не должен зависеть от компонентов низкого уровня.**

Все подходы, основанные на инверсии управления, страдают от следующих **двух недостатков**:

 - Логика взаимодействия программы разбросана по отдельным обработчикам событий или классам;
 
 - Поток управления задан неявно и использует общее состояние (shared state) обработчиков событий.
 
 **Одной из реализаций IoC в применении к управлению зависимостями является [**внедрение зависимостей**][DIP]**. Внедрение зависимости используется во многих фреймворках, которые называются **IoC-контейнерами**.
 
 [DIP]: </src/AdditionalDocs/SOLID/Dependency_Inversion_principle.md>

# KISS - keep it simple stupid (делайте вещи проще)

- Принцип проектирования и программирования, при котором **простота системы декларируется в качестве основной цели или ценности**.
***

#### Правила

- Разбивайте **задачи на подзадачи** которые не должны по вашему мнению длиться более 4-12 часов написания кода.

- Разбивайте задачу на множество более маленьких задач, каждая задача должна решаться одним или парой классов.

- Сохраняйте ваши методы маленькими. Каждый **метод должен состоять не более чем из 30-40 строк**. Каждый метод должен решать одну маленькую задачу, а не множество случаев. **Если в вашем методе множество условий, разбейте его на несколько. Это повысит читаемость, позволит легче поддерживать код и быстрее находить ошибки в нём.** Вы полюбите улучшать код.

- Сохраняйте ваши классы маленькими. Здесь применяется та же техника что и с методами.

- Придумайте **решение задачи сначала, потом напишите код**. Никогда не поступайте иначе. Многие разработчики придумывают решение задачи во время написания кода и в этом нет ничего плохого. Вы можете делать так и при этом придерживаться выше обозначенного правила. Если вы можете в уме разбивать задачу на более мелкие части, когда вы пишете код, делайте это любыми способами. И **не бойтесь переписывать код ещё и ещё и ещё…** В счёт не идёт число строк, до тех пор пока вы считаете что можно ещё меньше/ещё лучше.

- **Не бойтесь избавляться от кода**. Изменение старого кода и написание нового решения два очень важных момента. Если вы столкнулись с новыми требованиями, или не были оповещены о них ранее, тогда порой лучше придумать новое более изящное решение решающее и старые и новые задачи.


# Слабая связанность

**Связность** (coupling) - это взаимная зависимость реализации классов между собой, то есть индикатор количества изменений, которые нужно внести в классы при изменении одного класса. 

**Слабая связность означает, что изменения, вносимые в один класс повлекут за собой небольшие изменения в другие классы, то есть упростит рефакторинг кода, при необходимости**. 
***

 Самый простой пример уменьшения связности кода - это не использовать для классов открытые (public) поля, вместо чего следует использовать модификаторы доступа - геттеры и сеттеры. Таким образом, при изменении названия поля внутри класса не понадобится переписывать код где-либо еще.

Все придуманные шаблоны проектирования (design patterns) придуманы именно для того, чтобы снижать связность кода.

**Определяется по сложности (количеству необходимых изменений) которые возникают
при расширении.**

# Принцип минимальной информированности (Закон Деметры)

!!! Может быть перефразирован как **«Используйте только одну точку»** 

Каждый программный модуль должен:

- обладать ограниченным знанием о других модулях: знать о модулях, которые имеют «непосредственное» отношение к этому модулю.

- взаимодействовать только с известными ему модулями «друзьями», не взаимодействовать с незнакомцами.

- обращаться только к непосредственным «друзьям».
***

**Аналогия из жизни**: Если вы хотите, чтобы собака побежала, глупо командовать её лапами, лучше отдать команду собаке, а она уже разберётся со своими лапами сама.

Основной идеей является то, что **объект должен иметь как можно меньше представления о структуре и свойствах чего угодно** (включая собственные подкомпоненты).


В объекте можно вызывать методы принадлежащие только:

- самому объекту;

- объектам, переданным в параметрах метода;

- любому объекту созданному внутри метода;

- любим компонентам объекта ([**Композиция**][Composition]).

[Composition]: </src/AdditionalDocs/Composition.md> 

# Dependency Inversion Principle

**Принцип инверсии зависимостей (Dependency inversion principle, DIP)**

- Код должен зависеть от абстракций, а не от конкретных классов; 

  Класс, в котором используется `new`, автоматически становится зависимым от этой конкретной реализации, а не от абстракции

- Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций;

- Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
***

Рассмотрим классическую трехзвенную архитектуру:

![UML](/src/AdditionalDocs/uml/SOLID/DIP/noDIP.png)

**Высокоуровневые модули приложения не отделены от низкоуровневых реализаций**. Абстракции не отделены от деталей. Изменение логики в слое доступа к данным может неожиданно привести к поломке в модуле отображения. Тестировать такую систему будет очень сложно. Даже если получится написать модульные тесты, то любое изменение в системе приведет к тому, что эти тесты придется переписывать. В результате эта система обладает характеристиками:

1. **Жесткость**

     Тяжело менять систему, потому что каждое изменение затрагивает очень много различных ее частей.

2. **Хрупкость**

      Когда вы вносите изменения в одну часть системы, то в неожиданном месте ломается другая.

3. **Неподвижность**

      Очень сложно повторно использовать код в другом приложении, потому что модули сильно связаны между собой.

К чему мы пришли:

![UML](/src/AdditionalDocs/uml/SOLID/DIP/DIP.png)

В данном случае каждый слой отдельно представлен абстрактными классами/интерфейсами. Сам слой наследуется от этого абстрактного слоя (например, *Business Layer* реализует интерфейсы, которые объявлены в *Business Layer Abstract*). Все классы верхнего уровня используют нижележащий уровень через его абстрактный слой. Таким образом ни один слой не зависит от деталей другого. Напротив, они зависят только от абстракций.

Тут есть вопрос по реализации. Как класс из *UI Layer* узнает во время исполнения программы, какую реализацию надо использовать? 

1. Передача в конструктор или метод Set___(___ ___);

2. Создание фабрики.

<http://blog.byndyu.ru/2009/12/blog-post.html>

# Interface Segregation Principle

**Принцип разделения интерфейса (Interface Segregation Principle, ISP)**

- Клиенты не должны зависеть от методов, которые они не используют.
***

Принцип разделения интерфейсов говорит о том, что **слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические**, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.

# Liskov Substitution Principle

**Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP)**

- Пусть `q(x)` является свойством, верным относительно объектов `x` некоторого типа `T`. Тогда `q(y)` также должно быть верным для объектов `y` типа `S`, где `S` является подтипом типа `T`.

или

- Наследующий класс должен дополнять, а **не замещать поведение базового класса**.

или

- Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.
***

**Замещения** - если `S` является подтипом `T`, тогда объекты типа `T` в программе могут быть замещены объектами типа `S` без каких-либо изменений желательных свойств этой программы.

Более простыми словами можно сказать, что **поведение наследуемых классов не должно противоречить поведению, заданному базовым классом**, то есть поведение наследуемых классов должно быть ожидаемым для кода, использующего переменную базового типа.

 *«Подкласс не должен требовать от вызывающего кода больше, чем базовый класс, и не должен предоставлять вызывающему коду меньше, чем базовый класс»* (Саттер и Александреску)
 
 
 

# Open-Closed Principle

**Принцип открыт/закрыт (Open-Closed Principle, OCP)**

Программные сущности (классы, модули, функции и т. п.) должны быть **открыты для расширения, но закрыты для модификации**.

 - **Они открыты для расширения**.
  
      Это означает, что поведение модуля можно расширить. Когда требования к приложению изменяются, мы добавляем в модуль новое поведение, отвечающее изменившимся требованиям. Иными словами, мы можем изменить состав функций модуля.
 
 - **Они закрыты для модификации**. 
 
     Расширение поведения модуля не сопряжено с изменениями в исходном или двоичном коде модуля. **Двоичное исполняемое представление модуля, будь то компонуемая библиотека, DLL или EXE-файл, остается  неизменным**.
 ***
 
 При этом понятия открытости и закрытости определяются так:
 
  - **Модуль называют открытым**, если он еще доступен для расширения. Например, имеется возможность расширить множество операций в нем или добавить поля к его структурам данных.
  
  - **Модуль называют закрытым**, если он доступен для использования другими модулями. Это означает, что модуль (его интерфейс - с точки зрения скрытия информации) уже имеет **строго определенное окончательное описание**. На уровне реализации закрытое состояние модуля означает, что модуль можно компилировать, сохранять в библиотеке и делать его доступным для использования другими модулями (его клиентами).
  
 Но всегда ли нам нужно создавать наследника? Нет, не всегда! Даже такой ОО-гуру как Мейер, который описывает в своей книге 12 видов наследования, относится к расширяемости модулей путем создания наследников с разумным прагматизмом: 
 
 *«Если имеется возможность переписать исходную программу так, чтобы она, без излишнего усложнения, смогла удовлетворять потребности нескольких разновидностей клиентов, то следует это сделать»*.
  
 Естественно, модуль должен модифицироваться при наличии в нем ошибок: 
 
 *«Как принцип Открыт-Закрыт, так и переопределение в механизме наследования не позволяет справиться с дефектами разработки, не говоря уже об ошибках в программе. **Если в модуле что-то не в порядке, то следует это сразу исправить в исходной программе**, не пытаясь разбираться возникающей проблемой в производном модуле»*
 
 
 
 ## Принцип единственного выбора
 
 ```
 abstract class Importer
 {
     public abstract void ImportData();
 }
  
 static class ImporterFactory
 {
     public static Importer Create(string fileName)
     {
         Contract.Requires(!string.IsNullOrEmpty(fileName));
         Contract.Ensures(Contract.Result<Importer>() != null);
  
         var extension = Path.GetExtension(fileName);
         switch (extension)
         {
             case "json":
                 return new JsonImporter();
             case "xls":
             case "xlsx":
                 return new XlsImporter();
             default:
                 throw new InvalidOperationException(
                   "Extension is not supported");
         }
     }
 ```
 
 Отвечает ли реализация такой фабрики принципу **Open/Close**? Или для соответствия этому принципу нам нужно вводить интерфейс `IImporterFactory` и еще одну иерархию - иерархию фабрик? А кто будет создавать фабрику? С помощью фабрики фабрик?
 
 [**Фабричный метод**][Factory_Method] сам по себе и так уже прячет от своих клиентов способ получения нужного `Importer`-а и дополнительный уровень косвенности здесь не нужен.
 
 Вот что пишет Бертран Мейер по этому поводу: 
 
 *«Необходимо допускать возможность того, что **список вариантов**, заданных и известных на некотором этапе разработки программы, может **в последующем быть изменен** путем добавления или удаления вариантов. Чтобы обеспечить реализацию такого подхода к процессу разработки программного обеспечения, нужно найти способ защитить структуру программы от воздействия подобных изменений. Отсюда следует принцип **Единственного Выбора**»*
 
 **Принцип единственного выбора**: всякий раз, когда система программного обеспечения должна поддерживать множество альтернатив, их **полный список должен быть известен только одному модулю системы**.
 
 ## Какую проблему призван решить принцип Открыт/Закрыт?
 
 Смысл принципа OCP довольно прост: дизайн системы должен быть простым и устойчивым к изменениям.
 
  - **Во-первых, за счет абстракции и инкапсуляции**. Мы выделяем существенные части системы в виде интерфейсов и абстрактных классов, не задумываясь о реализации, которая будет скрыта от клиентов. Но даже конкретный класс, унаследованный от `System.Object` представляет собой абстракцию. Класс `String` абстрагирует нас от конкретного представления строки и многих других подробностей, хотя и не реализует интерфейс `IString`.
 
    Любой класс моделирует абстракцию: его **открытый интерфейс акцентирует внимание на важной составляющей класса**, оставляя в закрытой части ненужные подробности. Это позволяет думать о классе, как о черном ящике, который представляет определенные услуги лишь ему известным способом.
 
  - **Во-вторых, за счет наследования**. Мы используем наследование для полиморфного поведения, что позволяет использовать базовые классы в подавляющем числе мест приложения, а также использовать повторно значительные куски кода.
  
  !!!
 **Абстракция не подразумевает наличие наследования. Абстракция не может существовать без инкапсуляции!** *(книга Гради Буча «Объектно-ориентированный анализ и проектирование»)
  
 ## Заключение
 **Что такое OCP?** Это фиксация интерфейса класса/модуля, и возможность изменения или подмены реализации/поведения.
 
 **Цели OCP**: Борьба со сложностью и ограничение изменений минимальным числом модулей.
 
 **Как мы реализуем OCP?** С помощью инкапсуляции. Она позволяет изменять реализацию без изменения интерфейса и с помощью наследования. Наследование уже в свою очередь позволяет заменить реализацию, которая не затронет существующих клиентов базового класса.
 
 
 [Factory_Method]:</src/Creational/Factory_Method/Factory_Method.md>

# Single Responsibility Principle

**Принцип единственной ответственности (The Single Responsibility Principle, SRP)**

- **Каждый объект должен иметь одну ответственность и эта ответственность должна быть полностью инкапсулирована в класс**. Все его поведения должны быть направлены исключительно на обеспечение этой ответственности.

**Robert C. Martin определяет ответственность как причину изменения и заключает, что классы должны иметь одну и только одну причину для изменений**. 
***

Например, представьте себе класс, который составляет и печатает отчёт. Такой класс может измениться по двум причинам:

- может измениться само содержимое отчёта;

- может измениться формат отчёта.

Логично, что оба аспекта этих причин на самом деле являются двумя разными ответственностями. **SRP** говорит, что в таком случае нужно **разделить класс на два новых класса, для которых будет характерна только одна ответственность**. Причина, почему нужно сохранять направленность классов на единственную цель в том, что это делает классы более здоровыми. Что касается класса, приведённого выше, если произошло изменение в процессе составления отчёта - есть большая вероятность, что в негодность придёт код, отвечающий за печать.

## Использование 
Возникает вопрос, когда стоит использовать этот принцип? Всё же **принцип - это не закон и SRP стоит применять в зависимости от того, как изменяется приложение**:

- если **при изменении кода, отвечающего за одну ответственность, в приложении появляются исправления кода, отвечающего за другую ответственность**, то это первый сигнал о нарушении SRP.

  - если же изменения кода, отвечающего за одну ответственность, не вносят изменения в код, отвечающий за другую ответственность, то этот принцип можно не применять.
  
**Слепое следование принципу единственной ответственности приводит к избыточной сложности приложения, его поддержки и тестированию.**SRP** стоит применять только тогда, когда это оправдано.**
 
 Принцип **SRP** можно применить только в том случае, когда:

- объекту класса становится позволительно слишком много;

- доменная логика концентрируется только в одном классе;

- любое изменение логики поведения объекта приводит к изменениям в других местах приложения, где это не подразумевалось изначально;

- приходится тестировать, исправлять ошибки, компилировать различные места приложения, даже если за их работоспособность отвечает третья сторона;

- невозможно легко отделить и применить класс в другой сфере приложения, так как это потянет ненужные зависимости.  

# You ain’t gonna need it (Вам это не понадобится)

- [**KISS**][KISS] старается искать простые решения, а **YAGNI** просто не делает никаких решений!

- В качестве основной цели и/или ценности декларируется **отказ от избыточной функциональности, - то есть отказ добавления функциональности, в которой нет непосредственной надобности**.
***

#### Планирование проекта

Начиная планирование нового проекта, постарайтесь учесть следующее:

- Достичь меньшей сложности путем уменьшения уровня абстракций.

  Подумайте, вам действительно нужен Hibernate? Старайтесь тщательнее оценивать все, что может добавить сложности вашей системе. Учтите, что зачастую многие абстракции реализовываются в сторонних продуктах и библиотеках. Каждая из новых библиотек добавляет сложности. Обновления, патчи, исправления в безопасности - все это вам придется делать/применять в будущем.

- Разделить функционал от возможностей (features).

- Учесть небольшие не-функциональные требования.

- Определить затратные по времени задачи, чтобы избавиться от них.

#### Последствия YAGNI

- **Тратится время**, которое было бы затрачено на добавление, тестирование и улучшение необходимой функциональности.

- Новые функции должны быть отлажены, документированы и сопровождаться.
Новая функциональность ограничивает то, что может быть сделано в будущем, - **ненужные новые функции могут впоследствии помешать добавить новые нужные**.

  Если вся функциональность не документирована, она может так и остаться неизвестной пользователям, но может создать для безопасности пользовательской системы различные риски.

- Пока новые функции действительно не нужны, **трудно полностью предугадать, что они должны делать, и протестировать их**. Если новые функции тщательно не протестированы, они могут неправильно работать, когда впоследствии понадобятся.

- Это приводит к тому, что программное обеспечение становится более сложным (подчас чрезмерно сложным).

- Добавление новой функциональности может **привести к желанию ещё более новой функциональности, приводя к эффекту «снежного кома».**


**Также важно понимать, что все это вовсе не значит, что можно сесть и писать плохой код**, приправленный хаками. Вы просто пишете небольшое приложение, а не плохое! Можно согласиться на немного возросшие затраты по поддержке - мы живем в реальном мире.

[KISS]: </src/AdditionalDocs/KISS.md>

# Цепочка обязанностей 

![UML](/src/AdditionalDocs/uml/Chain_of_Responsibility.png)

Позволяет **передавать запросы последовательно по цепочке обработчиков**. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.

## Применимость

- Когда **программа содержит несколько объектов, способных обработать тот или иной запрос, однако заранее неизвестно какой запрос придёт и какой обработчик понадобится**.

  - Вы связываете потенциальных обработчиков в одну цепь и поочерёдно спрашиваете, хочет ли данный объект обработать запрос. Если нет, двигаетесь дальше по цепочке.

- Когда важно, чтобы **обработчики выполнялись один за другим в строгом порядке**.

  - Цепочка обязанностей позволяет запускать обработчики последовательно один за другим в определённом порядке.

- Когда **набор объектов, способных обработать запрос, должен задаваться динамически**.

  - В любой момент вы можете вмешаться в существующую цепочку и **переназначить связи так, чтобы убрать или добавить новое звено**.

## Шаги реализации

1. Создайте **интерфейс обработчика** и опишите в нём основной метод обработки.

   Продумайте, в каком виде клиент должен передавать данные запроса в обработчик. **Самый гибкий способ** - *превратить данные запроса в объект и передавать его целиком через параметры метода обработчика*.

2. Имеет смысл создать **абстрактный базовый класс обработчиков**, чтобы не дублировать **реализацию метода получения следующего обработчика** во всех конкретных обработчиках.

   Добавьте в базовый обработчик **поле для хранения ссылки на следующий объект цепочки**. Устанавливайте **начальное значение этого поля через конструктор**. Это сделает объекты обработчиков неизменяемыми. Но если программа предполагает динамическую перестройку цепочек, **можете добавить и сеттер для поля**.

   Реализуйте здесь метод обработки так, чтобы он перенаправлял запрос следующему объекту, проверив его наличие. Это позволит полностью скрыть поле-ссылку от подклассов, дав им возможность передавать запросы дальше по цепи, обратившись к родительской реализации метода.

3. Один за другим создайте классы конкретных обработчиков и реализуйте в них методы обработки запросов. При получении запроса каждый обработчик должен решить:

    - Может он обработать запрос или нет?
    - Следует передать запрос следующему обработчику или нет?

4. **Клиент может собирать цепочку обработчиков самостоятельно**, опираясь на свою бизнес-логику, либо получать уже готовые цепочки извне. В последнем случае, **цепочки собирают фабричные объекты исходя из конфигурации приложения или текущего окружения**.

5. **Клиент может посылать запросы любому обработчику в цепи, а не только первому.** Запрос будет передаваться по цепочке пока какой-то обработчик не откажется передавать его дальше, либо когда будет достигнут конец цепи.

6. Клиент должен знать о динамической природе цепочки и быть готов к таким случаям:

    - Цепочка может состоять из единственного объекта.
    - Запросы могут не достигать конца цепи.
    - Запросы могут достигать конца, оставаясь необработанными.
 
## Преимущества и недостатки

 | + | - |
 | ------ | ------ |
 |Уменьшает зависимость между клиентом и обработчиками.|Запрос может остаться никем не обработанным. +-
 |Соблюдает [**принцип единственной обязанности класса**][SRP].
 |Соблюдает принцип [**открытости/закрытости**][OCP].
 
## Отношения с другими паттернами

- **Цепочка обязанностей**, [**Команда**][Command], [**Посредник**][Mediator] и [**Наблюдатель**][Observer] показывают различные способы работы отправителей запросов с их получателями:

  - **Цепочка обязанностей** передаёт запрос последовательно через цепочку потенциальных получателей, ожидая, что какой-то из них обработает запрос.

  - [**Команда**][Command] устанавливает косвенную одностороннюю связь от отправителей к получателям.
  
  - [**Посредник**][Mediator] убирает прямую связь между отправителями и получателями, заставляя их общаться опосредованно, через себя.
  
  - [**Наблюдатель**][Observer] передаёт запрос одновременно всем заинтересованным получателям, но позволяет им динамически подписывать или отписываться от таких оповещений.

- **Цепочку обязанностей** часто используют вместе с [**Компоновщиком**][Composite]. В этом случае, запрос передаётся от дочерних компонентов к их родителям.

- Обработчики в **Цепочке обязанностей** могут быть выполнены в виде [**Команд**][Command]. В этом случае множество разных операций может быть выполнено над одним и тем же контекстом, коим является запрос.

  Но есть и другой подход, в котором сам запрос является [**Командой**][Command], посланной по цепочке объектов. В этом случае одна и та же операция может быть выполнена над множеством разных контекстов, представленных в виде цепочки.

- **Цепочка обязанностей** и [**Декоратор**][Decorator] имеют очень похожие структуры. Оба паттерна базируются на принципе рекурсивного выполнения операции через серию связанных объектов. Но есть и несколько важных отличий.

  Обработчики в **Цепочке обязанностей** могут выполнять произвольные действия, независимые друг от друга, а также в любой момент прерывать дальнейшую передачу по цепочке. С другой стороны [**Декораторы**][Decorator] расширяют какое-то определённое действие, не ломая интерфейс базовой операции и не прерывая выполнение остальных декораторов.


[SRP]: </src/AdditionalDocs/SOLID/Single_Responsibility_principle.md>
[OCP]: </src/AdditionalDocs/SOLID/Open-Closed_principle.md>

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>

# Команда 

![UML](/src/AdditionalDocs/uml/Command/Command.png)

**Превращает запросы в объекты**, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также **поддерживать отмену операций**.
 
 Соблюдение [**Dependency-Inversion**][DIP]
![UML](/src/AdditionalDocs/uml/Command/ex1.png)
![UML](/src/AdditionalDocs/uml/Command/ex1_sol.png)

## Применимость
 - Когда вы хотите параметризовать объекты выполняемым действием.

   - Команда превращает операции в объекты. А объекты можно **передавать, хранить и взаимозаменять внутри других объектов**.

     Скажем, вы разрабатываете библиотеку графического меню и хотите, чтобы пользователи могли использовать меню в разных приложениях, не меняя каждый раз код ваших классы. Применив паттерн, пользователям не придётся изменять классы меню, вместо этого они будут **конфигурировать объекты меню различными командами**.

 - Когда вы хотите **ставить операции в очередь, выполнять их по расписанию или передавать по сети**.

   - Как и любые другие объекты, **команды можно сериализовать**, то есть превратить в строку, чтобы потом сохранить в файл или базу данных. Затем, в любой удобный момент, её можно достать обратно, снова превратить в объект команды, и выполнить. Таким же образом **команды можно передавать по сети, логировать или выполнять на удалённом сервере**.

 - Когда вам нужна **операция отмены**.

   - Главная вещь, которая вам нужна, чтобы иметь возможность **отмены операций - это хранение истории**. Среди многих способов как это делается, паттерн **Команда** является, пожалуй, самым популярным.

     История команд выглядит как стек, в который попадают все выполненные объекты команд. Каждая команда перед выполнением операции сохраняет текущее состояния объекта, с которым она будет работать. После выполнения операции, копия команды попадает в стек истории, все ещё неся в себе сохранённое состояние объекта. Если потребуется отмена, программа возьмёт последнюю команду из истории и возобновит сохранённое в ней состояние.

     Этот способ имеет две особенности. **Во-первых, точное состояние объектов не так-то просто сохранить, ведь часть его может быть приватным. Но с этим может помочь справиться паттерн [**Снимок**][Memento].**

     **Во-вторых, копии состояния могут занимать довольно много оперативной памяти**. Поэтому иногда можно прибегнуть к альтернативной реализации, когда вместо восстановления старого состояния, команда выполняет обратное действие. **Недостаток этого способа в сложности** (а иногда и невозможности) реализации обратного действия.
     
 ## Шаги реализации

1. Создайте **общий интерфейс команд** и определите в нём метод запуска (`execute()`).

2. Создайте классы конкретных команд. **В каждом классе должно быть поле для хранения ссылки на один или несколько объектов-получателей, которым команда будет перенаправлять основную работу** (Делегирование).

   Кроме этого, команда должна иметь поля для хранения параметров, которые нужны при вызове методов получателя. Значения всех этих полей команда должна получать через конструктор.

   И наконец, реализуйте основной метод команды, вызывая в нём те или иные методы получателя.

3. Добавьте в классы отправителей поля для хранения команд. Объект-отправитель должен принимать готовый объект команды извне через конструктор, либо через сеттер команды.

4. **Измените основной код отправителей так, чтобы они делегировали выполнение действия команде**.

5. Порядок инициализации объектов должен выглядеть так:

 - Создаём объекты получателей. (Создаем лампочку)
 - Создаём объекты команд, связав их с получателями. (Создаем команду вклСвет, передаем в нее лампочку)
 - Создаём объекты отправителей, связав их с командами. (Создаем пульт, передаем в него команду)
 
 ## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |**Убирает прямую зависимость между объектами, вызывающими операции и объектами, которые их непосредственно выполняют**. |Усложняет код программы за счёт дополнительных классов.
 |Позволяет реализовать простую **отмену и повтор операций**.
 |Позволяет реализовать **отложенный запуск команд**.
 |Позволяет **собирать сложные команды из простых**.
 |Соблюдает принцип [**открытости/закрытости**][OCP].

## Отношения с другими паттернами

- [**Цепочка обязанностей**][Chain_of_Responsibility], **Команда**, [**Посредник**][Mediator] и [**Наблюдатель**][Observer] показывают различные способы работы отправителей запросов с их получателями:

  - [**Цепочка обязанностей**][Chain_of_Responsibility] передаёт запрос последовательно через цепочку потенциальных получателей, ожидая, что какой-то из них обработает запрос.
  
  - **Команда** устанавливает косвенную одностороннюю связь от отправителей к получателям.
  
  - [**Посредник**][Mediator] убирает прямую связь между отправителями и получателями, заставляя их общаться опосредованно, через себя.
  
  - [**Наблюдатель**][Observer] передаёт запрос одновременно всем заинтересованным получателям, но позволяет им динамически подписывать или отписываться от таких оповещений.

 - Обработчики в [**Цепочке обязанностей**][Chain_of_Responsibility] могут быть выполнены в виде **Команд**. В этом случае множество разных операций может быть выполнено над одним и тем же контекстом, коим является запрос.

    Но есть и другой подход, в котором сам запрос является **Командой**, посланной по цепочке объектов. В этом случае одна и та же операция может быть выполнена над множеством разных контекстов, представленных в виде цепочки.

 - **Команду** и [**Снимок**][Memento] можно использовать сообща для реализации отмены операций. В этом случе объекты команд будут отображать выполненные действие над объектом, снимки - хранить копию состояния этого объекта до того, как команда была выполнена.

    **Команда** и [**Стратегия**][Strategy] похожи по духу, но отличаются масштабом и применением:

    - **Команду** используют, чтобы превратить любые разнородные действия в объекты. Параметры операции превращаются в поля объекта. Этот объект теперь можно логировать, хранить в истории для отмены, передавать во внешние сервисы и так далее.
 
    - С другой стороны, [**Стратегия**][Strategy] описывает разные способы сделать одно и то же действие, позволяя взаимозаменять эти способы в каком-то объекте контекста.
Если **Команду** нужно копировать перед вставкой в историю выполненных команд, вам может помочь [**Прототип**][Prototype].

- [**Посетитель**][Visitor] это более мощный аналог **Команды**, которую можно выполнить сразу над объектами нескольких классов.


[OCP]: </src/AdditionalDocs/SOLID/Open-Closed_principle.md>
[DIP]: </src/AdditionalDocs/SOLID/Dependency_Inversion_principle.md>

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>

# Интерпретатор 

![UML](/src/AdditionalDocs/uml/Interpreter/Interpreter.png)

Предоставляет возможность оценить грамматику или выражение языка. Этот шаблон предполагает **реализацию интерфейса выражения, который интерпретирует конкретный контекст**. Этот шаблон используется в разборе SQL, движке обработки символов и т. д.

или

Позволяет **описать алгоритм со своей грамматикой и определенными правилами для решения конкретной задачи**. Короче говоря, данный шаблон позволяет описать механизм вычисления конкретной задачи с заданным синтаксисом.

## Применимость

- Когда нужно **реализовать простой язык**.
  
  - Уместен для языков с простой грамматикой, где простота важнее эффективности 
  
  - Может использоваться как со сценарными языками, так и с языками программирования.

## Шаги реализации

1. Создайте интерфейс выражения.
  
    - Как правило, будет вмещать в себя метод `interpret(String context)`

2. Создайте конкретные классы реализаций. Которые предусматривают в себе все нужные варианты интерпретаций.

## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |Грамматику легко изменять и расширять.|Сложные грамматики трудно сопровождать.
 |Простая реализация грамматики.
 
## Отношения с другими паттернами

- Обычно вместе с паттерном **Интерпретатор** используется [**Компоновщик**][Composite]
 
 - **Абстрактное синтаксическое дерево** - это пример применения паттерна [**Компоновщик**][Composite].

![UML](/src/AdditionalDocs/uml/Interpreter/AbstractSyntaxTree.png)
 
- [**Приспособленец**][Flyweight] показывает варианты совместного использования терминальных символов в абстрактном синтаксическом дереве. 

- **Интерпретатор** может пользоваться [**Итератором**][Singleton] для обхода структуры.

- [**Посетителя**][Visitor] можно использовать для инкапсуляции в одном классе поведения каждого узла абстрактного синтаксического дерева.


[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>

# Итератор

![UML](/src/AdditionalDocs/uml/Iterator.png)
 
Даёт возможность **последовательно обходить элементы составных объектов**, не раскрывая их внутреннего представления.

Коллекции (Iterable collection) не всегда являются списком. Это может быть и база данных, и удалённое API, и даже дерево [**Компоновщика**][Composite]. Поэтому сама коллекция может создавать итераторы, так как она знает, какие именно итераторы могут с ней работать.

**JDK имеет интерфейсы [Iterable\<T>](https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html), [Iterator\<E>](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html)**

**Так же JDK есть более функциональный [ListIterator\<E>](https://docs.oracle.com/javase/8/docs/api/java/util/ListIterator.html), используется классами, реализующими интерфейс [List](https://docs.oracle.com/javase/8/docs/api/java/util/List.html)**

## Применимость
 - Когда у вас есть сложная структура данных, и вы хотите скрыть от клиента детали её реализации (из-за сложности или вопросов безопасности).

   - **Итератор предоставляет клиенту всего несколько простых методов перебора элементов коллекции**. Это не только упрощает доступ к коллекции, но и защищает её данные от неосторожных или злоумышленных действий.

 - Когда вам нужно иметь **несколько вариантов обхода** одной и той же структуры данных.

   - Нетривиальные алгоритмы обхода структуры данных могут иметь довольно объёмный код. Этот код будет захламлять всё вокруг, если поместить его в класс коллекции или где-то посреди основной бизнес-логики программы. Применив итератор, вы можете **переместить код обхода структуры данных в собственный класс, упростив поддержку остального кода**.

 - Когда вам хочется иметь **единый интерфейс обхода различных структур данных**.

   - **Итератор позволяет вынести реализации различных вариантов обхода в подклассы**. Это позволит легко взаимозаменять объекты итераторов, в зависимости от того, с какой структурой данных приходится работать.

## Шаги реализации
 
1. Создайте **интерфейс итераторов**. В качестве минимума, вам понадобится **операция получения следующего элемента**. Но для удобства можно предусмотреть и другие методы, например, для **получения предыдущего элемента**, **текущей позиции**, **проверки окончания обхода и прочих**.

2. Создайте интерфейс коллекции и опишите в нём **метод получения итератора**. Важно, чтобы его сигнатура **возвращала общий интерфейс итераторов**, а не один из конкретных итераторов.

3. Создайте классы конкретных итераторов для тех коллекций, которые нужно обходить с помощью паттерна. **Итератор должен быть привязан только к одному объекту коллекции. Обычно эта связь устанавливается через конструктор**.

4. Реализуйте методы получения итератора в конкретных классах коллекций. Они должны создавать новый итератор того класса, который способен работать с данным типом коллекции. **Коллекция должна передавать собственную ссылку в созданный итератор**.

5. **В клиентском коде и в классах коллекций не должно остаться кода обхода элементов**. Клиент должен получать новый итератор из объекта коллекции каждый раз, когда ему нужно перебрать её элементы.

 ## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |Упрощает классы хранения данных.|Неоправдан, если можно обойтись простым циклом.
 |Позволяет реализовать различные **способы обхода структуры данных**.
 |Позволяет одновременно перемещаться по структуре данных в разные стороны.
 
 
## Отношения с другими паттернами

- Вы можете обходить дерево **[**Компоновщика**][Composite]**, используя **Итератор**.

- [**Фабричный метод**][Factory_method] можно использовать вместе с **Итератором**, чтобы подклассы коллекций могли создавать подходящие им итераторы.

- [**Снимок**][Memento] можно использовать вместе с **Итератором**, чтобы сохранить текущее состояние обхода структуры данных и вернуться к нему в будущем, если потребуется.

- [**Посетитель**][Visitor] можно использовать совместно с **Итератором**. **Итератор** будет отвечать за обход структуры данных, а [**Посетитель**][Visitor] - за выполнение действий над каждым её компонентом.


[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>

# Посредник

![UML](/src/AdditionalDocs/uml/Mediator.png)

(Также можно выделить Компоненты в отдельный интерфейс)

***Компоненты** - это разнородные объекты, содержащие бизнес-логику программы. Каждый компонент хранит ссылку на объект посредника, но работает с ним только через абстрактный интерфейс посредников. Благодаря этому, компоненты можно повторно использовать в другой программе, связав их с посредником другого типа.

***Посредник** определяет интерфейс для обмена информацией с компонентами. Обычно хватает одного метода для оповещения посредника о событиях, произошедших в компонентах. В параметрах этого метода можно передавать детали события: ссылку на компонент, в котором оно произошло, и любые другие данные.

Позволяет **уменьшить связанность** множества классов между собой, благодаря перемещению этих связей в один класс-посредник, также обеспечивает взаимодействие.

## Применимость
 
 - Когда вам сложно менять некоторые классы из-за **множества хаотичных связей с другими классами**.

   - **Посредник позволяет поместить все эти связи в один класс**. После чего вам будет легче их отрефакторить, сделать более понятными и гибкими.

 - Когда вы не можете **повторно использовать класс**, поскольку он зависит от уймы других классов.

   - После применения паттерна, компоненты теряют прежние связи с другими компонентами. А всё их общение происходит косвенно, через посредника.

 - Когда вам **приходится создавать множество подклассов компонентов, чтобы использовать одни и те же компоненты в разных контекстах**.

   - Если раньше изменение отношений в одном компоненте могли повлечь за собой снежный ком изменений в каждом другом компоненте, то теперь вам **достаточно создать подкласс посредника и поменять в нём связи между компонентами**.

## Шаги реализации

1. Найдите **группу тесно переплетённых классов**, отвязав которые друг от друга, можно получить некоторую пользу. Например, чтобы повторно использовать их код в другой программе.

2. Создайте **общий интерфейс Посредников и опишите в нём методы для взаимодействия с Компонентами**. В простейшем случае достаточно одного метода для получения оповещений от компонентов.

   Этот **интерфейс необходим, если вы хотите повторно использовать классы компонентов для других задач**. В этом случае, всё, что нужно сделать - это создать новый класс конкретного посредника.

3. Реализуйте этот **интерфейс в классе Конкретного посредника**. Поместите в него **поля, которые будут содержать ссылки на все объекты компонентов**.

4. Вы можете пойти дальше и переместить **код создания компонентов в класс Конкретного посредника, превратив его в фабрику**.

5. **Компоненты тоже должны иметь ссылку на объект посредника**. Связь между ними удобней всего установить, подавая посредника в параметры конструктора компонентов.

6. Измените **код компонентов так, чтобы они вызывали метод оповещения посредника**, а не методы других компонентов. С другой стороны, **посредник должен вызывать методы нужного компонента, когда получает оповещение**.

## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |Устраняет зависимости между компонентами, позволяя повторно их использовать.|Посредник может сильно раздуться.
 |Упрощает взаимодействие между компонентами.
 |Централизует управление в одном месте.
 
## Отношения с другими паттернами

- [**Цепочка обязанностей**][Chain_of_Responsibility], [**Команда**][Command], **Посредник** и [**Наблюдатель**][Observer] показывают различные способы работы отправителей запросов с их получателями:

  - [**Цепочка обязанностей**][Chain_of_Responsibility] передаёт запрос последовательно через цепочку потенциальных получателей, ожидая, что какой-то из них обработает запрос.

   - [**Команда**][Command] устанавливает косвенную одностороннюю связь от отправителей к получателям.

   - **Посредник** убирает прямую связь между отправителями и получателями, заставляя их общаться опосредованно, через себя.
   
   - [**Наблюдатель**][Observer] передаёт запрос одновременно всем заинтересованным получателям, но позволяет им динамически подписывать или отписываться от таких оповещений.

- **Посредник** и [**Фасад**][Facade] похожи тем, что пытаются организовать работу множества существующих классов.

  - [**Фасад**][Facade] создаёт упрощённый интерфейс к подсистеме, не внося в неё никакой добавочной функциональности. Сама подсистема не знает о существовании [**Фасада**][Facade]. Классы подсистемы общаются друг с другом напрямую.

  - **Посредник** централизует общение между компонентами системы. Компоненты системы знают только о существовании **Посредника**, у них нет прямого доступа к другим компонентам.

- Разница между **Посредником** и [**Наблюдателем**][Observer] не всегда очевидна. Чаще всего они выступают как конкуренты, но иногда могут работать вместе.
  
  Цель **Посредника** - убрать обоюдные зависимости между компонентами системы. Вместо этого они становятся зависимыми от самого посредника. С другой стороны, цель [**Наблюдателя**][Observer] - обеспечить динамическую одностороннюю связь, в которой одни объекты косвенно зависят от других.

  Довольно популярна реализация **Посредника** при помощи [**Наблюдателя**][Observer]. При этом объект посредника будет выступать издателем, а все остальные компоненты станут подписчиками и смогут динамически следить за событиями, происходящими в посреднике. В этом случае трудно понять, чем же отличаются оба паттерна.

  Но **Посредник** имеет и другие реализации, когда отдельные компоненты жёстко привязаны к объекту посредника. Такой код вряд ли будет напоминать [**Наблюдателя**][Observer], но всё же останется **Посредником**.

  Напротив, в случае реализации посредника с помощью [**Наблюдателя**][Observer], представим такую программу, в которой каждый компонент системы становится издателем. Компоненты могут подписываться друг на друга, в то же время, не привязываясь к конкретным классам. Программа будет состоять из целой сети [**Наблюдателей**][Observer], не имея центрального объекта **Посредника**.


[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Object_Pool]: </src/Creational/Object_Pool/Object_Pool.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>
[Private_Class_Data]: </src/Structural/Private_Class_Data/Private_Class_Data.md>


[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
[Null_Object]: </src/Behavioral/Null_Object/Null_Object.md>

# Хранитель

![UML](/src/AdditionalDocs/uml/Memento/Memento.png)

Классическая реализация паттерна полагается на **механизм вложенных классов**. (Java)

Когда нужно полностью исключить доступ к состоянию Создателей и Снимков.
![UML](/src/AdditionalDocs/uml/Memento/MementoSave.png)

Позволяет не нарушая инкапсуляцию, зафиксировать и сохранить внутреннее состояние объекта так, чтобы позднее восстановить его в это состояние.

## Применимость
 
 (Serialization = Memento)
 
 - Когда вам нужно **сохранять мгновенный снимок состояния объекта (или его части)**, чтобы впоследствии объект можно было восстановить в том же состоянии.

    - **Снимок позволяет делать любое количество снимков объекта и хранить их независимо от объекта**, с которого делают снимок. Снимки часто используют не только для реализации операции отмены, но и для транзакций, когда состояние объекта нужно откатить, если операция не удалась.

 - Когда **прямое получение состояния объекта раскрывает детали его реализации и нарушает инкапсуляцию**.

    - Паттерн предлагает изготовить снимок самому исходному объекту, так как ему доступны все поля, даже приватные.

## Шаги реализации

1. Определите класс создателя, объекты которого должны создавать снимки своего состояния.

2. Создайте **класс снимка и опишите в нём все те же поля, которые имеются в оригинальном классе-создателе**.

3. Сделайте **объекты снимков неизменяемыми**. Они должны получать начальные значения только один раз, через свой конструктор.

4. Если ваш язык программирования это позволяет, сделайте **класс снимка вложенным в класс создателя**.

   Если нет, извлеките из класса снимка пустой интерфейс, который будет доступен остальным объектам программы. Впоследствии вы можете добавить некоторые вспомогательные методы в этот интерфейс, дающие доступ к метаданным снимка, однако прямой доступ к данным создателя должен быть исключён.

5. Добавьте в **класс создателя метод получения снимков**. Создатель должен создавать новые объекты снимков, передавая значения своих полей через конструктор.

   Сигнатура метода должна возвращать снимки через ограниченный интерфейс, если он у вас есть. Сам класс должен работать с конкретным классом снимка.

6. Добавьте в **класс создателя метод восстановления из снимка**. Что касается привязки к типам, руководствуйтесь той же логикой, что и в пункте 4.

7. Опекуны, будь то история операций, объекты команд или нечто иное, должны знать о том, когда запрашивать снимки у создателя, где их хранить, и когда восстанавливать.

8. **Связь опекунов с создателями можно перенести внутрь снимков**. В этом случае каждый снимок будет привязан к своему создателю и должен будет сам восстанавливать его состояние. Но **это будет работать либо если классы снимков вложены в классы создателей, либо если создатели имеют сеттеры для установки значений своих полей**.

## Преимущества и недостатки

 | + | - |
 | ------ | ------ |
 |Не нарушает инкапсуляции исходного объекта.|Требует **много памяти, если клиенты слишком часто создают снимки**.
 |Упрощает структуру исходного объекта. Ему **не нужно хранить историю версий своего состояния**.|Может **повлечь дополнительные издержки памяти, если объекты, хранящие историю, не освобождают ресурсы**, занятые устаревшими снимками.
 | |В некоторых языках (например, PHP, Python, JavaScript) сложно гарантировать, чтобы только исходный объект имел доступ к состоянию снимка.

## Отношения с другими паттернами

- [**Команду**][Command] и **Снимок** можно использовать сообща для реализации отмены операций. В этом случе объекты команд будут отображать выполненные действие над объектом, снимки - хранить копию состояния этого объекта до того, как команда была выполнена.

- **Снимок** можно использовать вместе с [**Итератором**][Iterator], чтобы сохранить текущее состояние обхода структуры данных и вернуться к нему в будущем, если потребуется.

- **Снимок** иногда можно заменить [**Прототипом**][Prototype], если объект, чьё состояние требуется сохранять в истории, довольно простой, не имеет активных ссылок на внешние ресурсы, либо их можно легко восстановить.

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>

# Null Object

![UML](/src/AdditionalDocs/uml/Null_Object.png)

 Объекты могут иметь значение NULL, они нуждаются в проверке на NULL-значение перед использованием, так как методы класса «нулевого» объекта, как правило, не могут вызываться.

**Null-object инкапсулирует отсутствие объекта путём замещения его другим объектом, который ничего не делает**.

## Применимость

- Когда объект требует взаимодействия с другими объектами. **Null Object не устанавливает нового взаимодействия - он использует уже установленное взаимодействие**;

- Когда какие-то из взаимодействующих объектов должны бездействовать;

- Когда требуется абстрагирование **«общения» с объектами, имеющими NULL-значение**.

## Шаги реализации

- Описать существующий интерфес, оставляя методы пустыми или описать "заглушки".

## Преимущества и недостатки

| + | - |
| ------ | ------ |
|Замена всех проблем с Null.|

## Отношения с другими паттернами

- Класс **Null Object** часто реализуется как [**Singleton**][Singleton]. Поскольку **Null Object** обычно не имеет какого-либо состояния, его состояние не может измениться, поэтому несколько экземпляров идентичны. Вместо того, чтобы использовать несколько одинаковых экземпляров, система может просто использовать один экземпляр повторно.

- Если некоторые клиенты ожидают, что **Null Object** ничего не сделает в одном направлении, а некоторые в другом, потребуются несколько классов NullObject. Класс NullObject потребует подключаемых переменных, чтобы клиент мог указать, как нулевой объект ничего не должен делать. Это может быть признаком абстрактного объекта, не имеющего четко определенного (семантического) интерфейса.

- **Null Object** не может стать реальным объектом. Если объект может стать реальным объектом - это не **Null Object**. Это может быть реальный объект с режимом do-nothing, например, контроллер, который может переключаться и находиться в режиме только для чтения. Если это один объект, он должен быть реализован с шаблоном State или, возможно, с  [**Proxy**][Proxy] шаблоном. В этом случае может использоваться Null State или прокси может содержать **Null Object**

- **Null Object** может быть аналогично использованию [**Proxy**][Proxy], но оба шаблона имеют разные цели. [**Proxy**][Proxy] обеспечивает уровень косвенности при доступе к объекту. **Null Object** не скрывает реального объекта и не контролирует доступ к нему, он заменяет реальный объект. [**Proxy**][Proxy] может в конечном итоге мутировать, чтобы начать действовать как настоящий субъект. **Null Object** не будет мутировать для запуска.

- **Null Object** может быть частным случаем шаблона [**Strategy**][Strategy]. [**Strategy**][Strategy] определяет несколько ConcreteStrategy классов как разные подходы к выполнению задачи. Если один из этих подходов должен ничего не делать, тогда этот ConcreteStrategy является NullObject. Например, контроллер представляет собой представление по стратегии для обработки ввода, а NoController - это стратегия, которая игнорирует все входные данные.

- **Null Object** может быть частным случаем [**State**][State]. Обычно у каждого ConcreteState есть некоторые методы для этого состояния. Фактически, данный метод часто реализуется, чтобы сделать что-то полезное в большинстве состояний. Если конкретный ConcreteState реализует большинство методов, так что они пустые или по крайней мере дают нулевые результаты, он становится **Null Object**.

- **Null Object** может использоваться, чтобы позволить [**Visitor**][Visitor] безопасно посещать иерархию и обрабатывать нулевую ситуацию.
  

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Object_Pool]: </src/Creational/Object_Pool/Object_Pool.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>
[Private_Class_Data]: </src/Structural/Private_Class_Data/Private_Class_Data.md>


[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>
[Null_Object]: </src/Behavioral/Null_Object/Null_Object.md>

# Наблюдатель

![UML](/src/AdditionalDocs/uml/Observer.png)

**Наблюдатель** - определяет отношение "один ко многим" между объектами таким образом,
что при **изменении состояния одного объекта (Subject, Observable)** происходит автоматическое **оповещение и обновление 
всех зависимых объектов**.

[(Ex)][Ex3] JDK уже имеет реализацию паттерна через унаследование класса **Observer и Observable**.
Полезно когда нам нужно **оповещать только по условию**, а не сразу, потому что метод обновления будет действовать
только если флаг `changed = true` (set/has/clear)Changed().

Большой минус то, что это уже реализованный класс. То есть extend = наследование.


## Применимость

 - Когда при **изменении состояния одного объекта требуется что-то сделать в других**, но вы не знаете наперёд какие именно объекты должны отреагировать.

   - Эта задача может возникнуть при разработке GUI фреймворка, когда надо дать возможность сторонним классам реагировать на **клики по кнопкам**.

   - Паттерн **Наблюдатель** даёт возможность любому объекту с интерфейсом подписчика, подписываться на изменения в объектах-издателях.

 - Когда одни объекты должны наблюдать за другими, но только в определённых случаях.

   - Издатели ведут динамические списки. Все **наблюдатели могут подписываться или отписываться на обновления прямо во время выполнения** программы.

## Шаги реализации

1. Разбейте вашу функциональность на две части: **независимое ядро** и **опциональные зависимые части**. Независимое ядро станет издателем. Зависимые части станут подписчиками.

2. Создайте **интерфейс подписчиков**. В большинстве случаев, в нём достаточно определить единственный метод оповещения `update()`.

3. Создайте **интерфейс издателей** и опишите в нём **операции управления подпиской**. Помните, что издатель должен работать только с **общим интерфейсом подписчиков**.

4. [(Ex)][Ex1] Вам нужно решить, куда поместить **код ведения подписки**, ведь он обычно бывает одинаков для всех типов издателей. Самый очевидный способ - **вынести этот код в промежуточный абстрактный класс**, от которого будут **наследоваться все издатели**.

5. [(Ex)][Ex2] Но если вы интегрируете паттерн в существующие классы, то создать новый базовый класс может быть затруднительно. В этом случае, вы можете поместить **логику подписки во вспомогательный объект и делегировать ему работу из издателей**.

6. Создайте **классы конкретных издателей**. Реализуйте их так, чтобы **при каждом изменении** состояния, они **слали оповещения** всем своим подписчикам.

7. Реализуйте **метод оповещения в конкретных подписчиках**. Издатель может **отправлять какие-то данные вместе с оповещением** (например, в параметрах). Возможен и **другой вариант, когда подписчик, получив оповещение, сам берёт из объекта издателя нужные данные**. Но при этом **подписчик привяжет себя к конкретному классу издателя**. (Программировать не интерфейсами)

8. Клиент должен создавать необходимое количество объектов подписчиков и **подписывать** их у издателей.

## Преимущества и недостатки

| + | - |
| ------ | ------ |
|**Издатель не зависит** от конкретных классов подписчиков.| Наблюдатели оповещаются в случайном порядке.
|Вы можете подписывать и отписывать получателей **на лету**.|
|Реализует принцип [**открытости/закрытости**][OCP].

## Отношения с другими паттернами

 - [**Цепочка обязанностей**][Chain_of_Responsibility], [**Команда**][Command], [**Посредник**][Mediator] и **Наблюдатель** показывают различные способы работы отправителей запросов с их получателями:

   - [**Цепочка обязанностей**][Chain_of_Responsibility] передаёт запрос последовательно через цепочку потенциальных получателей,
    ожидая, что какой-то из них обработает запрос.
   
   - [**Команда**][Command] устанавливает косвенную одностороннюю связь от отправителей к получателям.
   
   - [**Посредник**][Mediator] убирает прямую связь между отправителями и получателями, заставляя их общаться опосредованно,
    через себя.
   
   - **Наблюдатель** передаёт запрос одновременно всем заинтересованным получателям, но позволяет им динамически подписывать
    или отписываться от таких оповещений.
   
 - Разница между [**Посредником**][Mediator] и **Наблюдателем** не всегда очевидна. Чаще всего они выступают как конкуренты,
    но иногда могут работать вместе.

    Цель [**Посредника**][Mediator] - убрать обоюдные зависимости между компонентами системы. 
    Вместо этого они становятся зависимыми от самого посредника. С другой стороны, 
    цель **Наблюдателя** - обеспечить динамическую одностороннюю связь, в которой одни объекты косвенно зависят от других.

    Довольно популярна реализация [**Посредника**][Mediator] при помощи **Наблюдателя**. 
    При этом объект посредника будет выступать издателем, а все остальные компоненты станут подписчиками и смогут динамически следить за событиями,
    происходящими в посреднике. В этом случае трудно понять, чем же отличаются оба паттерна.

    Но [**Посредник**][Mediator] имеет и другие реализации, когда отдельные компоненты жёстко привязаны к объекту посредника. Такой код вряд ли будет напоминать **Наблюдателя**,
    но всё же останется [**Посредником**][Mediator].

    Теперь представьте другую программу, в которой каждый компонент системы становится издателем. Компоненты могут подписываться друг на друга,
    в то же время, не привязываясь к конкретным классам. Программа будет состоять из целой сети наблюдателей, не имея центрального объекта посредника.

[Ex1]: </src/Behavioral/Observer/Example/ManytoMany/>
[Ex2]: </src/Behavioral/Observer/Example/Delegation/>
[Ex3]: </src/Behavioral/Observer/Example/withJDK/>

[OCP]: </src/AdditionalDocs/SOLID/Open-Closed_principle.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>

# Состояние 

![UML](/src/AdditionalDocs/uml/Strategy.png)

Позволяет **менять поведение в зависимости от своего состояния**. Извне создаётся впечатление, что изменился класс объекта.

Очень важным нюансом, отличающим этот паттерн от [**Стратегии**][Strategy], является то, что **и контекст, и сами конкретные состояния могут знать друг о друге и инициировать переходы от одного состояния к другому**.

## Применимость
 
  - Когда у вас есть объект, поведение которого кардинально меняется в зависимости от внутреннего состояния. Причём типов состояний много и их код часто изменяется.

    - Паттерн предлагает создать класс для каждого такого состояния, а затем **переместить туда все поля и методы, связанные с состоянием**. Первоначальный класс будет постоянно ссылаться на один из объектов-состояний, **делегируя ему большую часть работы**. Для изменения состояния, в контекст будет подставляться другой объект.

  - Когда **код класса содержит множество больших, похожих друг на друга, условных операторов**, которые выбирают поведения в зависимости от текущих значений полей класса.

    - Паттерн предлагает переместить каждую ветку такого условного оператора в собственный класс. Тут же можно поселить и все поля, связанные с данным состоянием.

  - Когда вы сознательно **используете табличную машину состояний**, построенную на условных операторах, но вынуждены мириться с дублированием кода для похожих состояний и переходов.

    - Паттерн **Состояние** позволяет реализовать **иерархическую машину состояний, базирующуюся на наследовании**. Вы можете отнаследовать похожие состояния от одного родительского класса, и вынести туда весь дублирующий код.

## Шаги реализации

1. Определитесь с классом, который будет отыгрывать роль контекста. Это может быть как существующий класс, в котором уже есть зависимость от состояния, так и новый класс, если код состояний размазан по нескольким классам.

2. Создайте интерфейс состояния. Он должен **описывать методы, общие для всех состояний, обнаруженных в контексте**.

3. Для каждого фактического состояния, создайте класс, реализующий интерфейс состояния. Переместите весь код, связанный с конкретным состоянием в нужный класс. В конце концов, все методы интерфейса состояния должны быть реализованы.

4. Создайте **в контексте поле для хранения объектов-состояний, а также публичный метод для изменения значения этого поля**.

5. Старые методы контекста, в которых находился зависимый от состояния код, замените на вызовы соответствующих методов объекта-состояния.

6. В зависимости от бизнес-логики, разместите код, который переключает состояние контекста либо внутри контекста, либо внутри классов конкретных состояний.

## Преимущества и недостатки

| + | - |
| ------ | ------ |
 |Избавляет от множества больших условных операторов машины состояний.|Может неоправданно усложнить код, если состояний мало и они редко меняются.
 |Концентрирует в одном месте код, связанный с определённым состоянием.
 |Упрощает код контекста.
 
## Отношения с другими паттернами

- [**Мост**][Bridge], [**Стратегии**][Strategy] и **Состояние** (а также слегка и [**Адаптер**][Adapter]) имеют схожие структуры классов - все они построены на принципе [**«композиции»**][Composition], то есть делегирования работы другим объектам. Тем не менее, они отличаются тем, что решают разные проблемы. Помните, что паттерны - это не только рецепт построения кода определённым образом, но и описание проблем, которые привели к данному решению.

- **Состояние** можно рассматривать как надстройку над [**Стратегией**][Strategy]. Оба паттерна используют композицию, чтобы менять поведение основного объекта, делегируя работу вложенным объектам-помощникам. Однако в [**Стратегии**][Strategy] эти объекты не знают друг о друге и никак не связаны. В **Состоянии** сами конкретные состояния могут переключать контекст.

[Composition]: </src/AdditionalDocs/Composition.md>

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>

# Стратегия

![UML](/src/AdditionalDocs/uml/Strategy.png)

**Стратегия** определяет семейство алгоритмов, инкапсулирует каждый из них 
и обеспечивает их взаимозаменяемость. Он позволяет модифицировать алгоритмы
независимо от их использования на стороне клиента.

## Применимость

 - Когда вам нужно использовать **разные вариации какого-то алгоритма внутри одного объекта**.

   - Стратегия позволяет **варьировать поведение** объекта во время выполнение программы, подставляя в него различные объекты-поведения (например, отличающиеся балансом скорости и потребления ресурсов).

 - Когда у вас есть множество **похожих классов**, отличающихся только некоторым поведением.

   - Стратегия позволяет вынести отличающееся поведение в отдельную иерархию классов и **свести первоначальные классы к одному**, сделав его поведение настраиваемым.

 - Когда вы не хотите обнажать **детали реализации** алгоритмов для других классов.

   - Стратегия позволяет **изолировать код**, данные и зависимости алгоритмов от других объектов, скрыв из внутри собственных классов.

 - Когда различные вариации алгоритмов реализованы в виде **развесистого условного оператора**. Каждая ветка такого оператора представляет вариацию алгоритма.

   - Стратегия помещает **каждую лапу** такого оператора **в отдельный класс-стратегию**. Затем контекст получает определённый объект-стратегию от клиента и делегирует ему работу. Если вдруг понадобится сменить алгоритм, в контекст можно подать другую стратегию.

## Шаги реализации

1. Определите алгоритм, который подвержен частым изменениям. Также подойдёт алгоритм, имеющий несколько вариаций, которые выбираются во время выполнения программы.

2. Создайте интерфейс стратегий, описывающий этот алгоритм. Он должен быть общим для всех вариантов алгоритма.

3. Поместите **вариации алгоритма в собственные классы**, которые реализуют этот интерфейс.

4. **В классе контекста создайте поле для хранения ссылки на текущий объект-стратегию**, а также метод для её изменения. Убедитесь в том, что контекст работает с этим объектом только через общий интерфейс стратегий.

5. Клиенты контекста должны подавать в контекст соответствующий объект-стратегию, когда хотят, чтобы тот вёл себя определённым образом.

## Преимущества и недостатки

| + | - |
| ------ | ------ |
|Горячая **замена алгоритмов** на лету.| Усложняет программу за счёт **дополнительных классов**.
|**Изолирует код** и данные алгоритмов от остальных классов.|**Клиент должен** знать, в чём разница между стратегиями, чтобы **выбрать подходящую**.
|Уход от наследования к **делегированию**.
|Реализует принцип **открытости/закрытости**.

## Отношения с другими паттернами
  
 - [**Мост**][Bridge], **Стратегия** и [**Состояние**][State] (а также слегка и [**Адаптер**][Adapter]) имеют схожие структуры классов - все они построены на принципе [**«композиции»**][Composition], то есть делегирования работы другим объектам. Тем не менее, они отличаются тем, что решают разные проблемы. Помните, что паттерны - это не только рецепт построения кода определённым образом, но и описание проблем, которые привели к данному решению.
  
 - [**Команда**][Command] и **Стратегия** похожи по духу, но отличаются масштабом и применением:
   - [**Команду**][Command] используют, чтобы превратить любые разнородные действия в объекты. Параметры операции превращаются в поля объекта. Этот объект теперь можно логировать, хранить в истории для отмены, передавать во внешние сервисы и так далее.
   
   - С другой стороны, **Стратегия** описывает разные способы сделать одно и то же действие, позволяя взаимозаменять эти способы в каком-то объекте контекста.
 
 - **Стратегия** меняет поведение объекта «изнутри», а [**Декоратор**][Decorator] изменяет его «снаружи».
  
 - [**Шаблонный метод**][Template Method] использует наследование, чтобы расширять части алгоритма. **Стратегия** использует делегирование, чтобы изменять алгоритм. [**Шаблонный метод**][Template Method] работает на уровне классов. **Стратегия** позволяет менять логику отдельных объектов.
  
 - [**Состояние**][State] можно рассматривать как надстройку над **Стратегией**. Оба паттерна используют [**композицию**][Composition], чтобы менять поведение основного объекта, делегируя работу вложенным объектам-помощникам. Однако в **Стратегии** эти объекты не знают друг о друге и никак не связаны. В [**Состоянии**][State] сами конкретные состояния могут переключать контекст.


[Composition]: </src/AdditionalDocs/Composition.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Adapter]: </src/Structural/Adapter/Adapter.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[State]: </src/Behavioral/State/State.md>
[Command]: </src/Behavioral/Command/Command.md>
[Template Method]: </src/Behavioral/Template_Method/Template_Method.md>

# Шаблонный метод 

![UML](/src/AdditionalDocs/uml/Template_Method.png)

Определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. **Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры**.

**Перехватчик (hook)** - метод объявленный в абстрактном классе, но имеющий пустую реализацию (или по умолчанию). Дает возможность, по желанию, **субкалссу подключаться к алгоритму в разных точках**. (Для необязательных частей алгоритма)

Применение JAVA : **`java.util.Arrays.sort()`** - Не похожа на обычную реализацию (через наследование), так как `sort()` статический. Нужно для сравниваемых объектов реализовать интерфейс `Comparable` метод `compereTo()`, который используется в методе `sort()`.

## Применимость

 - Когда подклассы должны **расширять базовый алгоритм, не меняя его структуры**.

   - Шаблонный метод позволяет подклассам расширять определённые шаги алгоритма через наследование, не меняя при этом структуру алгоритмов, объявленную в родительском классе.

 - Когда у вас есть несколько классов, делающих одно и то же с незначительными отличиями. Если вы редактируете один класс, то приходится вносить такие же правки и в остальные классы.

   - Паттерн шаблонный метод предлагает **создать для похожих классов общий суперкласс и оформить в нём главный алгоритма в виде шагов**. Отличающиеся шаги можно переопределить в подклассах.

     Это позволит **убрать дублирование кода в нескольких классах с похожим поведением, но отличающихся в деталях**.

## Шаги реализации
1. Изучите алгоритм и подумайте, можно ли его разбить на шаги. Какие шаги будут стандартными для всех вариаций алгоритма, а какие - изменчивыми.

2. Создайте абстрактный базовый класс. Определите в нём шаблонный метод. Этот метод должен состоять из вызовов шагов алгоритма. **Имеет смысл сделать шаблонный метод финальным**, чтобы подклассы не могли его переопределить.

3. Добавьте в абстрактный класс методы для каждого из шагов алгоритма. **Стандартные шаги должны иметь реализацию по умолчанию. Изменяемые шаги должны быть объявлены абстрактными.** Их нужно будет реализовать в подклассах.

4. Подумайте о введении в алгоритм хуков. Чаще всего, хуки располагают между основными шагами алгоритма, а также до и после всех шагов.

5. Создайте конкретные классы, унаследовав их от абстрактного класса. Реализуйте в них все недостающие шаги и хуки.

## Преимущества и недостатки
 | + | - |
 | ------ | ------ |
 |Облегчает повторное использование кода. |Вы можете нарушить [**Принцип подстановки Барбары Лисков**][LSP], изменяя базовое поведение одного из шагов алгоритма через подкласс.
 |Вы **жёстко ограничены скелетом существующего алгоритма**. |С ростом количества шагов, шаблонный метод становится слишком сложно поддерживать.
 
## Отношения с другими паттернами

- [**Фабричный метод**][Factory_Method] можно рассматривать как частный случай **Шаблонного метода**. Кроме того, [**Фабричный метод**][Factory_Method] нередко бывает частью большого класса с **Шаблонными методами**.

- **Шаблонный метод** использует наследование, чтобы расширять **части алгоритма**. [**Стратегия**][Strategy] использует делегирование, чтобы изменять алгоритм. **Шаблонный метод** работает на уровне классов. [**Стратегия**][Strategy] позволяет менять логику отдельных объектов.


[LSP]: </src/AdditionalDocs/SOLID/Liskov_Substitution_principle.md>

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>

# Посетитель

![UML](/src/AdditionalDocs/uml/Visitor.png)

Позволяет **создавать новые операции, не меняя классы объектов, над которыми эти операции могут выполняться**.

[***Проблема раннего и позднего связывания**][BindingTypes]

## Применимость

 - Когда вам нужно выполнить операцию над всеми элементами сложной структуры объектов (например, деревом).

   - **Посетитель** позволяет применять одну и ту же операцию к объектам различных классов.

 - Когда над объектами сложной структуры объектов надо выполнять некоторые, **не связанные между собой операций, но вы не хотите «засорять» классы такими операциями**.

   - **Посетитель** позволяет извлечь родственные операции из классов, составляющих структуру объектов, поместив их в один класс-посетитель. **Если структура объектов является общей для нескольких приложений, то паттерн позволит в каждое приложение включить только нужные операции**.

 - Когда **новое поведение имеет смысл только для некоторых классов из существующей иерархии**.

   - **Посетитель** позволяет определить поведение только для этих классов и оставить его пустым для всех остальных.

## Шаги реализации
 
1. Создайте **интерфейс посетителя и объявите в нём методы «посещения» для каждого класса компонента, который существует в программе**.

2. **Опишите интерфейс компонентов**. Если вы работаете с уже существующими классами, то объявите абстрактный метод принятия посетителей в базовом классе иерархии компонентов.

3. Реализуйте **методы принятия во всех конкретных компонентах**. Они должны **переадресовывать вызовы тому методу посетителя, в котором класс параметра совпадает с текущим классом компонента**.

4. Иерархия компонентов должна знать только о **базовом интерфейсе посетителей**. С другой стороны, **посетители будут знать обо всех классах компонентов**.

5. Для **каждого нового поведения создайте свой конкретный класс**. Приспособьте это поведение для всех посещаемых компонентов, **реализовав все методы интерфейса посетителей**.

   Вы можете столкнуться с ситуацией, **когда посетителю нужен будет доступ к приватным полям компонентов**. **В этом случае, вы можете либо раскрыть доступ к этим полям, нарушив инкапсуляцию компонентов, либо сделать класс посетителя вложенным в класс компонента**, если вам повезло писать на языке, который поддерживает вложенность классов.

6. Клиент будет создавать объекты посетителей, а затем передавать их компонентам, используя метод принятия.

## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |Упрощает **добавление новых операций над всей связанной структурой объектов**.|Паттерн **неоправдан, если иерархия компонентов часто меняется**.
 |Объединяет родственные операции в одном классе. |Может привести к нарушению инкапсуляции компонентов.
 |Посетитель **может накоплять состояние при обходе структуры компонентов**.
 
## Отношения с другими паттернами

- **Посетитель** можно рассматривать как расширенный аналог [**Команды**][Command], который способен работать сразу с несколькими видами получателей.

- Вы можете выполнить какое-то действие над всем деревом [**Компоновщика**][Composite] при помощи **Посетителя**.

- **Посетитель** можно использовать совместно с [**Итератором**][Iterator]. [**Итератор**][Iterator] будет отвечать за обход структуры данных, а **Посетитель** - за выполнение действий над каждым её компонентом.

[BindingTypes]: </src/AdditionalDocs/BindingTypes/>

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>

# Строитель

![UML](/src/AdditionalDocs/uml/Builder.png)

Позволяет создавать сложные объекты пошагово.
 
**Строитель** даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.

## Применимость

- Когда вы хотите избавиться от «*телескопического конструктора*».

  - Допустим, у вас есть один конструктор с десятью опциональными параметрами. Его неудобно вызывать, поэтому вы создали ещё десять конструкторов с меньшим количеством параметров. Всё что они делают - это переадресуют вызов к главному конструктору, подавая какие-то значения по умолчанию в качестве опциональных параметров.
  
```java
class Pizza {
    Pizza(int size) { ... }        
    Pizza(int size, boolean cheese) { ... }    
    Pizza(int size, boolean cheese, boolean pepperoni) { ... }
    ...
```

Паттерн **Строитель** позволяет **собирать объекты пошагово, вызывая только те шаги, которые вам нужны**. А значит, больше не нужно пытаться запихнуть в конструктор все возможные опции продукта.

- Когда ваш код должен создавать **разные представления какого-то объекта**. Например, деревянные и железобетонные дома.

  - **Строитель** можно применить, если создание нескольких представлений объекта состоит из одинаковых этапов, которые отличаются в деталях.

    **Интерфейс строителей определит все возможные этапы конструирования**. Каждому представлению будет соответствовать собственный класс-строитель. А **порядок этапов строительства будет задавать класс-директор** (возможно что и сам клиент).

- Когда вам нужно собирать сложные составные объекты, например, деревья [**Компоновщика**][Composite].

  - **Строитель** конструирует объекты пошагово, а не за один проход. Более того, шаги строительства **можно выполнять рекурсивно**. А без этого не построить древовидную структуру вроде [**Компоновщика**][Composite].

    Заметьте, что **Строитель** не позволяет посторонним объектам иметь доступ к конструируемому объекту пока тот не будет полностью готов. Это предотвращает клиентский код от получения незаконченных «битых» объектов.

## Шаги реализации

1. Убедитесь в том, что создание разных представлений объекта **можно свести к общим шагам**.

2. Опишите эти шаги в общем интерфейсе строителей.

3. Для каждого из представлений объекта-продукта создайте по одному классу-строителю и реализуйте их методы строительства.

   Не забудьте про метод получения результата. Обычно, конкретные строители определяют собственные методы получения результата строительства. Вы не можете описать эти методы в интерфейсе строителей, так **продукты не обязательно должны иметь общий базовый класс или интерфейс**. Но вы всегда можете добавить метод получения результата в общий интерфейс, если ваши строители производят однородные продукты с общим предком.

4. Подумайте о создании класса директора. Его методы будут создавать различные конфигурации продуктов, вызывая разные шаги одного и того же строителя.

5. **Клиентский код должен будет создавать и объекты строителей, и/(или нет) объект директора**. Перед началом строительства, клиент должен связать определённого строителя с директором. Это можно сделать либо через конструктор, либо через сеттер, либо подав строителя напрямую в в строительный метод директора.

6. **Результат строительства можно вернуть из директора, но только если метод возврата продукта удалось поместить в общий интерфейс строителей. Иначе, вы жёстко привяжете директора к конкретным классам строителей**.

## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |Позволяет создавать продукты пошагово.|Усложняет код программы за счёт дополнительных классов.
 |Позволяет использовать **один и тот же код для создания различных продуктов**. |Клиент будет привязан к конкретным классам строителей, так как **в интерфейсе строителя может не быть метода получения результата**.
 |Изолирует сложный код сборки продукта от его основной бизнес-логики.
 
 
## Отношения с другими паттернами

- Многие архитектуры начинаются с применения [**Фабричного метода**][Factory_Method] (более простого и расширяемого через подклассы) и эволюционируют в сторону [**Абстрактной фабрики**][Abstract_Factory], [**Прототипа**][Prototype] или **Строителя** (более гибких, но и более сложных).

- **Строитель** концентрируется на постройке сложных объектов шаг за шагом. [**Абстрактная фабрика**][Abstract_Factory] специализируется на создании семейств связанных продуктов. **Строитель** возвращает продукт только после выполнения всех шагов, а [**Абстрактная фабрика**][Abstract_Factory] возвращает продукт сразу же.

- **Строитель** позволяет пошагово сооружать дерево [**Компоновщика**][Composite].

- Паттерн **Строитель** может быть построен в виде [**Моста**][Bridge]: директор будет играть роль абстракции, а строители - реализации.

- [**Абстрактная фабрика**][Abstract_Factory], **Строитель** и [**Прототип**][Prototype] могут быть реализованы при помощи [**Одиночки**][Singleton].


[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>

# Абстрактная фабрика 

![UML](/src/AdditionalDocs/uml/Abstract_Factory.png)

Позволяет создавать **семейства связанных объектов**, не привязываясь к конкретным классам создаваемых объектов.(Через общий интерфейс фабрик)

## Применимость

 - Когда бизнес-логика программы должна работать с **разными видами связанных друг с другом продуктов**, не завися от конкретных классов продуктов.

   - Абстрактная фабрика скрывает от клиентского кода подробности того, как и какие конкретно объекты будут созданы. Но при этом клиентский код может работать со всеми типами создаваемых продуктов, так как их общий интерфейс был заранее определён.

 - Когда в программе **уже используется Фабричный метод**, но очередные изменения предполагают введение новых типов продуктов.

   - В хорошей программе, каждый класс отвечает только за одну вещь. **Если класс имеет слишком много фабричных методов**, они способны затуманить его основную функцию. Поэтому имеет смысл вынести всю логику создания продуктов в отдельную иерархию классов, применив абстрактную фабрику.

## Шаги реализации

1. Создайте таблицу соотношений типов продуктов к вариациям семейств продуктов.

2. Сведите все вариации продуктов к общим интерфейсам.

3. Определите **интерфейс абстрактной фабрики**. Он должен иметь **фабричные методы для создания каждого из типов продуктов**.

4. Создайте классы конкретных фабрик, реализовав интерфейс абстрактной фабрики. Этих классов должно быть столько же, сколько и вариаций семейств продуктов.

5. Измените код инициализации программы так, чтобы она создавала определённую фабрику и передавала её в клиентский код.

6. Замените в клиентском коде участки создания продуктов через конструктор вызовами соответствующих методов фабрики.

## Преимущества и недостатки

 | + | - |
 | ------ | ------ |
 |Гарантирует сочетаемость создаваемых продуктов.|Усложняет код программы за счёт **множества дополнительных классов**.
 |Избавляет клиентский код от привязки к конкретным классам продуктов.|Требует наличия всех типов продуктов в каждой вариации.
 |**Выделяет код производства продуктов** в одно место, упрощая поддержку кода.
 |Упрощает добавление новых продуктов в программу.
 |Реализует принцип [**Open/closed**][OCP].
 
 ## Отношения с другими паттернами
 
 - Многие архитектуры начинаются с применения [**Фабричного метода**][Factory_Method] (более простого и расширяемого через подклассы) и эволюционируют в сторону **Абстрактной фабрики**, [**Прототипа**][Prototype] или [**Строителя**][Builder] (более гибких, но и более сложных).
 
 - [**Строитель**][Builder] концентрируется на постройке сложных объектов шаг за шагом. **Абстрактная фабрика** специализируется на создании семейств связанных продуктов. [**Строитель**][Builder] возвращает продукт только после выполнения всех шагов, а **Абстрактная фабрика** возвращает продукт сразу же.
 
 - Классы **Абстрактной фабрики** чаще всего реализуются с помощью [**Фабричного метода**][Factory_Method], хотя они могут быть построены и на основе [**Прототипа**][Prototype].
 
- **Абстрактная фабрика** может быть использована вместо [**Фасада**][Facade] для того, чтобы скрыть платформо-зависимые классы.
 
 - **Абстрактная фабрика** может работать совместно с [**Мостом**][Bridge]. Это особенно полезно, если у вас есть абстракции, которые могут работать только с некоторыми из реализаций. В этом случае фабрика будет определять типы создаваемых абстракций и реализаций.
 
 - **Абстрактная фабрика**, [**Строитель**][Builder] и [**Прототип**][Prototype] могут быть реализованы при помощи [**Одиночки**][Singleton].
 
 
[OCP]: </src/AdditionalDocs/SOLID/Open-Closed_principle.md>
 
 
[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>


# 1. Фабрика
**Фабрика** - это **общая концепция проектирования функций, методов и классов**, когда какая-то одна часть программы отвечает за создание других частей программы.

Вы можете услышать слово Фабрика от других людей, когда они имеют в виду:

 - функцию или метод создающую все объекты программы;
 - класс, создающий пользователей системы;
 - статический метод, оборачивающий конструктор класса;
 - один из классических фабричных паттернов, приведённых ниже.

# 2. Создающий метод
**Создающий метод** - это простой метод-обёртка над вызовом конструктора продукта. Выделив создающий метод, вы изолируете любые изменения в конструировании продуктов от основного кода. Например, вы можете вовсе убрать вызов конструктора из создающего метода, отдавая вместо нового какой-то существующий объект.

Многие называют его фабричным методом, только потому, что он создаёт новые объекты. Типичная логика: *«этот метод создаёт объекты, а раз все фабрики создают что-то, значит этот метод - фабричный»*. И это вносит основную путаницу между понятием **Создающего метода** и паттерном **Фабричный метод**.

В этом примере, метод next является создающим методом:

```java
class Number {
    private String value;

    public Number(String value) {
        this.value = value;
    }

    public Number next() {
        return new Number (value + 1);
    }
}
```

# 3. Статический фабричный метод

**Статический фабричный метод** - **вариация создающего метода, объявленная как `static`**. Если этот метод создаёт объекты своего же класса, то, по сути, он выступает в роли альтернативного конструктора. Это может быть полезно, если:

  - **Требуется создать разные по функциональности конструкторы, у которых бы совпадали сигнатуры** (например, `Random(int max)` и `Random(int min)`). Это невозможно во многих языках программирования, но создав статический метод, вы можете обойти это ограничение.

  - **Хочется повторно использовать готовые объекты, вместо создания новых (например, паттерн Одиночка)**. При вызове конструктора вы всегда создаёте новый объект. Это можно обойти, если вынести вызов конструктора в новый метод. В этом методе вы можете сначала поискать готовый объект в каком-то кеше, и только если его нет, создать новый объект.

В следующем примере,**метод load является статическим фабричным методом** - он предоставляет удобный способ загрузить пользователя из базы данных.

```java
class User {
    private String name, email, phone;

    public User(String name, String email,String phone) {
        this.name = name;
        this.email = email;
        this.phone = phone;
    }

    public static User load(String name) {
      User user = DB.load_data(name);
      if (user == null) 
        user = new User(name, "email", "phone");
        return user;
    }
}
```

# 4. Паттерн Простая фабрика

**Паттерн Простая фабрика** - это класс, в котором есть **один метод с большим условным оператором**, выбирающим создаваемый продукт. Этот метод вызывают с неким параметром, по которому определяется какой из продуктов нужно создать. У простой фабрики, обычно, нет подклассов.

Обычно, простую фабрику путают с общим понятием **Фабрики** или с любым из **фабричных паттернов**.

Если объявить класс простой фабрики абстрактным (Java, C#), это не сделает его одним и тем же, что и абстрактная фабрика!

Вот пример простой фабрики:

```java
class UserFactory {
    public static function create(String type) {
        switch (type) {
           case "user": return new User();
           case "customer": return new Customer();
           case "admin": return new Admin();
            default:
                throw new Exception("Wrong user type passed.");
        }
    }
}
```

**Простая фабрика находится в шаге от того, чтобы стать Фабричным методом**.

# 5. Паттерн Фабричный метод
**Паттерн Фабричный метод** - **это устройство классов**, при котором подклассы могут переопределять тип создаваемого в суперклассе продукта.

**Если вы имеете иерархию продуктов и абстрактный создающий метод, который переопределяется в подклассах, то перед вами паттерн Фабричный метод**.

```java
class Department {
    public abstract Employee createEmployee(int id);

    public void fire(int id) {
        employee = this.createEmployee(id);
        employee.paySallary();
        employee.dismiss();
    }
}

class ITDepartment extends Department {
    @Override
    public Employee createEmployee(int id) {
        return new Programmer(id);
    }
}

class AccountingDepartment extends Department {
    @Override
    public Employee createEmployee(int id) {
        return new Accountant(id);
    }
}
```
# 6. Паттерн Абстрактная фабрика
**Паттерн Абстрактная фабрика** - **это устройство классов**, облегчающее создание семейств продуктов.

Что такое семейство продуктов? Например, классы Транспорт + Двигатель +  Управление. Вариациями этого семейства могут стать:

*Автомобиль + Двигатель Внутреннего Сгорания + Руль*

*Самолет + Реактивный Двигатель + Штурвал*

**Если у вас нет семейств продуктов, значит не может быть и абстрактной фабрики.**

Многие путают паттерн абстрактная фабрика с классом простой фабрики, объявленным как `abstract`, но это далеко не одно и то же!

 # Фабричный метод
 
 ![UML](/src/AdditionalDocs/uml/Factory_Method.png)
 
**Фабричный метод** - определяет общий интерфейс для создания объектов в суперклассе, позволяя **подклассам изменять тип создаваемых объектов**.

 ## Применимость
 
 - Когда **заранее неизвестны типы и зависимости объектов**, с которыми должен работать ваш код.

   - Фабричный метод **отделяет код производства продуктов** от остального кода, который эти продукты использует.

     Благодаря этому, код производства **можно расширять, не трогая основной код**. Так, чтобы добавить поддержку нового продукта, вам нужно создать новый подкласс и определить в нём фабричный метод, возвращая оттуда экземпляр нового продукта.

 - Когда вы хотите дать возможность пользователям **расширять части вашего фреймворка или библиотеки**.

   - Пользователи могут расширять классы вашего фреймворка через **наследование**. Но как сделать так, чтобы фреймворк создавал объекты из этих новых классов, а не из стандартных?

     Решением будет дать пользователям возможность **расширять не только желаемые компоненты, но и классы, которые создают эти компоненты**. А для этого создающие классы должны иметь конкретные создающие методы, которые можно определить.

     Например, вы используете готовый UI фреймворк для своего приложения. Но вот беда, требуется иметь круглые кнопки, вместо стандартных прямоугольных. Вы создаёте класс RoundButton. Но как сказать главному классу фреймворка (UIFramework), чтобы он теперь создавал круглые кнопки, вместо стандартных.

     Для этого вы создаёте подкласс UIWithRoundButtons из базового класса фреймворка, переопределяете в нём метод создания кнопки (createButton) и вписываете туда создание своего класса кнопок. Затем, используете  UIWithRoundButtons вместо стандартного UIFramework.

 - Когда вы хотите экономить системные ресурсы, повторно **используя уже созданные объекты, вместо создания новых**.

   - Такая проблема обычно возникает при работе с тяжёлыми ресурсоёмкими объектами, такими как подключение к базе данных, файловой системе и т.д.

Представьте, сколько действий вам нужно совершить, чтобы повторно использовать существующие объекты:

 1. Сперва вам следует создать общее хранилище, чтобы хранить вы нём все создаваемые объекты.
 2. При запросе нового объекта, нужно будет заглянуть в хранилище и проверить, есть ли там неиспользуемый объект.
 3. А затем вернуть его клиентскому коду.
 4. Но если свободных объектов нет - создать новый, не забыв добавить его в хранилище.
 
**Весь этот код нужно куда-то поместить, чтобы не засорять клиентский код.**

 ## Шаги реализации

1. Приведите все создаваемые продукты к **общему интерфейсу**.

2. В классе, который производит продукты, создайте **пустой фабричный метод**. В качестве возвращаемого типа укажите общий интерфейс продукта.

3. Затем, пройдитесь по коду класса и найдите все участки, **создающие продукты**. Поочерёдно **замените эти участки вызовами фабричного метода**, перенося в него код создания различных продуктов.

   В фабричный метод, возможно, придётся добавить несколько параметров, контролирующих какой из продуктов нужно создать.

4. Для каждого типа продуктов заведите подкласс и **переопределите в нём фабричный метод**. Переместите туда код создания соответствующего продукта из суперкласса.

4. Если создаваемых продуктов слишком много для существующих подклассов создателя, вы можете подумать о введении параметров в фабричный метод, которые позволят возвращать различные продукты в пределах одного подкласса.
(**объединить по смыслу продукты в 1 фабрику**)

*Например, у вас есть класс Почта с подклассами АвиаПочта и НаземнаяПочта, а также классы продуктов Самолёт, Грузовик и Поезд. Авиа соответствует  Самолётам, но для НаземнойПочты есть сразу два продукта. Вы могли бы создать новый подкласс почты для поездов, но проблему можно решить и по-другому. Клиентский код может передавать в фабричный метод НаземнойПочты аргумент, контролирующий какой из продуктов будет создан.*

5. Если после всех перемещений **фабричный метод стал пустым**, можете сделать его **абстрактным**. Если в нём что-то осталось - это будет его реализацией по умолчанию.

 ## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |Избавляет класс от привязки к конкретным классам продуктов.|Может привести к созданию **больших параллельных иерархий классов**, так как для каждого класса продукта надо создать свой подкласс создателя.
 |**Выделяет код производства продуктов** в одно место, упрощая поддержку кода.
 |Упрощает добавление новых продуктов в программу.
 |Реализует принцип [**открытости/закрытости**][OCP].

 ## Отношения с другими паттернами

 - Многие архитектуры начинаются с применения **Фабричного метода** (более простого и расширяемого через подклассы) и эволюционируют в сторону [**Абстрактной фабрики**][Abstract_Factory], [**Прототипа**][Prototype] или [**Строителя**][Builder] (более гибких, но и более сложных).

 - Классы [**Абстрактной фабрики**][Abstract_Factory] чаще всего реализуются с помощью **Фабричного метода**, хотя они могут быть построены и на основе [**Прототипа**][Prototype].

 - **Фабричный метод** можно использовать вместе с [**Итератором**][Iterator], чтобы подклассы коллекций могли создавать подходящие им итераторы.

 - [**Прототип**][Prototype] не опирается на наследование, но ему нужна сложная операция инициализации. **Фабричный метод** наоборот, построен на наследовании, но не требует сложной инициализации.

 - **Фабричный метод** можно рассматривать как частный случай [**Шаблонного метода**][Template_Method]. Кроме того, **Фабричный метод** нередко бывает частью большого класса с [**Шаблонными методами**][Template_Method].

[OCP]: </src/AdditionalDocs/SOLID/Open-Closed_principle.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>

# Объектный пул

![UML](/src/AdditionalDocs/uml/ObjectPool.png)

Набор инициализированных и **готовых к использованию объектов**. Когда системе требуется объект, он не создаётся, а берётся из пула. Когда объект больше не нужен, он не уничтожается, а возвращается в пул.

**!!!**

*Не рекомендуется использовать объединение объектов с определенными языками, такими как **Java**, особенно для объектов, которые используют только память и не имеют внешних ресурсов. Распределение объектов относительно **быстро на современных языках со сборщиками мусора**; Большинство сборщиков мусора сканируют «живые» ссылки на объекты, а не память, которую эти объекты используют для своего контента. Это означает, что любое количество «мертвых» объектов без ссылок может быть отброшено с минимальными затратами. Напротив, **сохранение большого количества «живых», но неиспользуемых объектов увеличивает продолжительность сбора мусора.***

**!!!**

Java supports thread pooling via java.util.concurrent.ExecutorService and other related classes.

## Применимость

- Когда **создание объекта в начале работы и уничтожение его в конце приводит к большим затратам**.
 
  - Особенно заметно повышение производительности, когда объекты **часто создаются-уничтожаются, но одновременно существует лишь небольшое их число**.
  
- Когда есть нескольким клиентам нужен **один и тот же ресурс в разное время**.

## Шаги реализации

1. Создайте класс `ObjectPool` с `private` массивом объектов внутри;

2. Создайте `acquire и release` методы в классе `ObjectPool`;

3. Убедитесь, что ваш **ObjectPool** - [**Singleton**][Singleton]

## Преимущества и недостатки

 | + | - |
 | ------ | ------ |
|Повышает производительность приложения| **JAVA использует сборщик мусора**|
|управляет соединениями и обеспечивает способ повторного использования и обмена ими|Существуют ["ловушки"](https://en.wikipedia.org/wiki/Object_pool_pattern) при использовании таких объектов|
|Может предоставить ограничение для максимального количества объектов, которые могут быть созданы|

## Отношения с другими паттернами

- [**Фабричный метод**][Factory_method] может использоваться для инкапсуляции логики создания объектов. Однако после их создания он не управляет ими,  **Пул объектов** отслеживает созданные им объекты.
 
- Пулы объектов обычно реализуются как [**Singleton**][Singleton].

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Object_Pool]: </src/Creational/Object_Pool/Object_Pool.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>

# Прототип

![UML](/src/AdditionalDocs/uml/Prototype.png)

Позволяет создавать новые объекты на основе некоторого объекта-прототипа.

## Применимость
 
 - Когда ваш **код не должен зависеть от классов копируемых объектов**.

   - Такое часто бывает, если ваш код работает с объектами, поданными извне через какой-то общий интерфейс. Вы не можете привязаться к их классам, даже если бы хотели, так как их конкретные классы неизвестны.

     Паттерн **Прототип** предоставляет клиенту общий интерфейс для работы со всеми прототипами. Клиенту **не нужно зависеть от всех классов копируемых объектов, а только от интерфейса клонирования**.

 - Когда вы имеете уйму подклассов, которые отличаются начальными значениями полей. Кто-то создал эти классы, чтобы быстро создавать объекты с определённой конфигурацией.

   - **Прототип** предлагает использовать набор прототипов, вместо создания подклассов для популярных конфигураций объектов.

    Таким образом, вместо порождения объектов из подклассов, вы будете копировать существующие объекты-прототипы, в которых уже настроено внутреннее состояние. Это позволит избежать взрывного роста количества классов в программе и уменьшить её сложность.

## Шаги реализации
!!!

(Поверхностное копирование)
- [Конструктор копирования][Ex1]

(Глубокое копирование)
- [Cloneable][Ex2]
- [Serialization][Ex3]

!!!

1. Создайте **интерфейс прототипов с единственным методом clone (Cloneable)**. Если у вас уже есть иерархия продуктов, метод клонирования можно объявить непосредственно в каждом из её классов.

2. Добавьте **в классы будущих прототипов альтернативный конструктор, принимающий в качестве аргумента объект текущего класса**. Этот конструктор должен скопировать из поданного объекта значения всех полей, объявленных в рамках текущего класса, а затем передать выполнение родительскому конструктору, чтобы тот позаботился об остальных полях.

   Если ваш язык программирования не поддерживает перегрузку методов, то копирование значений можно проводить и в другом методе, специально созданном для этих целей. Конструктор удобнее тем, что позволяет клонировать объект за один вызов.

3. **Метод клонирования обычно состоит всего из одной строки: вызова оператора new с конструктором прототипа. Все классы, поддерживающие клонирование, должны явно определить метод clone, чтобы подать собственный класс в оператор new. В обратном случае, результатом клонирования окажется объект родительского класса**.

4. Опционально, создайте **центральное хранилище прототипов**. В нём можно хранить вариации объектов, возможно даже одного класса, но по-разному настроенных.

   Вы можете разместить это хранилище либо в новом фабричном классе, либо в фабричном методе базового класса прототипов. Такой фабричный метод должен на основании входящих аргументов искать в каталоге прототипов подходящий экземпляр, а затем вызывать его метод клонирования и возвращать полученный объект.

    Наконец, нужно будет избавиться от прямых вызовов конструкторов объектов, заменив их вызовами фабричного метода хранилища прототипов.

 ## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |Позволяет клонировать объекты, не привязываясь к их конкретным классам.|Сложно клонировать составные объекты, имеющие ссылки на другие объекты.
 |Меньше повторяющегося кода инициализации объектов.
 |Ускоряет создание объектов.
 |Альтернатива созданию подклассов для конструирования сложных объектов.
 
## Отношения с другими паттернами

- Многие архитектуры начинаются с применения [**Фабричного метода**][Factory_method] (более простого и расширяемого через подклассы) и эволюционируют в сторону [**Абстрактной фабрики**][Abstract_Factory], **Прототипа** или [**Строителя**][Builder] (более гибких, но и более сложных).

- Классы [**Абстрактной фабрики**][Abstract_Factory] чаще всего реализуются с помощью [**Фабричного метода**][Factory_method], хотя они могут быть построены и на основе **Прототипа**.

- Если [**Команду**][Command] нужно копировать перед вставкой в историю выполненных команд, вам может помочь **Прототип**.

- Архитектура, построенная на [**Компоновщиках**][Composite] и [**Декораторах**][Decorator], часто может быть улучшена за счёт внедрения **Прототипа**. Он позволяет клонировать сложные структуры объектов, а не собирать их заново.

- **Прототип** не опирается на наследование, но ему нужна сложная операция инициализации. [**Фабричный метод**][Factory_method] наоборот, построен на наследовании, но не требует сложной инициализации.

- [**Снимок**][Memento] иногда можно заменить **Прототипом**, если объект, чьё состояние требуется сохранять в истории, довольно простой, не имеет активных ссылок на внешние ресурсы, либо их можно легко восстановить.

- [**Абстрактной фабрика**][Abstract_Factory], [**Строитель**][Builder] и **Прототип** могут быть реализованы при помощи [**Одиночки**][Singleton]. 

[Ex1]: </src/Creational/Prototype/Example/CopyConstructor/>
[Ex2]: </src/Creational/Prototype/Example/WithJDK/>
[Ex3]: </src/Creational/Prototype/Example/Serialization/>

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>

# Одиночка

![UML](/src/AdditionalDocs/uml/Singleton.png)

Гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

**Одиночка** решает сразу две проблемы **(нарушая принцип единственной ответственности класса)**.

## Применимость
  - Когда в программе **должен быть единственный экземпляр** какого-то класса, доступный всем клиентам (например, общий доступ к базе данных из разных частей программы).

    - Одиночка **скрывает от клиентов все способы создания нового объекта**, кроме специального метода. Этот метод либо создаёт объект, либо отдаёт существующий объект, если он уже был создан.

  - Когда вам хочется иметь больше контроля над глобальными переменными.

    - В отличие от глобальных переменных, **Одиночка** гарантирует, что никакой другой код не заменит созданный экземпляр класса, поэтому вы всегда уверены в наличие лишь одного объекта-одиночки.

      Тем не менее, в любой момент вы можете расширить это ограничение и позволить любое количество объектов-одиночек, поменяв код в одном месте (метод `getInstance()`).

 ## Шаги реализации
1. Добавьте в класс **приватное статическое поле** (+ `volatile` ), которое будет содержать одиночный объект.

2. Объявите **статический создающий метод**(+ `synchronized` ), который будет использоваться для получения одиночки.

3. Добавьте **«ленивую инициализацию»** (создание объекта при первом вызове метода) в создающий метод одиночки.

4. Сделайте **конструктор класса приватным**.

5. В клиентском коде замените вызовы конструктора вызовами создающего метода.

 ## Преимущества и недостатки
 | + | - |
 | ------ | ------ |
 |Гарантирует наличие единственного экземпляра класса. |Нарушает принцип единственной ответственности класса.
 |Предоставляет к нему глобальную точку доступа. |Маскирует плохой дизайн.
 |Реализует отложенную инициализацию объекта-одиночки. |Проблемы мультипоточности.
 | |Требует постоянного создания Mock-объектов при юнит-тестирования.


 
 ## Отношения с другими паттернами

- [**Фасад**][Facade] можно сделать **Одиночкой**, так как обычно нужен только один объект-фасад.

- Паттерн [**Легковес**][Flyweight] может напоминать **Одиночку**, если для конкретной задачи у вас получилось уменьшить количество объектов к одному. Но помните, что между паттернами есть два кардинальных отличия:

    1. В отличие от **Одиночки**, вы можете иметь множество объектов-легковесов.
    2. Объекты-легковесов должны быть неизменяемыми, тогда как объект-одиночки допускает изменение своего состояния.
 
- [**Абстрактная фабрика**][Abstract_Factory], [**Строитель**][Builder] и [**Прототип**][Prototype] могут быть реализованы при помощи **Одиночки**.


[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>

# Адаптер

![UML](/src/AdditionalDocs/uml/Adapter.png)

**Преобразует интерфейс класса к другому интерфейсу**, на который рассчитан клиент. Обеспечивает совместную работу классов, невозможную в обычных условиях из-за несовместимости интерфейсов.

## Применимость

 - Когда вы хотите использовать сторонний класс, но его **интерфейс не соответствует остальному коду приложения**.

   - Адаптер позволяет создать объект-прокладку, который будет превращать вызовы приложения в формат, понятный стороннему классу.

 - Когда вам нужно использовать несколько существующих подклассов, но в них **не хватает какой-то общей функциональности**. Причём **расширять суперкласс вы не можете** (Похоже на [**Декоратор**][Decorator]).

   - Вы могли бы создать ещё один уровень подклассов, и добавить в них недостающую функциональность. Но при этом *придётся дублировать один и тот же код в обеих ветках подклассов*.

     Более элегантное решение - **поместить недостающую функциональность в адаптер и приспособить его для работы с суперклассом**. Такой адаптер сможет работать со всеми подклассами иерархии. Это решение будет сильно напоминать паттерн [**Посетитель**][Visitor].

 ## Шаги реализации

1. Убедитесь, что у вас есть **два класса с неудобными интерфейсами**:

   - *полезный сервис* - служебный класс, который вы не можете изменять (он либо сторонний, либо от него зависит другой код);
 
   - *один или несколько клиентов* - классов приложения, несовместимых с сервисом из-за неудобного или несовпадающего интерфейса.

2. Опишите клиентский интерфейс, через который классы приложения смогли бы использовать сторонний класс.

3. Создайте класс адаптера, реализовав этот интерфейс.

4. **Поместите в адаптер поле-ссылку на объект-сервис**. В большинстве случаев, это поле заполняется объектом, переданным в конструктор адаптера. В случае простой адаптации этот объект можно передавать через параметры методов адаптера.

5. Реализуйте все методы клиентского интерфейса в адаптере. **Адаптер должен делегировать основную работу сервису**.

6. Приложение должно использовать адаптер только через клиентский интерфейс. Это позволит легко изменять и добавлять адаптеры в будущем.

## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |Отделяет и скрывает от клиента подробности преобразования различных интерфейсов.|Усложняет код программы за счёт дополнительных классов.
 
## Отношения с другими паттернами
 
 - [**Мост**][Bridge] проектируют загодя, чтобы развивать большие части приложения отдельно друг от друга. **Адаптер** применяется постфактум, чтобы заставить несовместимые классы работать вместе.

 - **Адаптер** меняет интерфейс существующего объекта. [**Декоратор**][Decorator] улучшает другой объект без изменения его интерфейса. Причём [**Декоратор**][Decorator] поддерживает рекурсивную вложенность, чего не скажешь об **Адаптере**.

 - **Адаптер** предоставляет классу альтернативный интерфейс. [**Декоратор**][Decorator] предоставляет расширенный интерфейс. [**Заместитель**][Proxy] предоставляет тот же интерфейс.

 - [**Фасад**][Facade] задаёт новый интерфейс, тогда как **Адаптер** повторно использует старый. **Адаптер** оборачивает только один класс, а [**Фасад**][Facade] оборачивает целую подсистему. Кроме того, **Адаптер** позволяет двум существующим интерфейсам работать сообща, вместо того, чтобы задать полностью новый.

 - [**Мост**][Bridge], [**Стратегия**][Strategy] и [**Состояние**][State] (а также слегка и **Адаптер**) имеют схожие структуры классов - все они построены на принципе [**«композиции»**][Composition], то есть делегирования работы другим объектам. Тем не менее, они отличаются тем, что решают разные проблемы. Помните, что паттерны - это не только рецепт построения кода определённым образом, но и описание проблем, которые привели к данному решению.


[Composition]: </src/AdditionalDocs/Composition.md>

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>

# Мост

![UML](/src/AdditionalDocs/uml/Bridge/Bridge.png)

Разделяет один или несколько классов на **две отдельные иерархии - абстракцию и реализацию**, позволяя изменять их независимо друг от друга.

 ***«Абстракция»*** (или *«интерфейс»*) - это образный слой управления чем-либо. Он не делает работу самостоятельно, а **делегирует её слою *«реализации»* (иногда называемому *«платформой»*)**.

!!!
**Только не путайте эти термины с интерфейсами или абстрактными классами из вашего языка программирования, это не одно и то же.**

Если говорить о реальных программах, то **абстракцией может выступать графический интерфейс программы**, а **реализацией - API к которому интерфейс обращается по реакции на действия пользователя**.

## Применимость
 
 - Когда вы хотите разделить монолитный класс, который содержит **несколько различных реализаций какой-то функциональности (например, может работать с разными системами баз данных)**.

   - Чем больше класс, тем тяжелее разобраться в его коде, тем больше это затягивает разработку. Кроме того, изменения, вносимые в одну из реализаций, приводят к редактированию всего класса, что может привести к ошибкам.

      **Мост** позволяет разделить монолитный класс на несколько отдельных иерархий. После этого вы можете менять их код независимо друг от друга. Это упрощает работу над кодом и уменьшает вероятность внесения ошибок.

 - Когда класс нужно **расширять в двух независимых плоскостях**.

    - **Мост** предлагает выделить одну из таких плоскостей в отдельную иерархию классов, **храня ссылку на один из её объектов в первоначальном классе**.

 - Когда вы хотите, чтобы **реализацию можно было бы изменять во время выполнения программы**.

   - **Мост** позволяет заменять реализацию даже во время выполнения программы, так как конкретная реализация не «вшита» в класс абстракции.

     Кстати, из-за этого пункта **Мост** часто путают со [**Стратегией**][Strategy]. Обратите внимания, что у **Моста** этот пункт стоит на последнем месте по значимости, так как его **главная задача - структурная**.

## Шаги реализации
 
1. Определите, существует ли в ваших классах **два непересекающихся измерения**. Это может быть **функциональность/платформа, предметная-область/инфраструктура, фронт-энд/бэк-энд или интерфейс/реализация**.

2. Продумайте, какие операции будут нужны клиентам и опишите их в базовом классе абстракции.

3. **Определите поведения доступные на всех платформах** и выделите из них ту часть, **которая будет нужная абстракции**. На основании этого опишите общий интерфейс реализации.

4. Для каждой платформы создайте свой класс конкретной реализации. Все они должны следовать общему интерфейсу, который мы выделили перед этим.

5. **Добавьте в класс абстракции ссылку на объект реализации**. Реализуйте методы абстракции, **делегируя основную работу связанному объекту реализации**.

6. Если у вас есть несколько вариаций абстракции, создайте для каждой из них свой подкласс.

7. Клиент должен **подать объект реализации в конструктор абстракции**, чтобы связать их воедино. После этого он может свободно использовать объект абстракции, забыв о реализации.

## Преимущества и недостатки
 
  | + | - |
  | ------ | ------ |
 |Позволяет строить платформо-независимые программы.|Усложняет код программы за счёт дополнительных классов.
 |Скрывает лишние или опасные детали реализации от клиентского кода.
 |Реализует принцип [**открытости/закрытости**][OCP].
 
 ## Отношения с другими паттернами

- **Мост** проектируют загодя, чтобы развивать большие части приложения отдельно друг от друга. [**Адаптер**][Adapter] применяется постфактум, чтобы заставить несовместимые классы работать вместе.

- **Мост**, [**Стратегия**][Strategy] и [**Состояние**][State] (а также слегка и [**Адаптер**][Adapter]) имеют схожие структуры классов - все они построены на принципе [**«композиции»**][Composition], то есть делегирования работы другим объектам. Тем не менее, они отличаются тем, что решают разные проблемы. Помните, что паттерны - это не только рецепт построения кода определённым образом, но и описание проблем, которые привели к данному решению.

- [**Абстрактная фабрика**][Abstract_Factory] может работать совместно с **Мостом**. Это особенно полезно, если у вас есть абстракции, которые могут работать только с некоторыми из реализаций. В этом случае фабрика будет определять типы создаваемых абстракций и реализаций.

- Паттерн [**Строитель**][Builder] может быть построен в виде **Моста**: директор будет играть роль абстракции, а строители - реализации.

[OCP]: </src/AdditionalDocs/SOLID/Open-Closed_principle.md>
[Composition]: </src/AdditionalDocs/Composition.md>

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>

# Компоновщик

![UML](/src/AdditionalDocs/uml/Composite/Composite.png)

Объединяет объекты в **древовидную структуру** для представления иерархии от частного к целому. **Компоновщик** позволяет клиентам **обращаться к отдельным объектам и к группам объектов одинаково**.

**Лист** - это простой элемент дерева, не имеющий ответвлений.

**Контейнер** (или *«композит»* или **узел**) - это составной элемент дерева. Он содержит набор дочерних компонентов, но ничего не знает об их типах. Это могут быть как простые компоненты-листья, так и другие компоненты-контейнеры. Но это не является проблемой, так как все дочерние элементы следуют общему интерфейсу.

## Применимость

 - Когда вам нужно представить **древовидную структуру** объектов.

   - Паттерн **Компоновщик** предлагает хранить в составных объектах ссылки на другие простые или составные объекты. Те, в свою очередь, тоже могут хранить свои вложенные объекты и так далее. В итоге вы можете строить сложную древовидную структуру данных, используя всего две основные разновидности объектов.

 - Когда клиенты должны **единообразно трактовать простые и составные объекты**.

   - Благодаря тому, что **простые и составные объекты реализуют общий интерфейс**, клиенту безразлично с каким именно объектом ему предстоит работать.

## Шаги реализации

1. Убедитесь, что вашу бизнес-логику можно представить как **древовидную структуру**. Попытайтесь разбить её на простые элементы и контейнеры. Помните, что **контейнеры могут содержать как простые элементы, так и другие контейнеры**.

2. Создайте **общий интерфейс компонентов**, который объединит операции контейнеров и простых элементов дерева. **Интерфейс будет удачным, если вы сможете взаимозаменять простые и составные компоненты без потери смысла**.

3. Создайте класс компонентов-листьев, не имеющих дальнейших ответвлений. Имейте в виду, что программа может содержать несколько видов таких классов.

4. Создайте класс компонентов-контейнеров, и добавьте в него **массив для хранения ссылок на вложенные компоненты**. Этот массив должен быть способен содержать как простые, так и составные компоненты, поэтому убедитесь, что **он объявлен с типом интерфейса компонентов**.

    Реализуйте в контейнере методы интерфейса компонентов, помня о том, что **контейнеры должны делегировать основную работу своим дочерним компонентам**.

5. Добавьте операции **добавления и удаления дочерних элементов в класс контейнеров**.

   [(Ex)](/src/Structural/Composite/Example/Simple_No_ISP/) Имейте в виду, что **методы добавления/удаления дочерних элементов можно поместить и в интерфейс компонентов**. Да, это **нарушит принцип разделения интерфейса**, так как реализации методов будут пустыми в компонентах-листьях. **Но зато все компоненты дерева станут действительно одинаковыми для клиента**.

## Преимущества и недостатки

| + | - |
| ------ | ------ |
|Упрощает архитектуру клиента при работе со сложным деревом компонентов.|**Создаёт слишком общий дизайн классов**.
|Облегчает добавление новых видов компонентов.

 
 ## Отношения с другими паттернами

- [**Строитель**][Builder] позволяет пошагово сооружать дерево **Компоновщика**.

- [**Цепочку обязанностей**][Chain_of_Responsibility] часто используют вместе с **Компоновщиком**. В этом случае, запрос передаётся от дочерних компонентов к их родителям.

- [(Ex)](/src/Structural/Composite/Example/With_Iterator/)Вы можете обходить дерево **Компоновщика**, используя [**Итератор**][Iterator].

- Вы можете выполнить какое-то действие над всем деревом **Компоновщика** при помощи [**Посетителя**][Visitor].

- **Компоновщик** часто совмещают с [**Легковесом**][Flyweight], чтобы реализовать общие ветки дерева и сэкономить при этом память.

- **Компоновщик** и [**Декоратор**][Decorator] имеют похожие структуры классов из-за того, что оба построены на рекурсивной вложенности. Она позволяет связать в одну структуру бесконечное количество объектов.

  [**Декоратор**][Decorator] оборачивает только один объект, а узел **Компоновщика** может иметь много детей. [**Декоратор**][Decorator] добавляет вложенному объекту новую функциональность, а **Компоновщик** не добавляет ничего нового, но «суммирует» результаты всех своих детей.

  Но они могут и сотрудничать: **Компоновщик** может использовать [**Декоратор**][Decorator], чтобы переопределить функции отдельных частей дерева компонентов.

- Архитектура, построенная на **Компоновщиках** и [**Декораторах**][Decorator], часто может быть улучшена за счёт внедрения [**Прототипа**][Prototype]. Он позволяет клонировать сложные структуры объектов, а не собирать их заново.

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>

# Декоратор 

![UML](/src/AdditionalDocs/uml/Decorator.png)

Позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».

 **Декоратор** имеет альтернативное название - «обёртка». Оно удачнее описывает суть паттерна: вы **помещаете целевой объект в другой объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к результату что-то своё**.

1. Декораторы **имеют тот же супертип**, что и декорируемые объекты;

2. Объект можно завернуть в 1 или несколько декораторов;

3. (из 1 следует) можно передать декорируемый объект вместо исходного;

4. Декоратор **добавляет свое действие до и/или после делегирования операций декорируемому объекту**, выполняющему остальную роботу 

5. Объект может быть **декорирован** в любой момент времени, т.е. **динамически и с произвольным кол. декораторов**.

!!! 
**Если программировать на уровне конкретного объекта Декоратор не подходит**.

## Применимость

 - Когда вам нужно **добавлять обязанности объектам на лету**, незаметно для кода, который их использует.

   - Объекты помещают в обёртки, имеющие дополнительные поведения. Обёртки и сами объекты имеют одинаковый интерфейс, поэтому клиентам без разницы с чем работать - с обычным объектом или обёрнутым.

 - Когда **нельзя расширить обязанности объекта с помощью наследования**.

   - Во многих языках программирования есть ключевое слово `final`, которое может заблокировать наследование класса. Расширить такие классы можно только с помощью **Декоратора**.

## Шаги реализации

 1. Убедитесь, что в вашей задаче есть **один основной компонент и несколько опциональных дополнений или надстроек над ним**.

 2. Создайте **интерфейс** компонента, который описывал бы все общие методы как для **основного компонента, так и для его дополнений**.

 3. Создайте **класс конкретного компонента** и поместите в него основную бизнес-логику.

 4. Создайте базовый класс декораторов. Он должен иметь **поле для хранения ссылки на вложенный объект-компонент**. Все методы базового декоратора должны делегировать действие вложенному объекту.

 5. И конкретный компонент, и базовый декоратор должны следовать одному и тому же интерфейсу компонента.

 6. Теперь создайте классы конкретных декораторов, наследуя их от базового декоратора. **Конкретный декоратор должен выполнять свою добавочную функциональность, а затем (или перед этим) вызывать эту же операцию обёрнутого объекта**.

 7. **Клиент берёт на себя ответственность за конфигурацию и порядок обёртывания объектов**.
 
## Преимущества и недостатки

| + | - |
| ------ | ------ |
|Большая гибкость, чем у наследования|Трудно конфигурировать многократно обёрнутые объекты.
|Позволяет добавлять обязанности на лету|**Обилие крошечных классов**. 
|Можно добавлять несколько новых обязанностей сразу.
|Позволяет иметь **несколько мелких объектов вместо одного объекта** на все случаи жизни.

## Отношения с другими паттернами

 - [**Адаптер**][Adapter] меняет интерфейс существующего объекта. **Декоратор** улучшает другой объект без изменения его интерфейса. Причём Декоратор поддерживает рекурсивную вложенность, чего не скажешь об Адаптере.

 - [**Адаптер**][Adapter] предоставляет классу альтернативный интерфейс. **Декоратор** предоставляет расширенный интерфейс. [**Заместитель**][Proxy] предоставляет тот же интерфейс.

 - [**Цепочка обязанностей**][Chain_of_Responsibility] и **Декоратор** имеют очень похожие структуры. Оба паттерна базируются на принципе **рекурсивного выполнения операции через серию связанных объектов**. Но есть и несколько важных отличий.

   Обработчики в [**Цепочке обязанностей**][Chain_of_Responsibility] могут выполнять **произвольные действия, независимые друг от друга,** а также в любой момент **прерывать дальнейшую передачу** по цепочке. С другой стороны Декораторы расширяют какое-то определённое действие, не ломая интерфейс базовой операции и не прерывая выполнение остальных декораторов.

- [**Компоновщик**][Composite] и **Декоратор** имеют похожие структуры классов из-за того, что оба построены на **рекурсивной вложенности**. Она позволяет связать в одну структуру бесконечное количество объектов.

    **Декоратор** оборачивает только один объект, а узел [**Компоновщика**][Composite] может иметь много детей. **Декоратор** добавляет вложенному объекту новую функциональность, а [**Компоновщик**][Composite] не добавляет ничего нового, но «суммирует» результаты всех своих детей.

    Но они могут и сотрудничать: [**Компоновщик**][Composite] может использовать **Декоратор**, чтобы переопределить функции отдельных частей дерева компонентов.

 - Архитектура, построенная на [**Компоновщиках**][Composite] и **Декораторах**, часто может быть улучшена за счёт внедрения [**Прототипа**][Prototype]. Он позволяет **клонировать сложные структуры объектов, а не собирать их заново**.

 - [**Стратегия**][Strategy] меняет поведение объекта **«изнутри»**, а **Декоратор** изменяет его **«снаружи»**.

 - **Декоратор** и [**Заместитель**][Proxy] имеют похожие структуры, но разные назначения. Они похожи тем, что оба построены на **композиции и делегировании** работы другому объекту. Паттерны отличаются тем, что [**Заместитель**][Proxy] **сам управляет жизнью сервисного объекта**, а обёртывание **Декораторов** контролируется клиентом.

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>

# Фасад

![UML](/src/AdditionalDocs/uml/Facade.png)

Предоставляет **унифицированный интерфейс к группе интерфейсов подсистемы**. Фасад определяет высокоуровневый интерфейс, упрощая работу с подсистемой 

## Применимость

 - Когда вам нужно представить **простой или урезанный интерфейс к сложной подсистеме**.

   - Часто подсистемы усложняются по мере развития. Применение большинства паттернов приводит к появлению меньших классов, но в большем количестве. Такую подсистему проще повторно использовать и настраивать под конкретные нужды, но вместе с тем применять подсистему без настройки становится труднее. **Фасад** предлагает некоторый вид системы по умолчанию, устраивающий большинство клиентов.

 - Когда вы хотите **разложить подсистему на отдельные слои**.

    - Используйте фасады для определения точек входа на каждый уровень подсистемы. Если подсистемы зависят друг от друга, то зависимость можно упростить, разрешив подсистемам обмениваться информацией только через фасады.

      *Например, возьмём ту же сложную система видеоконвертации. Вы хотите разбить её на слои работы с аудио и видео. Для каждой из этих частей можно попытаться создать фасад и заставить классы аудио и видео обработки общаться друг с другом через эти фасады, а не напрямую.*

 ## Шаги реализации
 
1. Определите можно ли создать **более простой интерфейс, чем тот, который предоставляет сложная подсистема**. Вы на правильном пути, если этот интерфейс избавит клиента от знания о подробностях подсистемы.

2. Создайте класс фасада, реализующий этот интерфейс. Он должен переадресовывать вызовы клиента нужным объектам подсистемы. **Фасад должен будет позаботиться о том, чтобы правильно инициализировать объекты подсистемы**.

3. Вы получите максимум пользы, если **клиент будет работать только с фасадом**. В этом случае, изменения в подсистеме будут затрагивать только код фасада, а клиентский код останется рабочим.

4. **Если ответственность фасада начинает размываться, подумайте о введении дополнительных фасадов**.

 ## Преимущества и недостатки
  
 | + | - |
 | ------ | ------ |
 |Изолирует клиентов от компонентов системы.|Фасад рискует стать [**божественным объектом**][God-Object], привязанным ко всем классам программы.
 |Уменьшает зависимость между подсистемой и клиентами.
 
 ## Отношения с другими паттернами

 - **Фасад** задаёт новый интерфейс, тогда как [**Адаптер**][Adapter] повторно использует старый. [**Адаптер**][Adapter] оборачивает только один класс, а **Фасад** оборачивает целую подсистему. Кроме того, [**Адаптер**][Adapter] позволяет двум существующим интерфейсам работать сообща, вместо того, чтобы задать полностью новый.

 - [**Абстрактная фабрика**][Abstract_Factory] может быть использована вместо **Фасада** для того, чтобы скрыть платформо-зависимые классы.

 - [**Легковес**][Flyweight] показывает, как создавать много мелких объектов, а **Фасад** показывает, как создать один объект, который отображает целую подсистему.

 - [**Посредник**][Mediator] и **Фасад** похожи тем, что пытаются организовать работу множества существующих классов.

   - **Фасад** создаёт упрощённый интерфейс к подсистеме, не внося в неё никакой добавочной функциональности. Сама подсистема не знает о существовании **Фасада**. Классы подсистемы общаются друг с другом напрямую.
  
   - [**Посредник**][Mediator] централизует общение между компонентами системы. Компоненты системы знают только о существовании [**Посредника**][Mediator], у них нет прямого доступа к другим компонентам.
 
 - **Фасад** можно сделать [**Одиночкой**][Singleton], так как обычно нужен только один объект-фасад.

 - **Фасад** похож на [**Заместитель**][Proxy] тем, что замещает сложную подсистему и может сам её инициализировать. Но в отличие от **Фасада**, [**Заместитель**][Proxy] имеет тот же интерфейс, что его служебный объект, благодаря чему их можно взаимозаменять.

[God-Object]:</src/AdditionalDocs/AntiPatterns/God-Object.md>

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>

# Приспособленец 

![UML](/src/AdditionalDocs/uml/Flyweight.png)

Позволяет вместить большее количество объектов в отведённую оперативной память за счёт **экономного разделения общего состояния объектов между собой, вместо хранения одинаковых данных в каждом объекте.**

**Неизменяемые данные объекта принято называть «*внутренним состоянием*». Все остальные данные - это «*внешнее состояние*»**.

#### Неизменяемость Легковесов

Так как **объекты легковесов** будут использованы в разных контекстах, вы должны быть уверены в том, что **их состояние невозможно изменять после создания (*final*)**. Всё внутреннее состояние легковес должен получать через параметры конструктора. Он не должен иметь сеттеров и публичных полей.

#### Фабрика Легковесов

**Flyweight** дополняет шаблон [**Factory Method**][Factory_Method] таким образом, что при обращении клиента [**Factory Method**][Factory_Method] для создания нового объекта ищет уже созданный объект с такими же параметрами, что и у требуемого, и возвращает его клиенту. Если такого объекта нет, то фабрика создаст новый.

Обычно этот метод добавляют в контейнер легковесов либо создают отдельный класс-фабрику. Его даже можно сделать статическим и поместить в класс легковесов.

## Применимость

- Когда **не хватает оперативной памяти для поддержки всех нужных объектов**.

  - Эффективность паттерна **Легковес** во многом зависит от того, как и где он используется. Применяйте этот паттерн, когда выполнены все перечисленные условия:

     - в приложении используется большое число объектов;

     - (из-за этого) высоки расходы оперативной памяти;

     - большую часть состояния объектов можно вынести за пределы их классов;

     - многие группы объектов можно заменить относительно небольшим количеством разделяемых объектов, поскольку внешнее состояние вынесено.

## Шаги реализации

1. Разделите поля класса, который станет легковесом, на две части:

   - **внутреннее состояние**: значения этих полей одинаковы для большого числа объектов.

   - **внешнее состояние (контекст)**: значения полей уникальны для каждого объекта.
   
2. **Оставьте поля внутреннего состояние в классе**, но убедитесь, что их значения неизменяемы. **Эти поля должны инициализироваться только через конструктор (final)**.

3. Превратите **поля внешнего состояния в аргументы методов**, где эти поля использовались. Затем, удалите поля из класса.

4. **Создайте фабрику, которая будет кешировать и повторно отдавать уже созданные объекты**. Клиент должен запрашивать легковеса с определённым внутренним состоянием из этой фабрики, а не создавать его напрямую.

5. Клиент должен хранить или вычислять значения внешнего состояния (контекст) и передавать его в методы объекта легковеса.

 ## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |Экономит оперативную память.|Расходует процессорное время на поиск/вычисление контекста.
 | |Усложняет код программы за счёт множества дополнительных классов.
 
 ## Отношения с другими паттернами

- [**Компоновщик**][Composite] часто совмещают с **Легковесом**, чтобы реализовать общие ветки дерева и сэкономить при этом память.

- **Легковес** показывает, как создавать много мелких объектов, а [**Фасад**][Facade] показывает, как создать один объект, который отображает целую подсистему.

- Паттерн **Легковес** может напоминать [**Одиночку**][Singleton], если для конкретной задачи у вас получилось уменьшить количество объектов к одному. Но помните, что между паттернами есть два кардинальных отличия:

  - В отличие от [**Одиночки**][Singleton], вы можете иметь множество объектов-легковесов.

  - Объекты-легковесов должны быть неизменяемыми, тогда как **объект-одиночки допускает изменение своего состояния**.
 
 
[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>

# Выделение частного класса данных

![UML](/src/AdditionalDocs/uml/Private_Class_Data.png)

Инкапсулирует данные перемещая их в другой класс. **Не дает возможности изменять переменные даже самому классу (так как они в другом классе)**

(Замена `final`)

!!!

[Java - не нужно. Больше для С#](https://stackoverflow.com/questions/42540998/private-class-data-design-pattern-in-java)

!!!
## Применимость
  
  - Когда мы хотим сделать `final after constructor`.

  - Когда у класса много атрибутов.
    
    - Мы выделяем новый класс, (или классы) которые вмещают в себя все нужные данные.

## Шаги реализации

1. Создать Дата-класс, который будет иметь одну ответственность, используя методы рефакторинга: **выделения поля и выделения метода**. Добавить все поля, которые нужно сокрыть.

2. Создайте **связь между старым и новым классом**. Старый класс, должен создавать Дата-класс передавая данные через конструктор.



[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Object_Pool]: </src/Creational/Object_Pool/Object_Pool.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prоtotype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>
[Proxy]: </src/Structural/Private_Class_Data/Private_Class_Data.md>


[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>

# Заместитель 

![UML](/src/AdditionalDocs/uml/Proxy.png)

Предоставляет суррогатный объект, управляющий доступом к другому объекту.

## Виды:

- [(Ex)](http://www.informit.com/articles/article.aspx?p=1398608) **Удалённый заместитель (*remote proxies*)**: обеспечивает связь с «Субъектом», который находится в другом адресном пространстве или на удалённой машине. Также может отвечать за кодирование запроса и его аргументов и отправку закодированного запроса реальному «Субъекту»;

- [(Ex)](/src/Structural/Proxy/Example/Virtual_proxy/) **Виртуальный заместитель (*virtual proxies*)**: **Lazy loading** обеспечивает создание реального «Субъекта» только тогда, когда он действительно понадобится. Также может кэшировать часть информации о реальном «Субъекте», чтобы отложить его создание;

- [(Ex)](/src/Structural/Proxy/Example/Protection_proxy/) **Защищающий заместитель (*protection proxies*)**: может проверять, имеет ли вызывающий объект необходимые для выполнения запроса права;

- [(Ex)](/src/Structural/Proxy/Example/Cached_proxy/) **Кэширующий прокси**: обеспечивает временное хранение результатов расчёта до отдачи их множественным клиентам, которые могут разделить эти результаты;

- **Копировать-при-записи**: обеспечивает копирование «субъекта» при выполнении клиентом определённых действий (частный случай «**виртуального прокси**»);

- **Протоколирующий прокси**: сохраняет в лог все вызовы «Субъекта» с их параметрами;

- **Экранирующий прокси**: защищает «Субъект» от опасных клиентов (или наоборот);

- **Синхронизирующий прокси**: производит синхронизированный контроль доступа к «Субъекту» в асинхронной многопоточной среде;

- ***«Умная»* ссылка (*smart reference proxy*)**: производит дополнительные действия, когда на «Субъект» создается ссылка, например, рассчитывает количество активных ссылок на «Субъект».

## Применимость

 - **Ленивая инициализация (виртуальный прокси)**. Когда у вас есть тяжёлый объект, грузящий данные из файловой системы или базы данных.

   - Вместо того чтобы грузить данные сразу после старта программы, можно сэкономить ресурсы и создать объект тогда, когда он действительно понадобится.

 - **Защита доступа (защищающий прокси)**. Когда в программе есть разные типы пользователей и вам хочется **защищать объект от неавторизованного доступа**. Например, если ваши объекты - это важная часть операционной системы, а пользователи - сторонние программы (хорошие или вредоносные).

   - Прокси может проверять доступ при каждом вызове и передавать выполнение служебному объекту, если доступ разрешён.

 - **Локальный запуск сервиса (удалённый прокси)**. Когда настоящий сервисный объект находится на удалённом сервере.

   - В этом случае заместитель транслирует запросы клиента в вызовы по сети, в протоколе, понятном удалённому сервису.

 - **Логирование запросов (логирующий прокси)**. Когда требуется хранить историю обращений к сервисному объекту.

   - Заместитель может сохранять историю обращения клиента к сервисному объекту.

 - **Кеширование объектов («умная» ссылка)** (Похоже на [Объектный пул][Object_Pool]) Когда нужно кешировать результаты запросов клиентов и управлять их жизненным циклом.

   - **Заместитель может подсчитывать количество ссылок на сервисный объект**, которые были отданы клиенту и остаются активными. Когда все ссылки освобождаются - можно будет освободить и сам сервисный объект (например, закрыть подключение к базе данных).

     Кроме того, **Заместитель** может отслеживать, не менял ли клиент сервисный объект. Это позволит использовать объекты повторно и сильно экономить ресурсы, особенно если речь идёт о больших прожорливых сервисах.

## Шаги реализации

1. Определите интерфейс, который бы сделал заместитель и оригинальный объект взаимозаменяемыми.

2. Создайте класс заместителя. Он **должен содержать ссылку на сервисный объект**. Чаще всего, сервисный объект создаётся самим заместителем. В редких случаях, заместитель получает готовый сервисный объект от клиента через конструктор.

3. Реализуйте методы заместителя в зависимости от его предназначения. В большинстве случаев, проделав какую-то полезную работу, **методы заместителя должны передать запрос сервисному объекту**.

4. **Подумайте о введении фабрики, которая решала бы какой из объектов создавать - заместитель или реальный сервисный объект**. Но с другой стороны, эта логика может быть помещена в создающий метод самого заместителя.

5. Подумайте, не реализовать ли вам **ленивую инициализацию сервисного объекта при первом обращении клиента к методам заместителя**.

## Преимущества и недостатки
 
 | + | - |
 | ------ | ------ |
 |Позволяет **контролировать сервисный объект незаметно для клиента**.|Увеличивает время отклика от сервиса.
 |Может работать, даже если сервисный объект ещё не создан.|Усложняет программу за счёт дополнительных классов.
 |Может **контролировать жизненный цикл служебного объекта**.
  
 ## Отношения с другими паттернами

- [**Адаптер**][Adapter] предоставляет классу *альтернативный интерфейс*. [**Декоратор**][Decorator] предоставляет *расширенный интерфейс*. **Заместитель** предоставляет тот же интерфейс.

- [**Фасад**][Facade] похож на **Заместитель** тем, что замещает сложную подсистему и может сам её инициализировать. Но в отличие от [**Фасада**][Facade], **Заместитель** имеет тот же интерфейс, что его служебный объект, благодаря чему их можно взаимозаменять.

- [**Декоратор**][Decorator] и **Заместитель** имеют похожие структуры, но разные назначения. Они похожи тем, что оба построены на композиции и делегировании работы другому объекту. Паттерны отличаются тем, что **Заместитель** сам управляет жизнью сервисного объекта, а обёртывание [**Декораторов**][Decorator] контролируется клиентом.

[Abstract_Factory]: </src/Creational/Factorys/Abstract_Factory/Abstract_Factory.md>
[Factory_Method]: </src/Creational/Factorys/Factory_Method/Factory_Method.md>
[Object_Pool]: </src/Creational/Object_Pool/Object_Pool.md>
[Builder]: </src/Creational/Builder/Builder.md>
[Prototype]: </src/Creational/Prototype/Prototype.md>
[Singleton]: </src/Creational/Singleton/Singleton.md>

[Adapter]: </src/Structural/Adapter/Adapter.md>
[Bridge]: </src/Structural/Bridge/Bridge.md>
[Composite]: </src/Structural/Composite/Composite.md>
[Decorator]: </src/Structural/Decorator/Decorator.md>
[Facade]: </src/Structural/Facade/Facade.md>
[Flyweight]: </src/Structural/Flyweight/Flyweight.md>
[Proxy]: </src/Structural/Proxy/Proxy.md>

[Chain_of_Responsibility]: </src/Behavioral/Chain_of_Responsibility/Chain_of_Responsibility.md>
[Command]: </src/Behavioral/Command/Command.md>
[Iterator]: </src/Behavioral/Iterator/Iterator.md>
[Mediator]: </src/Behavioral/Mediator/Mediator.md>
[Memento]: </src/Behavioral/Memento/Memento.md>
[Observer]: </src/Behavioral/Observer/Observer.md>
[State]: </src/Behavioral/State/State.md>
[Strategy]: </src/Behavioral/Strategy/Strategy.md>
[Template_Method]: </src/Behavioral/Template_Method/Template_Method.md>
[Visitor]: </src/Behavioral/Visitor/Visitor.md>

